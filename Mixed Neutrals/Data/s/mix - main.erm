ZVSE2
; Author:   Berserker aka EtherniDee
; Engine:   ERM 2.0+
; Requires: ERA 3.3+, Era Erm Framework

; TODO:
; 1) Fix 1 dragon to be preserved among neutrals
; 2) Normalize float rel quantities in ReadTileNeutrals to be 1 in sum, increasing/decreasing TotalFightValue

; === TYPES ===
; TFactions = array ? of TFaction;
;   Represents all registered factions, where each index is real faction ID + 1 (thus Neutrals are 0).

; TFaction = array ? of MonId: integer;
;   Represents all registered monsters of single faction.

; TNeutrals = array 7 of record
;   MonType:  integer;
;   Quantity: integer; calculated real number of monsters
; end;
;
;   Contains mixed neutrals, that human attacker will face in battle.

; TNeutralsConfig = record
;   Stacks: array 7 of record
;     MonType:          integer;
;     RelativeQuantity: float;   multiplier of total monsters power, used to change final stack quantity for humans
;   end;
;
;   SpreadMask: integer; Three bits for each 0..6 stack (see MIX_SPREAD_XXX constants). Specifies strategy to spread stack among free slots.
;
;   Contains mixed neutrals configuration for adventure map tile.
;   Each stack quantity will be calculated as TotalFightValue * RelativeQuantity / FightValue of particular monster type


; ============== PUBLIC ==============
; These settings should be configured in json or changed programmatically. Do not edit this file.
!#VRi^mix_on^:S(TRUE);                            Global mod presence flag for other mods
!#VRi^mix_enabled^:S(TRUE);                       Automatical conversion of regular neutrals to mixed neutrals is enabled or not.
!#VRi^mix_minNumNeutralStacks^:S2;                Minimum number of mixed neutral stacks in battle.
!#VRi^mix_maxNumNeutralStacks^:S4;                Maximum Number of mixed neutral stacks in battle.
!#VRi^mix_neutralStackSpread^:S(MIX_SPREAD_SPACE_BETWEEN); Default spread strategy for neutral stacks.
!#VRi^mix_neutralStackScale^:S100;                Multiplier for original neutrals quantity on adventure map in percents.
!#VRi^mix_neutralStackScaleForHuman^:S100;         Additional multiplier of neutrals power only for humans in percents.
!#VRi^mix_neutralsAggressionModifier^:S0;         Value to add to neutrals aggression level. May be negative.
                                     ;            Normal values range: 0 - compliant, 1..9 - gradation of aggression, 10 - savage.
!#VRi^mix_neutralsNeverEscape^:S(FALSE);          If true, neutrals will never try to escape.
!#VRi^mix_generateMonstersByFactions^:S(TRUE);    If true, additional generated monsters will belong to the same faction.
!#VAi^mix_allowAlliedFactions^:S(TRUE);           If true, allied faction monsters will also be generated.
!#VRi^mix_moveNeutralsToFactions^:S(TRUE);        If true, all WoG neutral monsters will be assigned a faction / town.
!#VRi^mix_registerRegularMonsters^:S(TRUE);       If true, all regular WoG creatures are registered and will become accessible for generation.
!#VRi^mix_registerFactionAllies^:S(TRUE);         If true, configurates each faction allies and their association level.
!#VRi^mix_minRelativeMonLevel^:S-(MON_MAX_LEVEL); Minimum relative level for generated monsters, as compared to base monster level. -6..+6.
!#VRi^mix_maxRelativeMonLevel^:S(MON_MAX_LEVEL);  Maximum relative level for generated monsters, as compared to base monster level. -6..+6.
; ============ END PUBLIC ============


!?FU(mix_InitStructs);
!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?i^mix_factions^;        // List[index: factionId - NO_TOWN] of list of faction monster ID, ordered by monster level
!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?i^mix_factionAllies^;
!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?i^mix_monToFactionInd^; // List[index: monId] of faction ID - NO_TOWN
!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?i^mix_faction_levels^;  // List[index: factionId - NO_TOWN] of list[index: monLevel] of accumCount(monLevel monsters).
!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?i^mix_monsters^;        // List of all registered monsters, sorted by monster level
!!SN:M(M_AUTO_ID)/100/(M_INT)/(M_TEMP)/?i^mix_temp_buf^;        // Temporary buffer
!!SN:M(M_AUTO_ID)/(MON_NUM_LEVELS)/(M_INT)/(M_STORED)/?i^mix_monster_levels^; // List[index: monLevel] of accumCount(monLevel monsters).

!!VRi^mix_monsRegistrationState^:S(MIX_MONS_NOT_REGISTERED);
!!VRi^mix_randomSeed^:T0/0/(INT_MAX);

!#FU(mix_InitStructs):P;

!?FU(mix_LoadGlobalConfig);
!!FU(LoadIntGlobalsFromJson):P^mix.global.^/^mix_^/
  ^minNumNeutralStacks^/^maxNumNeutralStacks^/^neutralStackSpread^/^neutralStackScale^/^neutralStackScaleForHuman^/^neutralsAggressionModifier^/
  ^neutralsNeverEscape^/^generateMonstersByFactions^/^allowAlliedFactions^/^moveNeutralsToFactions^/^registerRegularMonsters^/^registerFactionAllies^;

!!FU(LoadIntGlobalsFromJson):P^mix.global.^/^mix_^/^minRelativeMonLevel^/^maxRelativeMonLevel^/^enabled^;

!!VRi^mix_minNumNeutralStacks^:F1/(MIX_MAX_NEUTRAL_STACKS);
!!VRi^mix_maxNumNeutralStacks^:Fi^mix_minNumNeutralStacks^/(MIX_MAX_NEUTRAL_STACKS);
!!VRi^mix_neutralStackSpread^:F(MIX_NO_SPREAD)/(MIX_SPREAD_LAST_STRATEGY);
!!VRi^mix_neutralStackScale^:F1/410000;
!!VRi^mix_neutralStackScaleForHuman^:F1/41000000;
!!VRi^mix_neutralsAggressionModifier^:F(ADV_MON_AGGRESSION_MIN)/(ADV_MON_AGGRESSION_MAX);
!!VRi^mix_enabled^:F(FALSE)/(TRUE);

!#FU(mix_LoadGlobalConfig):P;

!?FU(OnAfterErmInited)&i^mix_moveNeutralsToFactions^<>(FALSE);
!!MA:O(MON_GOLD_GOLEM)/(TOWN_TOWER);
!!MA:O(MON_DIAMOND_GOLEM)/(TOWN_TOWER);
!!MA:O(MON_AZURE_DRAGON)/(TOWN_TOWER);
!!MA:O(MON_CRYSTAL_DRAGON)/(TOWN_CONFLUX);
!!MA:O(MON_FAERIE_DRAGON)/(TOWN_RAMPART);
!!MA:O(MON_RUST_DRAGON)/(TOWN_FORTRESS);
!!MA:O(MON_ENCHANTER)/(TOWN_TOWER);
!!MA:O(MON_SHARPSHOOTER)/(TOWN_RAMPART);
!!MA:O(MON_HALFLING)/(TOWN_CASTLE);
!!MA:O(MON_PEASANT)/(TOWN_CASTLE);
!!MA:O(MON_BOAR)/(TOWN_STRONGHOLD);
!!MA:O(MON_MUMMY)/(TOWN_NECROPOLIS);
!!MA:O(MON_NOMAD)/(TOWN_STRONGHOLD);
!!MA:O(MON_ROGUE)/(TOWN_CASTLE);
!!MA:O(MON_TROLL)/(TOWN_STRONGHOLD);

!!re i/(MON_SUPREME_ARCHANGEL)/(MON_SACRED_PHOENIX):;
  !!VR(faction:y):Si -(MON_SUPREME_ARCHANGEL);
  !!MA:Oi/(faction);
!!en:;

!!MA:O(MON_GHOST)/(TOWN_NECROPOLIS);

!!re i/(MON_FIRE_MESSENGER)/(MON_WATER_MESSENGER):;
  !!MA:Oi/(TOWN_CONFLUX);
!!en:;

!!MA:O(MON_GORYNYCH)/(TOWN_FORTRESS);
!!MA:O(MON_WAR_ZEALOT)/(TOWN_CASTLE);
!!MA:O(MON_ARCTIC_SHARPSHOOTER)/(TOWN_TOWER);
!!MA:O(MON_LAVA_SHARPSHOOTER)/(TOWN_INFERNO);
!!MA:O(MON_NIGHTMARE)/(TOWN_NECROPOLIS);
!!MA:O(MON_SANTA_GREMLIN)/(TOWN_TOWER);
!!MA:O(MON_SYLVAN_CENTAUR)/(TOWN_RAMPART);
!!MA:O(MON_SORCERESS)/(TOWN_CONFLUX);
!!MA:O(MON_WEREWOLF)/(TOWN_STRONGHOLD);
!!MA:O(MON_HELL_STEED)/(TOWN_INFERNO);
!!MA:O(MON_DRACOLICH)/(TOWN_NECROPOLIS);

!?FU(OnAfterErmInited)&i^mix_registerFactionAllies^<>(FALSE);
!!FU(mix_SetFactionAllies):P(TOWN_CASTLE)/100/(TOWN_RAMPART)/50;
!!FU(mix_SetFactionAllies):P(TOWN_RAMPART)/100/(TOWN_CASTLE)/50;
!!FU(mix_SetFactionAllies):P(TOWN_TOWER)/100/(TOWN_CONFLUX)/50;
!!FU(mix_SetFactionAllies):P(TOWN_INFERNO)/100/(TOWN_NECROPOLIS)/50/(TOWN_DUNGEON)/50;
!!FU(mix_SetFactionAllies):P(TOWN_NECROPOLIS)/100/(TOWN_INFERNO)/50/(TOWN_DUNGEON)/50;
!!FU(mix_SetFactionAllies):P(TOWN_DUNGEON)/100/(TOWN_INFERNO)/50/(TOWN_NECROPOLIS)/50;
!!FU(mix_SetFactionAllies):P(TOWN_STRONGHOLD)/100/(TOWN_FORTRESS)/50;
!!FU(mix_SetFactionAllies):P(TOWN_FORTRESS)/100/(TOWN_STRONGHOLD)/50;
!!FU(mix_SetFactionAllies):P(TOWN_CONFLUX)/100/(TOWN_TOWER)/50;

!?FU(OnAfterErmInited);
!!VR(minMonTableSize:y):S(MON_LAST_WOG) +1;
!!FU(Array_EnsureMinSize):P^mix_monToFactionInd^/(minMonTableSize)/(MIX_UNSET_FACTION);

!!VRi^mix_monsRegistrationState^:S(MIX_MONS_ARE_REGISTERING);
!!FU(mix_OnRegisterRegularMonsters):P;
!!VRi^mix_monsRegistrationState^:S(MIX_MONS_ARE_REGISTERED);

!!FU(mix_OptimizeMonsterStructs):P;

!?FU(mix_OnRegisterRegularMonsters)&i^mix_registerRegularMonsters^<>(FALSE);
!!FU(mix_RegisterRegularMonsterRange):P(MON_PIKEMAN)/(MON_MAGIC_ELEMENTAL);
!!FU(mix_RegisterRegularMonsterRange):P(MON_PIKEMAN)/(MON_MAGIC_ELEMENTAL);
!!FU(mix_RegisterRegularMonsterRange):P(MON_ICE_ELEMENTAL)/(MON_ICE_ELEMENTAL);
!!FU(mix_RegisterRegularMonsterRange):P(MON_MAGMA_ELEMENTAL)/(MON_MAGMA_ELEMENTAL);
!!FU(mix_RegisterRegularMonsterRange):P(MON_STORM_ELEMENTAL)/(MON_STORM_ELEMENTAL);
!!FU(mix_RegisterRegularMonsterRange):P(MON_ENERGY_ELEMENTAL)/(MON_TROLL);
!!FU(mix_RegisterRegularMonsterRange):P(MON_SUPREME_ARCHANGEL)/(MON_GHOST);
!!FU(mix_RegisterRegularMonsterRange):P(MON_FIRE_MESSENGER)/(MON_SANTA_GREMLIN);
!!FU(mix_RegisterRegularMonsterRange):P(MON_SYLVAN_CENTAUR)/(MON_DRACOLICH);

!?FU(OnAdventureMapRightMouseClick);
!!CM:P?(x:y)/?(y:y)/?(z:y) A?(screenX:y)/?(screenY:y);
!!OB(x)/(y)/(z):T?(objType:y);
!!FU&(objType)<>(OBJ_MONSTER):E;

!!TR(x)/(y)/(z):V?(visibility:y);
!!OW:C?(player:y);
!!VR(visibilityBit:y):S1 Sd<<(player) &(visibility);
!!FU&(visibilityBit)=0:E;

!!SN:M(M_AUTO_ID)/(MIX_NEUTRALS_STRUCT_SIZE)/(M_INT)/(M_TRIGGER_LOCAL)/?(neutrals:y);
!!FU(mix_ReadTileNeutrals):P(x)/(y)/(z)/(neutrals)/?(success:y);
!!FU&(success)=(FALSE):E;

!!VR(showFuzzyNumbers:y):S(TRUE);
!!VR(disablePopup:y):S(FALSE);
!!FU(mix_OnViewNeutrals):P?(showFuzzyNumbers)/?(disablePopup)/(neutrals)/(x)/(y)/(z);
!!FU&(disablePopup)<>(FALSE):E;

!!CM:R(FALSE);

!!VR(dlgId:y):S(MIX_VIEW_NEUTRALS_DLG_ID);

; Detect possibility to display dialog with bigger icons if only default wog creatures range is used by game
!!FU(GetMaxMonsterId):P?(maxMonsterId:y);
!!VR(dlgId)&(maxMonsterId)<=(MON_LAST_WOG):S(MIX_VIEW_NEUTRALS_ALT_DLG_ID);

!!DL(dlgId):N^mixneutr.txt^;

!!FU(mix_GetAdvMapMonInfo):P(x)/(y)/(z)/?(origMonType:y);
!!VR(dlgCaption:z):S^^;
!!SN&(origMonType)<>(NO_MON):H^monname^/(origMonType)/1/?(dlgCaption);
!!DL(dlgId):A(MIX_VIEW_NEUTRALS_DLG_CAPTION_ID)/(DLG_CMD_SET_TEXT)/(dlgCaption);

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!VR(pairInd:y):Si *2;
  !!SN:V(neutrals)/(pairInd)/?(monType:y)/?(monNum:y);

  !!if&(monType)<>(NO_MON):;
    !!if&(showFuzzyNumbers)<>(FALSE):;
      !!FU(MonCountToFuzzyText):P(monNum)/?(monNumStr:z)/(MON_FUZZY_COUNT_EXTRA_SHORT);
    !!el:;
      !!FU(FormatQuantity):P(monNum)/?(monNumStr:z)/(MIX_VIEW_NEUTRALS_DLG_MON_NUM_MAX_LEN)/(MIX_VIEW_NEUTRALS_DLG_MON_NUM_MAX_DIGITS);
      !!VR(monNumStr):S^{~DFFFFD}%(monNumStr){~}^;
    !!en;

    !!VR(picItemId:y):S(MIX_VIEW_NEUTRALS_DLG_FIRST_MON_DEF_ID) +i;
    !!VR(picLabelItemId:y):S(MIX_VIEW_NEUTRALS_DLG_FIRST_MON_LABEL_ID) +i;
    !!VR(defFrame:y):S(monType) +2;

    !!DL(dlgId):A(picItemId)/(DLG_CMD_SET_DEF_FRAME)/(defFrame);
    !!DL(dlgId):A(picLabelItemId)/(DLG_CMD_SET_TEXT)/(monNumStr);
  !!en;
!!en:;

!!FU(DL_GetSize):P(dlgId)/?(dlgWidth:y)/?(dlgHeight:y);
!!VR(dlgX:y):S(dlgWidth) :-2 +(screenX);
!!VR(dlgY:y):S(dlgHeight) :-2 +(screenY);
!!FU(DL_Coords):P(dlgId)/(dlgX)/(dlgY);
!!FU(DL_ShowPopup):P(dlgId);

!?FU(OnAdvMapTileHint);
!#VA(x:x) (y:x) (z:x) (objType:x) (monType:x);
!!FU&(objType)<>(OBJ_MONSTER):E;

!!TR(x)/(y)/(z):V?(visibility:y);
!!OW:C?(player:y);
!!VR(visibilityBit:y):S1 Sd<<(player) &(visibility);
!!FU&(visibilityBit)=0:E;

!!FU(mix_GetTileNeutralsConfig):P(x)/(y)/(z)/?(config:y);
!!FU&(config)=(NULL):E;

; Calculate sum of relative float quantities to get scale koefficient
!!VR(scaleFloat:e):S0;

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!VR(pairInd:y):Si *2;
  !!SN:V(config)/(pairInd)/?t/?(slotQtyFloat:e);
  !!VR(scaleFloat):+(slotQtyFloat);
!!en:;

!!SN:H^monname^/(monType)/1/?(monName:z);
!!MO(x)/(y)/(z):G?(monNum:y);
!!VR(monNumFloat:e):S(monNum) *(scaleFloat) F(INT_MIN)/(INT_MAX);
!!VR(monNum):S(monNumFloat);
!!VR(monNum)&(monNum)<0:S(INT_MAX);
!!FU(MonCountToFuzzyText):P(monNum)/?(monNumStr:z)/(MON_FUZZY_COUNT_HUMAN_FRIENDLY);

!!MM:M^%(monNumStr) %(monName)^;

!#TM97:S1/1/1/(BITS_8_MASK);

!?TM97&i^timerDay^=1/i^timerOnce^=1/i^mix_enabled^<>(FALSE);
!!FU(mix_InitializeNeutrals):P;

!?FU(mix_InitializeNeutrals);
; Create shortcuts to global settings
!!VR(minNumNeutralStacks:y):Si^mix_minNumNeutralStacks^;
!!VR(maxNumNeutralStacks:y):Si^mix_maxNumNeutralStacks^;
!!VR(neutralStackSpread:y):Si^mix_neutralStackSpread^ &7;
!!VR(neutralStackScale:y):Si^mix_neutralStackScale^;
!!VR(netralStackScaleForHuman:y):Si^mix_neutralStackScaleForHuman^;
!!VR(generateMonstersByFactions:y):Si^mix_generateMonstersByFactions^;
!!VR(allowAlliedFactions:y):Si^mix_allowAlliedFactions^;
!!VR(minRelativeMonLevel:y):Si^mix_minRelativeMonLevel^;
!!VR(maxRelativeMonLevel:y):Si^mix_maxRelativeMonLevel^;
!!VR(spreadMask:y):S0;

; Generate spread mask for all stacks
!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!VR(spreadMask):Sd<<3 |(neutralStackSpread);
!!en:;

; Generate stack positions table if spreading is used
; It determines in which positions should generated stacks be placed in particular order
; Up to 7 positions for each of 1..7 number of stacks.
!!if&(neutralStackSpread)<>(MIX_NO_SPREAD):;
  !#VA(stackPosTable[28]:y);
  !!VR(stackPosTable[0]):C3;
  !!VR(stackPosTable[1]):C1/5;
  !!VR(stackPosTable[3]):C3/1/5;
  !!VR(stackPosTable[6]):C2/4/0/6;
  !!VR(stackPosTable[10]):C3/4/0/1/6;
  !!VR(stackPosTable[15]):C3/4/1/5/0/6;
  !!VR(stackPosTable[21]):C3/2/4/1/5/0/6;
!!en;

; Process each monster on adventure map
!!VR(x:y):S-1;

!!re i:;
  !!UN:U(OBJ_MONSTER)/(ANY_OBJ)/-1/(x)/(y:y)/(z:y);
  !!br&(x)<0:;

  ; Get monster type and faction
  !!OB(x)/(y)/(z):U?(origMonType:y);
  !!MA:O(origMonType)/?(origMonFaction:y) L(origMonType)/?(origMonLevel:y);

  ; Scale adventure map monsters quantity
  !!if&(neutralStackScale)<>100:;
    !!MO(x)/(y)/(z):G?(advMonQty:y);
    !!VR(advMonQty):*(neutralStackScale) :100 F1/(ADV_MAP_MON_MAX_QUANTITY);
    !!MO(x)/(y)/(z):G(advMonQty);
  !!en;

  ; Get tile config
  !!FU(mix_GetTileNeutralsConfig):P(x)/(y)/(z)/?(config:y)/(MIX_AUTOCREATE_NEUTRALS_CONFIG);

  ; Check if there is custom settings for given monsters type
  !!VR(baseKey:z):S^mix.mon%(origMonType)^;
  !!VR(groupKey:z):S(baseKey);
  !!VR(key:z):S^%(baseKey).custom^;
  !!SN:T(key)/?(valueStr:z);
  !!VR(hasCustomSettings:y):V(valueStr);

  ; Fallback to global template for any monster
  !!if&(hasCustomSettings)=(FALSE):;
    !!VR(baseKey):S^mix.monANY^;
    !!VR(groupKey):S(baseKey);
    !!VR(key):S^%(baseKey).custom^;
    !!SN:T(key)/?(valueStr:z);
    !!VR(hasCustomSettings):V(valueStr);
  !!en;

  !!if&(hasCustomSettings)<>(FALSE):;
    ; Allocate and initialize spreads list
    !#VA(slotSpreads[MIX_MAX_NEUTRAL_STACKS]:y);
    !!VR(slotSpreads):C(MIX_NO_SPREAD)/(MIX_NO_SPREAD)/(MIX_NO_SPREAD)/(MIX_NO_SPREAD)/(MIX_NO_SPREAD)/(MIX_NO_SPREAD)/(MIX_NO_SPREAD);

    ; Setup tile basic config
    !!SN:V(config)/0/(NO_MON)/(MIX_DEFAULT_SLOT_POWER)/(NO_MON)/(MIX_DEFAULT_SLOT_POWER)/(NO_MON)/(MIX_DEFAULT_SLOT_POWER)/(NO_MON)/(MIX_DEFAULT_SLOT_POWER)
                    /(NO_MON)/(MIX_DEFAULT_SLOT_POWER)/(NO_MON)/(MIX_DEFAULT_SLOT_POWER)/(NO_MON)/(MIX_DEFAULT_SLOT_POWER);

    ; Generate random floating point number in [0..1] range
    !!VR(randomInt:y):R0/0/(INT_MAX);
    !!VR(randomFloat:e):S(randomInt) :(INT_MAX);

    ; Process alternative groups
    !!re g/0/(INT_MAX)/0:;
      ; Determine alternative probability
      !!VR(key:z):S^%(baseKey).probability^;
      !!SN:T(key)/?(valueStr:z);
      !!VR(probability:e):S1;
      !!VR(probability)&(key)<>(valueStr):V(valueStr) :100;
      !!VR(probability)&(probability)<0:S0;

      ; Adjust random float point
      !!VR(randomFloat):-(probability);

      ; Got it, it's our alternative group
      !!if&(randomFloat)<=0:;
        ; Process each slot
        !!re j/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
          ; Get config for current slot
          !!VR(slotKey:z):S^%(baseKey).slot%j^;
          !!VR(key:z):S^%(slotKey).type^;
          !!SN:T(key)/?(valueStr:z);

          ; Config found
          !!if&(key)<>(valueStr):;
            ; Determine slot type
            !!SN:C(valueStr)/?(slotType:y)/?(constExists:y);
            !!VR(slotType)&(constExists)=(FALSE):V(valueStr);

            ; Initialize slot remaining probability = 100% = 1.0
            !!VR(remainingProbability:e):S1;

            ; Generate random floating point number in [0..1] range
            !!VR(randomInt:y):R0/0/(INT_MAX);
            !!VR(randomFloat:e):S(randomInt) :(INT_MAX);

            ; Process all slot alternatives
            !!re r/0/(INT_MAX)/0:;
              ; Determine alternative probability
              !!VR(key:z):S^%(slotKey).probability^;
              !!SN:T(key)/?(valueStr:z);
              !!VR(probability:e):S1;
              !!VR(probability)&(key)<>(valueStr):V(valueStr) :100;
              !!VR(probability)&(probability)<0:S0;

              ; Adjust random float point
              !!VR(randomFloat):-(probability);

              ; Got it, it's our alternative
              !!if&(randomFloat)<=0:;
                ; Get current slot values
                !!VR(pairInd:y):Sj *2;
                !!VR(spreadShiftInd:y):Sj *3;
                !!SN:V(config)/(pairInd)/?(currSlotType:y)/?(slotPower:y);
                !!VR(slotSpread:y):S(@slotSpreads) +j Sy(slotSpread);

                ; Override spread if specified
                !!VR(key:z):S^%(slotKey).spread^;
                !!SN:T(key)/?(valueStr:z);

                !!if&(key)<>(valueStr):;
                  !!SN:C(valueStr)/?(slotSpread)/?(constExists:y);
                  !!VR(slotSpread)&(constExists)=(FALSE):V(valueStr);
                  !!VR(slotSpread)|(slotSpread)<(MIX_SPREAD_FIRST_STRATEGY)/(slotSpread)>(MIX_SPREAD_LAST_STRATEGY):S(MIX_NO_SPREAD);
                !!en;

                ; Override power if specified
                !!VR(key:z):S^%(slotKey).power^;
                !!SN:T(key)/?(valueStr:z);
                !!VR(slotPower)&(key)<>(valueStr):V(valueStr) F0/(MIX_MAX_SLOT_POWER);

                ; Determine random monster level requirements
                !!VR(minMonLevel:y):S(MON_MIN_LEVEL);
                !!VR(key:z):S^%(slotKey).min_level^;
                !!SN:T(key)/?(valueStr:z);

                !!if&(key)<>(valueStr):;
                  !!SN:C(valueStr)/?(minMonLevel)/?(constExists:y);
                  !!VR(minMonLevel)&(constExists)=(FALSE):V(valueStr);

                  !!if&(minMonLevel)>=(MIX_MON_ABS_LEVEL_FIRST)/(minMonLevel)<=(MIX_MON_ABS_LEVEL_LAST):;
                    !!VR(minMonLevel):-(MIX_MON_ABS_LEVEL_FIRST);
                  !!el:;
                    !!VR(minMonLevel):+(origMonLevel) F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
                  !!en;
                !!en;

                !!VR(maxMonLevel:y):S(MON_MAX_LEVEL);
                !!VR(key:z):S^%(slotKey).max_level^;
                !!SN:T(key)/?(valueStr:z);

                !!if&(key)<>(valueStr):;
                  !!SN:C(valueStr)/?(maxMonLevel)/?(constExists:y);
                  !!VR(maxMonLevel)&(constExists)=(FALSE):V(valueStr);

                  !!if&(maxMonLevel)>=(MIX_MON_ABS_LEVEL_FIRST)/(maxMonLevel)<=(MIX_MON_ABS_LEVEL_LAST):;
                    !!VR(maxMonLevel):-(MIX_MON_ABS_LEVEL_FIRST) F(minMonLevel)/(MON_MAX_LEVEL);
                  !!el:;
                    !!VR(maxMonLevel):+(origMonLevel) F(minMonLevel)/(MON_MAX_LEVEL);
                  !!en;
                !!en;

                ; Determine real slot type
                !!if&(slotType)=(MIX_MON_TYPE_BASE):;
                  !!VR(slotType):S(origMonType);
                !!el&(slotType)=(MIX_MON_TYPE_FACTION):;
                  !!FU(mix_GenerateFactionMonster):P(origMonFaction)/(FALSE)/?(slotType)/(minMonLevel)/(maxMonLevel);
                !!el&(slotType)=(MIX_MON_TYPE_ALLY):;
                  !!FU(mix_GenerateFactionMonster):P(origMonFaction)/(TRUE)/?(slotType)/(minMonLevel)/(maxMonLevel);
                !!el&(slotType)=(MIX_MON_TYPE_RANDOM):;
                  !!FU(mix_GenerateRandomMonster):P?(slotType)/(minMonLevel)/(maxMonLevel);
                !!el&(slotType)>=(MIX_COPY_FROM_SLOT_0)/(slotType)<=(MIX_COPY_FROM_SLOT_6):;
                  !!VR(targetPairInd:y):S(slotType) -(MIX_COPY_FROM_SLOT_0) *2;
                  !!SN:V(config)/(targetPairInd)/?(slotType);
                !!en;

                !!VR(slotType)&(slotType)<(MON_FIRST):S(NO_MON);

                ; Copy current slot to other slots if specified
                !!VR(key:z):S^%(slotKey).copy_to^;
                !!SN:T(key)/?(valueStr:z);

                ; Found something like "0 3 5 6" - list of slots to copy current slot to
                !!if&(key)<>(valueStr):;
                  !!re (tokenInd:y)/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
                    ; Get next target slot index
                    !!VR(token:z):M2/(valueStr)/(tokenInd);
                    !!br&(token)=^^:;
                    !!VR(targetSlot:y):V(token);
                    !!co|(targetSlot)<0/(targetSlot)>=(MIX_MAX_NEUTRAL_STACKS):;

                    ; Perform copying
                    !!VR(targetPairInd:y):S(targetSlot) *2;
                    !!SN:V(config)/(targetPairInd)/(slotType)/(slotPower);
                    !!VR(targetSlotSpreadPtr:y):S(@slotSpreads) +(targetSlot);
                    !!VRy(targetSlotSpreadPtr):S(slotSpread);
                  !!en:; re
                !!en; if

                ; Override slot value in config
                !!SN:V(config)/(pairInd)/(slotType)/(slotPower);
                !!VR(slotSpreadPtr:y):S(@slotSpreads) +j;
                !!VRy(slotSpreadPtr):S(slotSpread);

                !!br:;
              !!en; if

              ; Try to get next slot alternative from config
              !!VRr:+1;
              !!VR(slotKey:z):S^%(baseKey).slot%j_alt%r^;
              !!VR(key:z):S^%(slotKey).type^;
              !!SN:T(key)/?(valueStr:z);

              ; No more alternatives
              !!br&(key)=(valueStr):;

              ; Determine slot type
              !!SN:C(valueStr)/?(slotType:y)/?(constExists:y);
              !!VR(slotType)&(constExists)=(FALSE):V(valueStr);
            !!en:; re
          !!en; if
        !!en:; re

        ; Build slots spread mask
        !!VR(customSpreadMask:y):S0;

        !!re j/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
          !!VR(bitShifting:y):Sj *3;
          !!VR(slotSpread:y):S(@slotSpreads) +j Sy(slotSpread) Sd<<(bitShifting);
          !!VR(customSpreadMask):|(slotSpread);
        !!en:;

        !!SN:V(config)/-1/(customSpreadMask);

        !#VA(-slotSpreads);

        ; Convert integer monster powers into floats
        !!VR(totalPower:y):S0;

        ; Calculate total stacks power
        !!re j/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
          !!VR(pairInd:y):Sj *2;
          !!SN:V(config)/(pairInd)/?(slotType:y)/?(slotPower:y);
          !!co&(slotType)=(NO_MON):;

          !!VR(totalPower):+(slotPower);
        !!en:;

        !!VR(totalPower)&(totalPower)=0:S1;

        ; Calculate and save relative power for each stack
        !!re j/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
          !!VR(pairInd:y):Sj *2;
          !!SN:V(config)/(pairInd)/?(slotType:y)/?(slotPower:y);
          !!co&(slotType)=(NO_MON):;

          !!VR(singleStackRelQty:e):S(slotPower) :(totalPower) *(netralStackScaleForHuman) :100;
          !!SN:V(config)/(pairInd)/(slotType)/(singleStackRelQty);
        !!en:;

        !!br:;
      !!en:; if

      ; Try to get next group alternative from config
      !!VRg:+1;
      !!VR(baseKey):S^%(groupKey)_alt%g^;
      !!VR(key):S^%(baseKey).custom^;
      !!SN:T(key)/?(valueStr:z);

      ; No more alternatives
      !!br&(key)=(valueStr):;
    !!en:; re
  !!el:; Automatical generation
    ; Reset tile config
    !!SN:V(config)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0;

    ; Determine number of stacks and relative monsters quantity per stack
    !!VR(numNeutralStacks:y):R0/(minNumNeutralStacks)/(maxNumNeutralStacks);
    !!VR(singleStackRelQty:e):S1 *(netralStackScaleForHuman) :100 :(numNeutralStacks);

    ; Set spread for all stacks
    !!SN:V(config)/-1/(spreadMask);

    ; Prepare positions decision algos and place main stack
    !!if&(neutralStackSpread)=(MIX_NO_SPREAD):;
      !!VR(sign:y):S1;
      !!VR(stackInd:y):S3;
    !!el&(neutralStackSpread)=(MIX_SPREAD_RANDOM):;
      !!VR(freeSlots[7]:y):C0/1/2/3/4/5/6;
      !!VR(numFreeSlots:y):S7;

      !!VR(freeSlotArrInd:y):R0/1/(numFreeSlots) -1;
      !!VR(freeSlotPtr:y):S(freeSlotArrInd) +(@freeSlots);
      !!VR(stackInd):Sy(freeSlotPtr);

      !!VR(numFreeSlots):-1;
      !!VR(lastFreeSlotPtr:y):S(numFreeSlots) +(@freeSlots);
      !!VRy(freeSlotPtr):Sy(lastFreeSlotPtr);
    !!el:;
      !!VRt:S(numNeutralStacks) -1;
      !!VR(posTableItemPtr:y):St *t +t :2 +(@stackPosTable);
      !!VR(stackInd:y):Sy(posTableItemPtr);
      !!VR(posTableItemPtr):+1;
    !!en;

    !!VR(pairInd:y):S(stackInd) *2;
    !!SN:V(config)/(pairInd)/(origMonType)/(singleStackRelQty);

    ; Determine new monsters level requirements
    !!VR(minMonLevel:y):S(origMonLevel) +(minRelativeMonLevel) F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
    !!VR(maxMonLevel:y):S(origMonLevel) +(maxRelativeMonLevel) F(minMonLevel)/(MON_MAX_LEVEL);

    ; Generate additional stacks
    !!re j/1/(numNeutralStacks)/1/-1:;
      ; Determine new stack position
      !!if&(neutralStackSpread)=(MIX_NO_SPREAD):;
        ; Generate random monsters from center
        !!VR(sign):*-1;
        !!VR(posModifier:y):Sj *(sign);
        !!VR(stackInd):+(posModifier);
      !!el&(neutralStackSpread)=(MIX_SPREAD_RANDOM):;
        !!VR(freeSlotArrInd):R0/1/(numFreeSlots) -1;
        !!VR(freeSlotPtr):S(freeSlotArrInd) +(@freeSlots);
        !!VR(stackInd):Sy(freeSlotPtr);

        !!VR(numFreeSlots):-1;
        !!VR(lastFreeSlotPtr):S(numFreeSlots) +(@freeSlots);
        !!VRy(freeSlotPtr):Sy(lastFreeSlotPtr);
      !!el:;
        !!VR(stackInd):Sy(posTableItemPtr);
        !!VR(posTableItemPtr):+1;
      !!en;

      ; Support custom random monster generators
      !!VR(randomMonType:y):S(NO_MON);
      !!FU(mix_CustomGenerateRandomMonster):P?(randomMonType)/(origMonType)/(x)/(y)/(z);

      ; Provide fallback if no user monster generation function is provided
      !!if&(randomMonType)=(NO_MON):;
        !!if&(generateMonstersByFactions)<>(FALSE):;
          !!FU(mix_GenerateFactionMonster):P(origMonFaction)/(allowAlliedFactions)/?(randomMonType)/(minMonLevel)/(maxMonLevel);
        !!el:;
          !!FU(mix_GenerateRandomMonster):P?(randomMonType)/(minMonLevel)/(maxMonLevel);
        !!en;
      !!en;

      ; Assign stack to virtual slot
      !!VR(pairInd:y):S(stackInd) *2;
      !!SN:V(config)/(pairInd)/(randomMonType)/(singleStackRelQty);
    !!en:; re
  !!en; el
!!en:; re

; Support for "neutralsAggressionModifier" and "neutralsNeverEscape" options
!?OB(OBJ_MONSTER)/(ANY_MON);
!!MO998:R?(aggression:y)/1;
!!VR(aggression):+i^mix_neutralsAggressionModifier^ F(ADV_MON_AGGRESSION_MIN)/(ADV_MON_AGGRESSION_MAX);
!!MO998:R(aggression)/1;

!!MO998&i^mix_neutralsNeverEscape^<>(FALSE):U(TRUE);

!?FU(OnBeforeBattleUniversal);
!!VRi^mix_isMixedNeutralsBattle^:S(FALSE);

!?FU(OnBeforeBattleUniversal)&i^battle_human_0^=(TRUE)/i^battle_owner_1^=(NO_OWNER);
!!BA:P?(x:y)/?(y:y)/?(z:y);

; Get original monster info, exit if siege or any error
!!FU(mix_GetAdvMapMonInfo):P(x)/(y)/(z)/?(origMonType:y)/?(origMonNum:y);
!!FU|(origMonType)=(NO_MON)/(origMonNum)<=0:E;

; Calculate total fight value
!!MA:F(origMonType)/?(origMonFightValue:y);
!!VR(totalFightValue:e):S(origMonFightValue) *(origMonNum);
!!FU&(totalFightValue)<=0:E;

; Determine concrete neutral stacks for battle (other scripts/mods are totally ignored here)
!!SN:M(M_AUTO_ID)/(MIX_NEUTRALS_STRUCT_SIZE)/(M_INT)/(M_TRIGGER_LOCAL)/?(neutrals:y);
!!FU(mix_ReadTileNeutrals):P(x)/(y)/(z)/(neutrals)/?(success:y)/?(remanentFightValue:e);
!!FU&(success)=(FALSE):E;

!!VRi^mix_isMixedNeutralsBattle^:S(TRUE);

; Reset defender stacks
!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!BA:M(BATTLE_RIGHT)/i/(NO_MON)/0;
!!en:;

; Assign stacks and remember total neutrals fight value
!!VR(neutralsFightValue:e):S0;
!!VR(slotInd:y):S0;

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!VR(pairInd:y):Si *2;
  !!SN:V(neutrals)/(pairInd)/?(monType:y)/?(monNum:y);

  !!if&(monType)<>(NO_MON):;
    !!MA:F(monType)/?(monFightValue:y);
    !!VR(stackFightValue:e):S(monFightValue) *(monNum);
    !!VR(neutralsFightValue):+(stackFightValue);
    !!BA:M(BATTLE_RIGHT)/(slotInd)/(monType)/(monNum);
    !!VR(slotInd):+1;
  !!en;
!!en:;

; Add remanent fight value to total fight value
!!VR(neutralsFightValue):+(remanentFightValue);

!!VR(neutralsFightValue):C?i^mix_neutralsFightValue^;
!!VR(remanentFightValue):C?i^mix_neutralsRemanentFightValue^;

; Remember real battle coordinates in case some script tries to manipulate them
!!VRi^mix_battleX^:S(x);
!!VRi^mix_battleY^:S(y);
!!VRi^mix_battleZ^:S(z);

!?FU(OnSetupBattlefield)&i^mix_isMixedNeutralsBattle^=(TRUE);
; Initialize stacks experience and bonus lines. Copy exp from the first stack and bonus lines from each monster type.
!#VA(bonusLine[15]:y);
!!EA-22:E?(baseStackExp:y)/d/d/d;

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!VR(stackExpId:y):S(BATTLE_DEFENDER_STACK_FIRST) +i +1 *-1;
  !!BA:M(BATTLE_RIGHT)/i/?(monType:y)/?t;
  !!co&(monType)=(NO_MON):;

  !!re j/0/(STACK_EXP_MAX_BONUS_LINES)/1/-1:;
    !!EA(monType):Bj/?(bonusLine[0])/?(bonusLine[1])/?(bonusLine[2])/?(bonusLine[3])/?(bonusLine[4])/?(bonusLine[5])/?(bonusLine[6])/?(bonusLine[7])/
                     ?(bonusLine[8])/?(bonusLine[9])/?(bonusLine[10])/?(bonusLine[11])/?(bonusLine[12])/?(bonusLine[13])/?(bonusLine[14]) L?(maxRankExpLimit:y);
    !!EA(stackExpId):Bj/(bonusLine[0])/(bonusLine[1])/(bonusLine[2])/(bonusLine[3])/(bonusLine[4])/(bonusLine[5])/(bonusLine[6])/(bonusLine[7])/
                        (bonusLine[8])/(bonusLine[9])/(bonusLine[10])/(bonusLine[11])/(bonusLine[12])/(bonusLine[13])/(bonusLine[14]) L(maxRankExpLimit) E(baseStackExp)/2/d/d;
  !!en:;
!!en:;

!?FU(OnAfterBattleSetup)&i^mix_isMixedNeutralsBattle^=(TRUE);
!!FU(mix_GetNeutralsMixedFactionsMoraleModifier):P?i^mix_neutralsMixedFactionsMoraleModifier^;

!?FU(mix_GetNeutralsMixedFactionsMoraleModifier);
; Does not account possible Angel Alliance usages
!#VA(result:x);

!!VR(numFactions:y):S0;
!!VR(undeadPresent:y):S(FALSE);
!!VR(factionCounters[MIX_MAX_SOD_FACTIONS_WITH_NEUTRALS]:y):C0/0/0/0/0/0/0/0/0/0;

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!BA:M(BATTLE_RIGHT)/i/?(monType:y)/?(monNum:y);
  !!co&(monType)=(NO_MON):;

  !!MA:X(monType)/?(monFlags:y);
  !!VR(siegeFlag:y):S(monFlags) &(MON_FLAG_SIEGE_WEAPON);
  !!co&(siegeFlag)<>0:;

  !!VRt:S(monFlags) &(MON_FLAG_UNDEAD);
  !!VR(undeadPresent)&t<>0:S(TRUE);

  !!MA:O(monType)/?(monFaction:y);
  !!VR(monFaction):+1;
  !!VR(factionCounterPtr:y):S(@factionCounters) +(monFaction);
  !!VR(isSeenFaction:y):Sy(factionCounterPtr);
  !!VRy(factionCounterPtr):+1;

  !!VR(numFactions)&(isSeenFaction)=(FALSE):+1;
!!en:;

!!VR(result):S2 -(numFactions) F(MIX_MIN_MORALE)/(MIX_MAX_MORALE) -(undeadPresent);

!?FU(mix_CompensateNeutralsMorale);
!!VR(noMoraleMask:y):S(MON_FLAG_NO_MORALE) |(MON_FLAG_UNDEAD) |(MON_FLAG_SIEGE_WEAPON);
!!VR(moraleModifier:y):Si^mix_neutralsMixedFactionsMoraleModifier^;

!!re i/(BATTLE_DEFENDER_BASE_STACK_FIRST)/(BATTLE_DEFENDER_BASE_STACK_LAST):;
  !!BMi:T?(monType:y) N?(monNum:y) F?(monFlags:y) G(BMG_FIELD_MORALE)/?(monMorale:y)/?t;
  !!co|(monType)=(NO_MON)/(monNum)<=0:;

  !!VRt:S(monFlags) &(noMoraleMask);

  !!if&t=0:;
    !!VR(monMorale):-(moraleModifier) +1 F(MIX_MIN_MORALE)/(MIX_MAX_MORALE);
    !!BMi:G(BMG_FIELD_MORALE)/(monMorale)/?t;
  !!en;
!!en:;

!?FU(OnBattleRound)&i^battle_round^=(FIRST_NON_TACTICS_ROUND)/i^mix_isMixedNeutralsBattle^=(TRUE);
!!FU(mix_CompensateNeutralsMorale):P;

!?FU(OnBeforeBattleAction)&i^mix_isMixedNeutralsBattle^=(TRUE);
!!FU(mix_CompensateNeutralsMorale):P;

!?FU(OnAfterBattleAction)&i^mix_isMixedNeutralsBattle^=(TRUE);
!!FU(mix_CompensateNeutralsMorale):P;

!?FU(OnAfterBattleUniversal)&i^mix_isMixedNeutralsBattle^=(FALSE);
!!FU(mix_OnAnalyseBattleResults):P;

!?FU(OnAfterBattleUniversal)&i^mix_isMixedNeutralsBattle^=(TRUE);
; Check if there are neutral stacks left, calculating total fight value
!!VR(finalFightValue:e):S0;

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!BA:M(BATTLE_RIGHT)/i/?(monType:y)/?(monNum:y);

  !!if&(monType)<>(NO_MON)/(monNum)>0:;
    !!MA:F(monType)/?(monFightValue:y);
    !!VR(stackFightValue:e):S(monFightValue) *(monNum);
    !!VR(finalFightValue):+(stackFightValue);
  !!en;
!!en:;

; Call custom callback, allowing to log battle casualities and implement, for instance, custom necromancy
!!FU(mix_OnAnalyseBattleResults):P;

; Exit if all neutrals are dead and clear neutrals config
!!if&(finalFightValue)<=0:;
  !!FU(mix_ClearTileNeutralsConfig):Pi^mix_battleX^/i^mix_battleY^/i^mix_battleZ^;
  !!FU:E;
!!en;

; Add remanent fight value to final fight value
!!VR(remanentFightValue:e):Ci^mix_neutralsRemanentFightValue^;
!!VR(finalFightValue):+(remanentFightValue);

; Recalculate new neutrals quantity on map as Ceil(Original quantity * Final Fight Value / Original Fight Value)
!!FU(mix_GetAdvMapMonInfo):Pi^mix_battleX^/i^mix_battleY^/i^mix_battleZ^/?(origMonType:y)/?(origMonNum:y);
!!VR(originalFightValue:e):Ci^mix_neutralsFightValue^;
!!VR(newAdvMapMonQtyFloat:e):S(finalFightValue) :(originalFightValue) *(origMonNum);
!!VR(ceiler:e):S99 :100;
!!VR(newAdvMapMonQtyFloat):+(ceiler) F1/(ADV_MAP_MON_MAX_QUANTITY);
!!VR(newMonNum:y):S(newAdvMapMonQtyFloat);

!!if&(newMonNum)=0:;
  ; New number cannot reach zero
  !!VR(newMonNum):S1;
!!el&(newMonNum)<0:;
  ; Handle integer overflow
  !!VR(newMonNum):S(ADV_MAP_MON_MAX_QUANTITY);
!!en;

; New number cannot be bigger, than original one if neutrals have some possibility to grow during battle
!!VR(newMonNum)&(newMonNum)>(origMonNum):S(origMonNum);

; Call custom callback, allowing to change final neutral stack size on adventure map
; Here custom rules may be implement, for instance, restoring neutrals if attacker escaped or died
!!FU(mix_OnApplyNeutralsCasualities):P?(newMonNum)/(origMonNum)/i^mix_battleX^/i^mix_battleY^/i^mix_battleZ^;;

; Overwrite neutrals final army
!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!BA:M(BATTLE_RIGHT)/i/(NO_MON)/0;
!!en:;

!!BA:M(BATTLE_RIGHT)/0/(origMonType)/(newMonNum);

!?FU(umt_CompareMonsByLevels);
!#VA(firstMonId:x);
!#VA(secondMonId:x);
!#VA(state:x);
!#VA(result:x);

!!MA:L(firstMonId)/?(firstMonLevel:y) L(secondMonId)/?(secondMonLevel:y);
!!VR(result):S(firstMonLevel) -(secondMonLevel);

!?FU(mix_OptimizeMonsterStructs);
; Sorts faction monster lists by monster levels. Counts each monster level quantity for each faction accumulatively.

; Preparre faction lists
!!VR(factions:y):Si^mix_factions^;
!!VR(factionLevels:y):Si^mix_faction_levels^;
!!SN:M(factions)/?(numFactions:y) M(factionLevels)/(numFactions);

; Process each faction
!#VA(levelCounters[MON_NUM_LEVELS]:y);

!!re i/0/(numFactions)/1/-1:;
  ; Count monster levels for each faction
  !!SN:V(factions)/i/?(currFaction:y) M(currFaction)/?(numFactionMons:y);
  !!SN:M(M_AUTO_ID)/(MON_NUM_LEVELS)/(M_INT)/(M_STORED)/?(currFactionLevels:y) V(factionLevels)/i/(currFactionLevels);
  !!VR(levelCounters):C0/0/0/0/0/0/0;

  !!re j/0/(numFactionMons)/1/-1:;
    !!SN:V(currFaction)/j/?(mon:y);
    !!MA:L(mon)/?(monLevel:y);
    !!VR(monLevel):F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
    !!VR(levelCounterPtr:y):S(@levelCounters) +(monLevel);
    !!VRy(levelCounterPtr):+1;
  !!en:;

  ; Convert level counters into accumulated level counters
  !!VRt:S(MON_MIN_LEVEL) +1;

  !!re (level:y)/t/(MON_MAX_LEVEL):;
    !!VR(currLevelCounterPtr:y):S(@levelCounters) +(level);
    !!VR(prevLevelCounterPtr:y):S(currLevelCounterPtr) -1;
    !!VRy(currLevelCounterPtr):+y(prevLevelCounterPtr);
  !!en:;

  ; Copy level counters to global list
  !!SN:V(currFactionLevels)/0/(levelCounters[0])/(levelCounters[1])/(levelCounters[2])/(levelCounters[3])/(levelCounters[4])/(levelCounters[5])/(levelCounters[6]);

  ; Sort each faction monsters by level
  !!FU(Array_CustomSort):P(currFaction)/(umt_CompareMonsByLevels);
!!en:; re

!!VR(monsters:y):Si^mix_monsters^;

; Sort all monsters list by level
!!FU(Array_CustomSort):P(monsters)/(umt_CompareMonsByLevels);

; Count all monster levels
!!VR(levelCounters):C0/0/0/0/0/0/0;

!!re i/0/i^mix_numMons^/1/-1:;
  !!SN:V(monsters)/i/?(mon:y);
  !!MA:L(mon)/?(monLevel:y);
  !!VR(monLevel):F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
  !!VR(levelCounterPtr:y):S(@levelCounters) +(monLevel);
  !!VRy(levelCounterPtr):+1;
!!en:;

; Convert level counters into accumulated level counters
!!VRt:S(MON_MIN_LEVEL) +1;

!!re (level:y)/t/(MON_MAX_LEVEL):;
  !!VR(currLevelCounterPtr:y):S(@levelCounters) +(level);
  !!VR(prevLevelCounterPtr:y):S(currLevelCounterPtr) -1;
  !!VRy(currLevelCounterPtr):+y(prevLevelCounterPtr);
!!en:;

; Copy level counters to global list
!!SN:Vi^mix_monster_levels^/0/(levelCounters[0])/(levelCounters[1])/(levelCounters[2])/(levelCounters[3])/(levelCounters[4])/(levelCounters[5])/(levelCounters[6]);

!?FU(mix_RegisterRegularMonsterRange);
; Register monsters with IDs in specified range as regular monsters (not commanders, towers, war machine or blank).
; These monsters will available for generation.
; The function may be called in "mix_OnRegisterRegularMonsters" event only.
!#VA(firstMonId:x); The first monster ID.
!#VA(lastMonId:x);  The last monster ID.

!!if&i^mix_monsRegistrationState^<>(MIX_MONS_ARE_REGISTERING):;
  !!SN:F^ShowErmError^/^The "mix_RegisterRegularMonsterRange" function can be called in "mix_OnRegisterRegularMonsters" event only^;
  !!FU:E;
!!en;

!!if|(firstMonId)<(MON_FIRST)/(lastMonId)<(MON_FIRST)/(firstMonId)>(lastMonId)/(lastMonId)>(MIX_MAX_POSSIBLE_MON_ID):;
  !!SN:F^ShowErmError^/^Invalid monsters range to register: %(firstMonId)..%(lastMonId)^;
  !!FU:E;
!!en;

; Ensure, there is enough space in monster-to-faction table
!!VR(minMonTableSize:y):S(lastMonId) +1;
!!VR(monToFactionInd:y):Si^mix_monToFactionInd^;
!!FU(Array_EnsureMinSize):P(monToFactionInd)/(minMonTableSize)/(MIX_UNSET_FACTION);

; Start with already registered factions
!!VR(factions:y):Si^mix_factions^;
!!SN:M(factions)/?(numFactions:y);

; Process each monster in the range
!!re (mon:y)/(firstMonId)/(lastMonId):;
  ; Do not register same monster twice
  !!SN:V(monToFactionInd)/(mon)/?(factionInd:y);
  !!co&(factionInd:y)<>(MIX_UNSET_FACTION):;

  ; Get monster faction and convert it to index
  !!VR(factionInd:y):S(INT_MIN);
  !!MA:O(mon)/?(factionInd) L(mon)/?(monLevel:y);
  !!FU&(factionInd)=(INT_MIN):E;
  !!VR(factionInd):-(NO_TOWN);

  ; Save monster faction index in monster to faction index map
  !!SN:V(monToFactionInd)/(mon)/(factionInd);

  ; Allocate new factions if accessing faction with new index
  !!if&(factionInd)>=(numFactions):;
    !!VR(newNumFactions:y):S(factionInd) +1;
    !!SN:M(factions)/(newNumFactions);

    !!re i/(numFactions)/(newNumFactions)/1/-1:;
      !!SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?(faction:y) V(factions)/i/(faction);
    !!en:;

    !!VR(numFactions):S(newNumFactions);
  !!en;

  ; Add monster to specified faction, global monsters list, specific level monster list and faction-mon-level monster list
  !!SN:V(factions)/(factionInd)/?(faction:y) M(faction)/d1 V(faction)/-1/(mon);
  !!SN:Mi^mix_monsters^/d1 Vi^mix_monsters^/-1/(mon);

  !!VRi^mix_numMons^:+1;
!!en:; re
; mix_RegisterRegularMonsterRange

!?FU(mix_SetFactionAllies);
; Set up to 7 ally factions for specified base faction. They may be used for random monsters generation.
; Each faction is added with some weight. Weight determines the chance to generate unit from base or any
; allied factions. For example, if you add Rampart 50 and Neutrals 10 to Castle 100, then whe total weight
; will be 100 + 50 + 10 = 160.
; Chance for Castle   monster will be 100 / 160 * 100% = 62.5%.
; Chance for Rampart  monster will be 50  / 160 * 100% = 31.25%.
; Chance for Neutrals monster will be 10  / 160 * 100% = 6.25%.

!#VA(baseFaction:x);       Base faction ID to set ally factions for.
!#VA(baseFactionWeight:x); Base faction weight.
!#VA(variableArgs:x);      ... Other arguments are pairs of (Faction ID, Faction Weight).

!!FU:A?(numArgs:y);
!!VRt:S(numArgs) %2;

!!if|(numArgs)<(@baseFactionWeight)/t<>0:;
  !!SN:F^ShowErmError^/^Invalid number of arguments^;
  !!FU:E;
!!en;

!!if|(baseFaction)<(NO_TOWN)/(baseFaction)>(MIX_MAX_POSSIBLE_FACTION_ID):;
  !!SN:F^ShowErmError^/^Invalid "baseFaction" argument: %(baseFaction)^;
  !!FU:E;
!!en;

!!if|(baseFactionWeight)<(MIX_MIN_FACTION_WEIGHT)/(baseFactionWeight)>(MIX_MAX_FACTION_WEIGHT):;
  !!SN:F^ShowErmError^/^Invalid "baseFactionWeight" argument: %(baseFactionWeight)^;
  !!FU:E;
!!en;

!!VR(baseFactionInd:y):S(baseFaction) -(NO_TOWN);
!!VR(numAllies:y):S(numArgs) -(@variableArgs) +1 :2;

; Get base faction allies array
!!VR(factionAllies:y):Si^mix_factionAllies^;
!!SN:M(factionAllies)/?(numFactions:y);

!!if&(baseFactionInd)>=(numFactions):;
  !!VR(numFactions):S(baseFactionInd) +1;
  !!SN:M(factionAllies)/(numFactions);
!!en;

!!SN:M(factionAllies)/(baseFactionInd)/?(baseFactionAllies:y);
!!VR(arraySize:y):S(numAllies) +1 *2;

!!if&(baseFactionAllies)=(NULL):;
  !!SN:M(M_AUTO_ID)/(arraySize)/(M_INT)/(M_STORED)/?(baseFactionAllies:y) V(factionAllies)/(baseFactionInd)/(baseFactionAllies);
!!el:;
  !!SN:M(baseFactionAllies)/(arraySize);
!!en;

; Write base faction data
!!SN:V(baseFactionAllies)/0/(baseFactionInd)/(baseFactionWeight);

; Start filling the array with allied factions
!!re i/0/(numAllies)/1/-1:;
  !!VR(factionArgPtr:y):Si *2 +(@variableArgs);
  !!VR(weightArgPtr:y):S(factionArgPtr) +1;
  !!VR(allyFaction:y):Sx(factionArgPtr);
  !!VR(allyFactionWeight:y):Sx(weightArgPtr);

  !!if|(allyFaction)<(NO_TOWN)/(allyFaction)>(MIX_MAX_POSSIBLE_FACTION_ID):;
    !!SN:F^ShowErmError^/^Invalid allied faction ID: %(allyFaction)^;
    !!FU:E;
  !!en;

  !!if|(allyFactionWeight)<=(MIX_MIN_FACTION_WEIGHT)/(allyFactionWeight)>(MIX_MAX_FACTION_WEIGHT):;
    !!SN:F^ShowErmError^/^Invalid allied faction weight: %(allyFactionWeight)^;
    !!FU:E;
  !!en;

  !!VR(allyFactionInd:y):S(allyFaction) -(NO_TOWN);
  !!VR(pairInd:y):Si +1 *2;

  !!SN:V(baseFactionAllies)/(pairInd)/(allyFactionInd)/(allyFactionWeight);
!!en:;

!?FU(mix_GetRandomBaseOrAlliedFaction);
; Returns either base faction ID or random allied faction ID, based on faction allies configuration.
; The result faction must have at least single unit, satisfying specified level requirements.
; Base faction ID is returned on any error.
!#VA(baseFaction:x); Base faction ID.
!#VA(result:x);      Result.
!#VA(minLevel:x);    OPT. Minimum required monster level.
!#VA(maxLevel:x);    OPT. Maximum required monster level.

!!VR(result):S(baseFaction);
!!VR(baseFactionInd:y):S(baseFaction) -(NO_TOWN);

!!SN:Mi^mix_factions^/?(numFactions:y);
!!FU|(baseFactionInd)<0/(baseFactionInd)>=(numFactions):E;

!!VR(factionAllies:y):Si^mix_factionAllies^;

!!FU:A?(numArgs:y);
!!VR(minLevel)&(numArgs)<(@minLevel):S(MON_MIN_LEVEL);
!!VR(maxLevel)&(numArgs)<(@maxLevel):S(MON_MAX_LEVEL);
!!VR(minLevel):F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
!!VR(maxLevel):F(minLevel)/(MON_MAX_LEVEL);

!!SN:V(factionAllies)/(baseFactionInd)/?(baseFactionAllies:y);
!!FU&(baseFactionAllies)=(NULL):E;
!!SN:M(baseFactionAllies)/?(numAllies:y);

!!VR(numAllies)::2;
!!VR(numAlts:y):S0;
!!VR(totalWeight:y):S0;

!!VR(tempBuf:y):Si^mix_temp_buf^;
!!VR(factionLevels:y):Si^mix_faction_levels^;

; Iterate through each allied faction, adding only those with non-zero weight and necessary monsters
!!re i/0/(numAllies)/1/-1:;
  !!VR(allyDataPtr:y):Si *2;
  !!SN:V(baseFactionAllies)/(allyDataPtr)/?(allyFactionInd:y)/?(allyFactionWeight:y);
  !!co&(allyFactionWeight)=0:;

  !!SN:V(factionLevels)/(allyFactionInd)/?(allyFactionLevels:y) V(allyFactionLevels)/(maxLevel)/?(sampleSize:y);
  !!VR(lowerLevelsSampleSize:y):S0;

  !!if&(minLevel)>(MON_MIN_LEVEL):;
    !!VRt:S(minLevel) -1;
    !!SN:V(allyFactionLevels)/t/?(lowerLevelsSampleSize);
    !!VR(sampleSize):-(lowerLevelsSampleSize);
  !!en;

  !!co&(sampleSize)<=0:;

  !!VR(tempBufPos:y):S(numAlts) *2;
  !!SN:V(tempBuf)/(tempBufPos)/(allyFactionInd)/(allyFactionWeight);
  !!VR(totalWeight):+(allyFactionWeight);
  !!VR(numAlts):+1;
!!en:;

!!FU&(numAlts)<=0:E;

!!VR(randomWeight:y):R0/1/(totalWeight);
!!VR(weight:y):S0;

!!re i/0/(numAllies)/1/-1:;
  !!VR(allyDataPtr:y):Si *2;
  !!SN:V(baseFactionAllies)/(allyDataPtr)/?(allyFactionInd:y)/?(allyFactionWeight:y);
  !!VR(weight):+(allyFactionWeight);

  !!br&(weight)>=(randomWeight):;
!!en:;

!!VR(result):S(allyFactionInd) +(NO_TOWN);

!?FU(mix_GenerateRandomMonster);
; Generates regular random monster of any faction and returns its ID or NO_MON on error.
!#VA(result:x);
!#VA(minLevel:x); OPT. Monster minimal level.
!#VA(maxLevel:x); OPT. Monster maximal level.

!!VR(result):S(NO_MON);

!!VR(numMons:y):Si^mix_numMons^;
!!FU&(numMons)<=0:E;

!!FU:A?(numArgs:y);
!!VR(minLevel)&(numArgs)<(@minLevel):S(MON_MIN_LEVEL);
!!VR(maxLevel)&(numArgs)<(@maxLevel):S(MON_MAX_LEVEL);
!!VR(minLevel):F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
!!VR(maxLevel):F(minLevel)/(MON_MAX_LEVEL);

!!VR(monLevels:y):Si^mix_monster_levels^;
!!SN:V(monLevels)/(maxLevel)/?(sampleSize:y);
!!VR(lowerLevelsSampleSize:y):S0;

!!if&(minLevel)>(MON_MIN_LEVEL):;
  !!VRt:S(minLevel) -1;
  !!SN:V(monLevels)/t/?(lowerLevelsSampleSize);
  !!VR(sampleSize):-(lowerLevelsSampleSize);
!!en;

!!VR(randomInd:y):R0/1/(sampleSize) -1;
!!VR(randomInd):+(lowerLevelsSampleSize);
!!SN:Vi^mix_monsters^/(randomInd)/?(result);

!?FU(mix_GenerateFactionMonster);
; Generates random monster from particular faction or even allied factions.
!#VA(faction:x);             Faction/Town ID or (NO_TOWN) for neutrals.
!#VA(allowAlliedFactions:x); Allow to generate from allied factions (TRUE) or not (FALSE). Default: (FALSE).
!#VA(result:x);              Result monster ID or (NO_MON) on error.
!#VA(minLevel:x);            OPT. Min monster level.
!#VA(maxLevel:x);            OPT. Max monster level.

!!VR(result):S(NO_MON);

!!VR(numMons:y):Si^mix_numMons^;
!!FU&(numMons)<=0:E;

!!FU:A?(numArgs:y);
!!VR(minLevel)&(numArgs)<(@minLevel):S(MON_MIN_LEVEL);
!!VR(maxLevel)&(numArgs)<(@maxLevel):S(MON_MAX_LEVEL);
!!VR(minLevel):F(MON_MIN_LEVEL)/(MON_MAX_LEVEL);
!!VR(maxLevel):F(minLevel)/(MON_MAX_LEVEL);

!!VR(factions:y):Si^mix_factions^;
!!SN:M(factions)/?(numFactions:y);

!!VR(factionInd:y):S(faction) -(NO_TOWN);
!!FU|(factionInd)<0/(factionInd)>=(numFactions):E;

; Get final faction ID and index
!!FU(mix_GetRandomBaseOrAlliedFaction)&(allowAlliedFactions)<>(FALSE):P(faction)/?(faction);
!!VR(factionInd:y):S(faction) -(NO_TOWN);

; Check if there exists such faction with at least single creature with matching level
!!SN:Mi^mix_faction_levels^/(factionInd)/?(monLevels:y);
!!SN:V(monLevels)/(maxLevel)/?(sampleSize:y);
!!VR(lowerLevelsSampleSize:y):S0;

!!if&(minLevel)>(MON_MIN_LEVEL):;
  !!VRt:S(minLevel) -1;
  !!SN:V(monLevels)/t/?(lowerLevelsSampleSize);
  !!VR(sampleSize):-(lowerLevelsSampleSize);
!!en;

!!FU&(sampleSize)<=0:E;

!!SN:V(factions)/(factionInd)/?(factionMons:y);

; Write random faction monster ID to result
!!VR(monInd:y):R0/1/(sampleSize) -1 +(lowerLevelsSampleSize);
!!SN:V(factionMons)/(monInd)/?(result);

!?FU(mix_GetAdvMapMonInfo);
; Given coordinates of monster on adventure map, returns monster type and number.
; If object is not a monster, (NO_MON) type is returned.
!#VA(x:x) (y:x) (z:x);
!#VA(monType:x); OUT. (NO_MON) on error
!#VA(monNum:x);  OUT

!!VR(monType):S(NO_MON);
!!VR(monNum):S0;
!!OB(x)/(y)/(z):T?(objType:y) U?(monType);

!!if&(objType)<>(OBJ_MONSTER):;
  !!VR(monType):S(NO_MON);
  !!FU:E;
!!en:;

!!MO(x)/(y)/(z):G?(monNum);

!?FU(mix_ClearTileNeutralsConfig);
!#VA(x:x) (y:x) (z:x);

!!VR(configKey:z):S^mix_mon_%(x)_%(y)_%(z)^;
!!SN:W(configKey)/?(config:y);
!!SN&(config)<>0:M(config) W(configKey)/0;

!?FU(mix_GetTileNeutralsConfig);
!#VA(x:x) (y:x) (z:x) (result:x) (autocreate:x) = (FALSE);
; Returns TNeutralsConfig: existing config for given map tile in the form of SN:M array ID or 0 if config is missing.
; Specify (autocreate) = (TRUE) to create new config, if nothing is found.
; Warning: calling any Mixed Neutrals API may invalid the result array ID.

!!VR(configKey:z):S^mix_mon_%(x)_%(y)_%(z)^;
!!SN:W(configKey)/?(result);

; No config found, autocreate empty
!!SN&(result)=0/(autocreate)<>(FALSE):M(M_AUTO_ID)/(MIX_NEUTRALS_CONFIG_SIZE)/(M_INT)/(M_STORED)/?(result)
                                      W(configKey)/(result)
                                      V(result)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0/(NO_MON)/0
                                      V(result)/(MIX_NEUTRALS_CONFIG_SPREAD_MASK_IND)/0;

!?FU(mix_ReadTileNeutrals);
; Calculates neutrals types and current final quantitites, writing them to user-specified array.
; The result contains virtual slots, which may be empty and non-sequential.
!#VA(x:x) (y:x) (z:x);
!#VA(neutrals:x);           TNeutrals. SN:M array ID to write finally calculated data to.
!#VA(success:x);            Boolean.   Optional, OUT. True, if data exists and was successfully read.
!#VA(remanentFightValue:x); Float.     Optional, OUT. Not used Fight Value, that should be preserved after battle.

!!VR(success):S(FALSE);

; Get config, exit if none
!!FU(mix_GetTileNeutralsConfig):P(x)/(y)/(z)/?(config:y);
!!FU&(config)=(FALSE):E;

; Get total number of original creatures
!!FU(mix_GetAdvMapMonInfo):P(x)/(y)/(z)/?(origMonType:y)/?(totalMons:y);
!!FU|(origMonType)=(NO_MON)/(totalMons)<=0:E;

; Calculate total fight value as float
!!MA:F(origMonType)/?(origMonFightValue:y);
!!VR(totalFightValue:e):S(totalMons) *(origMonFightValue);
!!FU&(totalFightValue)<=0:E;

; Initialize result to empty slots
!!SN:V(neutrals)/0/-1/0/-1/0/-1/0/-1/0/-1/0/-1/0/-1/0;

; Get spread mask
!!SN:V(config)/(MIX_NEUTRALS_CONFIG_SPREAD_MASK_IND)/?(spreadMask:y);

; Unpack spread mask
!#VA(spreads[7]:y);

!!re i/(@spreads[0])/(@spreads[-1]):;
  !!VRyi:S(spreadMask) &7;
  !!VR(spreadMask):Sd>>3;
!!en:;

; Calculate each stack size in floats
!!VR(numStacksToSpread:y):S0;
!!VR(numStacks:y):S0;

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  ; Reset spread config for current stack by default
  !!VR(spreadPtr:y):S(@spreads) +i;
  !!VR(spread:y):Sy(spreadPtr);
  !!VRy(spreadPtr):S(MIX_NO_SPREAD);

  ; Skip free slot
  !!VR(pairInd:y):Si *2;
  !!SN:V(config)/(pairInd)/?(monType:y)/?(monRelQuantity:e);
  !!co&(monType)<=(NO_MON):;

  ; Skip slot with zero fight value or quantity
  !!MA:F(monType)/?(monFightValue:y);
  !!VR(monQuantityFloat:e):S(totalFightValue) *(monRelQuantity) :(monFightValue);
  !!co&(monQuantityFloat)<=0:;

  ; Force integer cap for number of creatures
  !!VR(monQuantityFloat)&(monQuantityFloat)>=(INT_MAX):S(INT_MAX);

  ; Adjust number of stacks to spread and restore stack spread config
  !!VRy(spreadPtr):S(spread);
  !!VR(numStacksToSpread)&(spread)<>(MIX_NO_SPREAD):+1;

  ; Save monster in the result list
  !!SN:V(neutrals)/(pairInd)/(monType)/(monQuantityFloat);
  !!VR(numStacks):+1;
!!en:;

; Exit if config does not contain any monsters
!!FU&(numStacks)=0:E;

; Determine free slot indexes and count
!#VA(freeSlots[7]:y);
!!VR(freeSlotPtr:y):S(@freeSlots);

!!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
  !!VR(pairInd:y):Si *2;
  !!SN:V(neutrals)/(pairInd)/?(monType:y);

  !!if&(monType)=(NO_MON):;
    !!VRy(freeSlotPtr):Si;
    !!VR(freeSlotPtr):+1;
  !!en;
!!en:;

!!VR(numFreeSlots:y):S(freeSlotPtr) -(@freeSlots);
!!VR(numFreeSlotsLeft:y):S(numFreeSlots);

; Perform spreading
!!if&(numFreeSlots)>0/(numStacksToSpread)>0:;
  !!VR(slotsPerSpreadedStack:y):S(numFreeSlots) :(numStacksToSpread);
  !!VR(freeSlotsReserve:y):S(numFreeSlots) %(numStacksToSpread);
  !!VR(stackInd:y):S3;
  !!VR(sign:y):S-1;

  !!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
    ; Calculate current stack index, processing stacks from center in the following order
    ; [0][1][2][3][4][5][6] - Stacks
    ;  5  3  1  0  2  4  6  - Order
    !!VR(sign):*-1;
    !!VR(posModifier:y):Si *(sign);
    !!VR(stackInd):+(posModifier);

    ; Continue if slot is free
    !!VR(pairInd:y):S(stackInd) *2;
    !!SN:V(neutrals)/(pairInd)/?(monType:y)/?(monQuantityFloat:e);
    !!co&(monType)=(NO_MON):;

    ; Continue if slot must not be spreaded
    !!VR(spreadPtr:y):S(@spreads) +(stackInd);
    !!VR(spread:y):Sy(spreadPtr);
    !!co|(spread)<(MIX_SPREAD_FIRST_STRATEGY)/(spread)>(MIX_SPREAD_LAST_STRATEGY):;

    ; Determine, how many free slots will be used for current stack
    !!VR(numOccupiedSlots:y):S(slotsPerSpreadedStack);

    !!if&(freeSlotsReserve)>0:;
      !!VR(freeSlotsReserve):-1;
      !!VR(numOccupiedSlots):+1;
    !!en;

    ; Exit if no more free slots
    !!br&(numOccupiedSlots)<=0:;

    ; Calculate float quantity for each slot to occupy
    !!VR(numStackSlots:y):S(numOccupiedSlots) +1;
    !!VR(spreadedMonQuantityFloat:e):S(monQuantityFloat) :(numStackSlots);

    ; Update float monster quantity in main stack slot
    !!SN:V(neutrals)/(pairInd)/?t/(spreadedMonQuantityFloat);

    ; Prepare to occupy new slots
    !!VR(freeSlotPtr:y):-1;

    !!if&(spread)=(MIX_SPREAD_RANDOM):;
      !!VRf:S(z) Sd<<16;
      !!VRg:S(y) Sd<<8;
      !!VR(randomBits:y):S(x) |(y) |(z) Xi^mix_randomSeed^;
      !!FU(Tm32Encode):P(randomBits)/?(randomBits);
    !!el&(spread)=(MIX_SPREAD_SPACE_BETWEEN):;
      ; Special handling for space-between strategy: original slot is removed and is inserted as free slot
      !!SN:V(neutrals)/(pairInd)/(NO_MON)/0;
      !!VRy(spreadPtr):S(MIX_NO_SPREAD);
      !!VR(freeSlotPtr):S(@freeSlots) +(numFreeSlots);
      !!VR(numFreeSlots):+1;
      !!VR(numOccupiedSlots):+1;

      !!VRy(freeSlotPtr):S(stackInd);

      !!re (freeSlotPtr)/(freeSlotPtr)/(@freeSlots[1])/-1:;
        !!VR(prevFreeSlotPtr:y):S(freeSlotPtr) -1;
        !!br&y(freeSlotPtr)>=y(prevFreeSlotPtr):;

        !!VRt:Sy(prevFreeSlotPtr);
        !!VRy(prevFreeSlotPtr):Sy(freeSlotPtr);
        !!VRy(freeSlotPtr):St;
      !!en:;

      !!VR(numFreeSlotsAfter:y):S(numFreeSlots) -(numOccupiedSlots);
      !!VR(numGaps:y):S(numOccupiedSlots) -1;
      !!VR(gap:y):S(numFreeSlotsAfter) :(numGaps);
      !!VR(spaceReserve:y):S(numFreeSlotsAfter) %(numGaps);
      !!VR(freeSlotPtr):S(@freeSlots);
    !!en:; el

    ; Occupy new slots
    !!re j/0/(numOccupiedSlots)/1/-1:;
      ; Find matching free slot
      !!if|(spread)=(MIX_SPREAD_TOP_DOWN)/(numFreeSlots)=1:;
        !!VR(freeSlotPtr):S(@freeSlots[0]);
      !!el&(spread)=(MIX_SPREAD_NEAR_CENTER):;
        !!VR(closestFreeSlotPtr:y):S-1;
        !!VR(closestFreeSlotDistance:y):S(INT_MAX);

        !!re k/0/(numFreeSlots)/1/-1:;
          !!VR(freeSlotPtr):S(@freeSlots) +k;
          !!VR(freeSlot:y):Sy(freeSlotPtr);
          !!VR(freeSlotDistance:y):S(stackInd) -(freeSlot);
          !!VR(freeSlotDistance)&(freeSlotDistance)<0:*-1;

          !!if&(freeSlotDistance)<(closestFreeSlotDistance):;
            !!VR(closestFreeSlotPtr:y):S(freeSlotPtr);
            !!VR(closestFreeSlotDistance:y):S(freeSlotDistance);
          !!en;
        !!en:; re

        !!VR(freeSlotPtr):S(closestFreeSlotPtr);
      !!el&(spread)=(MIX_SPREAD_AWAY_FROM_CENTER):;
        !!VR(farthestFreeSlotPtr:y):S(stackInd);
        !!VR(farthestFreeSlotDistance:y):S0;

        !!re k/0/(numFreeSlots)/1/-1:;
          !!VR(freeSlotPtr):S(@freeSlots) +k;
          !!VR(freeSlot:y):Sy(freeSlotPtr);
          !!VR(freeSlotDistance:y):S(stackInd) -(freeSlot);
          !!VR(freeSlotDistance)&(freeSlotDistance)<0:*-1;

          !!if&(freeSlotDistance)>(farthestFreeSlotDistance):;
            !!VR(farthestFreeSlotPtr:y):S(freeSlotPtr);
            !!VR(farthestFreeSlotDistance:y):S(freeSlotDistance);
          !!en;
        !!en:; re

        !!VR(freeSlotPtr):S(farthestFreeSlotPtr);
      !!el&(spread)=(MIX_SPREAD_SPACE_BETWEEN):;
        ; Apply gap/spacing
        !!if&j>0:;
          !!VR(freeSlotsToSkip:y):S(gap);

          !!if&(spaceReserve)>0:;
            !!VR(freeSlotsToSkip):+1;
            !!VR(spaceReserve):-1;
          !!en;

          !!VR(freeSlotPtr):+(freeSlotsToSkip);
        !!en; if
      !!el&(spread)=(MIX_SPREAD_RANDOM):;
        !!VRt:S(randomBits) %(numFreeSlots);
        !!VRt&t<0:+(numFreeSlots);
        !!VR(freeSlotPtr):St +(@freeSlots);
        !!VR(randomBits)::(numFreeSlots);
      !!el:;
        !!SN:F^ShowErmError^/^Impossible spreading strategy %(spread)^;
        !!FU:E;
      !!en; el

      !!VR(freeSlot:y):Sy(freeSlotPtr);

      ; Remove found free slot from the list and compact the list
      !!VRy(freeSlotPtr):S-1;
      !!VR(numFreeSlots):-1;

      !!VRf:S(freeSlotPtr) +1;

      !!re k/f/(@freeSlots[-1]):;
        !!VR(destFreeSlotPtr:y):Sk -1;
        !!VRy(destFreeSlotPtr):Syk;
      !!en:;

      ; Occupy slot
      !!VR(pairInd:y):S(freeSlot) *2;
      !!SN:V(neutrals)/(pairInd)/(monType)/(spreadedMonQuantityFloat);
    !!en:; re
  !!en:; re
!!en; if

; Apply merging in order to obtain integer non-zero quantities for each slot and unused fight value sum
!#VA(monReserve[14]:y); array 7 of (monType: int, monQuantity: float)
!!VR(monReserveSize:y):S0;

!!VR(numRealSlots:y):S0;

!!VRi:S(MIX_MAX_NEUTRAL_STACKS) -1;

; Process each stack from right to left
!!re i/i/0/-1:;
  ; Continue if slot is free
  !!VR(pairInd:y):Si *2;
  !!SN:V(neutrals)/(pairInd)/?(monType:y)/?(monQuantityFloat:e) V(neutrals)/(pairInd)/(NO_MON)/0;
  !!co&(monType)=(NO_MON):;

  ; Search for the same monster type in reserve
  !!re (monReserveInd:y)/0/(monReserveSize)/1/-1:;
    !!VR(monReservePtr:y):S(monReserveInd) *2 +(@monReserve);
    !!VRy(monReservePtr):C?(reserveMonType:y)/?(reserveMonQuantity:e);
    !!br&(reserveMonType)=(monType):;
  !!en:;

  ; Add monster from reserve to current stack, if any
  ; Create new reserve if current monster type is absent
  !!if&(monReserveInd)<(monReserveSize):;
    !!VR(monQuantityFloat):+(reserveMonQuantity);
  !!el:;
    !!VR(monReservePtr):S(monReserveSize) *2 +(@monReserve);
    !!VR(monReserveSize):+1;
  !!en;

  ; Convert current stack quantity to integer
  !!VR(monQuantity:y):S(monQuantityFloat);
  !!VR(monQuantity)&(monQuantity)<0:S(INT_MAX);

  ; Calculate rest monster quantity for reserve
  !!VR(reserveMonQuantity:e):S(monQuantityFloat) -(monQuantity);

  ; Update reserve
  !!VRy(monReservePtr):C(monType)/(reserveMonQuantity);

  ; Update result stack
  !!VR(monType)&(monQuantity)=0:S(NO_MON);
  !!SN:V(neutrals)/(pairInd)/(monType)/(monQuantity);

  !!VR(numRealSlots)&(monQuantity)>0:+1;
!!en:; re

!!VR(remanentFightValue):S0;

; Apply minimal 1 monster requirement if all slots seem to be empty
!!if&(numRealSlots)=0:;
  !!VR(minFightValueMonType:y):S(NO_MON);
  !!VR(minFightValue:y):S(INT_MAX);
  !!VR(minFightValuePairInd:y):S-1;

  !!re i/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
    ; Continue if slot is free
    !!VR(pairInd:y):Si *2;
    !!SN:V(config)/(pairInd)/?(monType:y);
    !!co&(monType)<=(NO_MON):;

    ; Remember monster, if it's fight value is less, than current minimum
    !!MA:F(monType)/?(monFightValue:y);

    !!if&(monFightValue)<(minFightValue):;
      !!VR(minFightValue):S(monFightValue);
      !!VR(minFightValueMonType):S(monType);
      !!VR(minFightValuePairInd):S(pairInd);
    !!en;
  !!en:;

  ; Set 1 monster to slot
  !!SN:V(neutrals)/(minFightValuePairInd)/(minFightValueMonType)/1;
!!el:;
  ; Calculate remanentFightValue, based on left reserve after merging
  !!VR(remanentFightValueFloat:e):S0;

  !!re (monReserveInd:y)/0/(monReserveSize)/1/-1:;
    !!VR(monReservePtr:y):S(monReserveInd) *2 +(@monReserve);
    !!VRy(monReservePtr):C?(reserveMonType:y)/?(reserveMonQuantity:e);
    !!MA:F(reserveMonType)/?(reserveMonFightValue:y);
    !!VR(reserveStackFightValue:e):S(reserveMonQuantity) *(reserveMonFightValue);
    !!VR(remanentFightValueFloat):+(reserveStackFightValue);
  !!en:;

  ; Try to distribute remanent fight value between existing stacks equally
  !!re i:;
    ; Stop if there is nothing to redistribute
    !!br&(remanentFightValueFloat)<=0:;

    ; Prepare to track any extra added creature
    !!VR(numMonsAdded:y):S0;

    ; Calculate fight value bonus for each existing stack
    !!VR(stackFightValue:y):S(remanentFightValueFloat) :(numRealSlots) F0/(INT_MAX);

    ; Loop through each existing stack, trying to use its extra fight value
    !!re j/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
      ; Continue if slot is free
      !!VR(pairInd:y):Sj *2;
      !!SN:V(neutrals)/(pairInd)/?(monType:y)/?(monQuantity:y);
      !!co&(monType)=(NO_MON):;

      ; Try to increase stack size
      !!MA:F(monType)/?(monFightValue:y);
      !!VR(numExtraMons:y):S(stackFightValue) :(monFightValue);
      !!VR(extraFightValue:y):S(numExtraMons) *(monFightValue);
      !!VR(remanentFightValueFloat):-(extraFightValue);
      !!VR(numMonsAdded):+(numExtraMons);
      !!SN:V(neutrals)/(pairInd)/?t/d(numExtraMons);
    !!en:;

    ; Exit if no stack was increased in size
    !!br&(numMonsAdded)<=0:;
  !!en:; re

  ; Perform last pass, distributing the rest fight value unequally
  !!if&(remanentFightValueFloat)>0:;
    !!re j/0/(MIX_MAX_NEUTRAL_STACKS)/1/-1:;
      ; Continue if slot is free
      !!VR(pairInd:y):Sj *2;
      !!SN:V(neutrals)/(pairInd)/?(monType:y)/?(monQuantity:y);
      !!co&(monType)=(NO_MON):;

      ; Try to increase stack size
      !!MA:F(monType)/?(monFightValue:y);
      !!VR(numExtraMons:y):S(remanentFightValueFloat) :(monFightValue);
      !!VR(extraFightValue:y):S(numExtraMons) *(monFightValue);
      !!VR(remanentFightValueFloat):-(extraFightValue);
      !!SN:V(neutrals)/(pairInd)/?t/d(numMonsAdded);
    !!en:;
  !!en; if

  !!VR(remanentFightValue):C(remanentFightValueFloat);
!!en; el

!!VR(success):S(TRUE);

; ========================== TESTING ==========================

!?FU(OnAdventureMapRightMouseClick)&y1<>y1;
!!CM:R0 P?(x:y)/?(y:y)/?(z:y);
!!FU(mix_GetTileNeutralsConfig):P(x)/(y)/(z)/?(config:y)/(MIX_AUTOCREATE_NEUTRALS_CONFIG);

!#VA(relQts[3]:e);
!!VR(relQts[0]):S333 :100;
!!VR(relQts[1]):S333 :100;
!!VR(relQts[2]):S333 :100;
!!SN:V(config)/0/2/(relQts[0])/9/(relQts[1])/13/(relQts[2]);

!!SN:M(M_AUTO_ID)/(MIX_NEUTRALS_STRUCT_SIZE)/(M_INT)/(M_TRIGGER_LOCAL)/?(neutrals:y);
!!FU(mix_ReadTileNeutrals):P(x)/(y)/(z)/(neutrals);

!#VA(monTypes[3]:y) (monNums[3]:y);
!!SN:V(neutrals)/0/?(monTypes[0])/?(monNums[0])/?(monTypes[1])/?(monNums[1])/?(monTypes[2])/?(monNums[2]);

!!IF:M^%(monTypes[0])/%(monNums[0]) %(monTypes[1])/%(monNums[1]) %(monTypes[2])/%(monNums[2])^;