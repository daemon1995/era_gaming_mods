ZVSE2


************************************************************************
************************************************************************
****************************** GAME FIXES ******************************
************************************************************************
************************************************************************

// Flexible cheats input
// by Archer30
; This script enables good old HoMM 3 cheats for ERA
; It also allows using cheats when the input is mixing with unrelated characters. The first word of the input would be checked and decide whether it's a cheat code input.
; Cheats that works for both adventure map and battlefield in SoD now also works the same in ERA
; This script is replaced by Easy Cheats
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!FU:E;

!!SN:E(setHook)/1/4205107/(gem_OnDecryptInputString); 00402A33

!?FU(gem_OnDecryptInputString);
!#VA(hook:x);

; Exit if it is not a place to use cheats
!!FU(H3Dlg_GetCurrentDlgId):P?(dlgId:y);
!!FU&(dlgId)<>(DLG_ADVMAP)/(dlgId)<>(DLG_BATTLE):E;

; Get the input
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/8/4/?(ptr:y);
!!SN:B(ptr)/d/?(input:z);

; Get rid of space before the first word
!!SN:K(input)/?(size:y);

!!re i/0/(size)/1/-1;
  !!SN:K(input)/i/?(character:z);

  !!br|(character)=^n^/(character)=^w^;
!!en;

; Exit if the string is empty (full of space)
!!FU&i=(size):E;

!!VR(size):-i;
!!FU(Substr):P(input)/i/(size)/?(input);

; Catch only the first word of the input to check if they match any cheats
!!VR(firstWord:z):M2/(input)/0;
; Convert the first word to lower case for the next step
!!FU(StrToLower):P(firstWord)/?(str:z);

; Make old cheats work by converting them to new ones
!!VR(newStr:z):S^^;

; Check mappings
; For adventure map
!!if&(dlgId)=(DLG_ADVMAP);
  !!OW:Ai^timerOwner^/?(hero:y);

  !!if&(hero)>(NO_HERO);
    !!if|(str)=^nwcmuchrejoicing^/(str)=^nwcmorpheus^/(str)=^wogfellowship^; [Full Morale on Hero. No AB]
      !!VR(newStr):S^wogfellowship^;
    !!el|(str)=^nwcigotbetter^/(str)=^nwcquigon^/(str)=^nwcneo^/(str)=^woggandalfwhite^; [Gain +1 Level for Hero]
      !!VR(newStr):S^woggandalfwhite^;
    !!el|(str)=^nwcantioch^/(str)=^nwcr2d2^/(str)=^nwclotsofguns^/(str)=^wogoliphaunt^; [All War Machines]
      !!VR(newStr):S^wogoliphaunt^;
    !!el|(str)=^nwctim^/(str)=^nwcmidichlorians^/(str)=^nwcthereisnospoon^/(str)=^wogsaruman^/(str)=^woggandalf^; [999 Mana and All Spells]
      !!VR(newStr):S^wogsaruman^;
    !!el|(str)=^nwcfleshwound^/(str)=^nwcdarthmaul^/(str)=^nwcagents^/(str)=^wogpathofthedead^; [Fill Each Slot with 10 Black Knights]
      !!VR(newStr):S^wogpathofthedead^;
    !!el|(str)=^nwcavertingoureyes^/(str)=^nwcpadme^/(str)=^nwctrinity^/(str)=^woggaladriel^; [Fill Your Army with Archangels]
      !!VR(newStr):S^woggaladriel^;
    !!el|(str)=^nwccoconuts^/(str)=^nwcpodracer^/(str)=^nwcnebuchadnezzar^/(str)=^wogshadowfax^; [Unlimited Movement for Hero]
      !!VR(newStr):S^wogshadowfax^;
    !!el|(str)=^nwccastleanthrax^/(str)=^nwcfollowthewhiterabbit^/(str)=^wogbilbo^; [Full Luck on Your Hero. No AB]
      !!VR(newStr):S^wogbilbo^;
    !!en;
  !!en;

  !!if|(str)=^nwcsirrobin^/(str)=^nwcbluepill^/(str)=^wogdarklord^/(str)=^wogdenethor^; [Instant lose. No AB]
    !!VR(newStr):S^wogdarklord^;
  !!el|(str)=^nwcalreadygotone^/(str)=^nwcprophecy^/(str)=^nwcoracle^/(str)=^wogpalantir^; [Show Full Grail Map]
    !!VR(newStr):S^wogpalantir^;
  !!el&(str)=^nwcignoranceisbliss^;     [Hide Full Map. No RoE, AB]
    !!VR(newStr):S^wogmordor^;
  !!el|(str)=^nwctrojanrabbit^/(str)=^nwcredpill^/(str)=^wogonering^/(str)=^wogfrodo^; [Instant Win. No AB]
    !!VR(newStr):S^wogonering^;
  !!el|(str)=^nwcshrubbery^/(str)=^nwcwatto^/(str)=^nwctheconstruct^/(str)=^wogisengard^; [100,000 Gold and 100 of Every Resource]
    !!VR(newStr):S^wogisengard^;
  !!el|(str)=^nwconlyamodel^/(str)=^nwccoruscant^/(str)=^nwczion^/(str)=^wogminastirith^; [All Buildings]
    !!VR(newStr):S^wogminastirith^;
  !!el|(str)=^nwcgeneraldirection^/(str)=^nwcrevealourselves^/(str)=^nwcwhatisthematrix^/(str)=^wogeyeofsauron^; [Reveal Full Map]
    !!VR(newStr):S^wogeyeofsauron^;
  !!el&(str)=^nwcphisherprice^;         [Alternate Color Scheme - not working? Disabled for now. No AB]
    !!FU:E;

    !!VR(newStr):S^wogsarumanofmanycolors^;
  !!en;

; For battle
!!el&(dlgId)=(DLG_BATTLE);
  !!if&i^battle_hero_%i(battle_current_side)^>(NO_HERO);
    !!if|(str)=^nwctim^/(str)=^nwcmidichlorians^/(str)=^nwcthereisnospoon^/(str)=^wogsaruman^/(str)=^woggandalf^; [999 Mana and All Spells]
      !!VR(newStr):S^woggandalf^;
    !!en;
  !!en;

  !!if|(str)=^nwcsirrobin^/(str)=^nwcbluepill^/(str)=^wogdarklord^/(str)=^wogdenethor^; [Instant lose. No AB]
    !!VR(newStr):S^wogdenethor^;
  !!el|(str)=^nwctrojanrabbit^/(str)=^nwcredpill^/(str)=^wogonering^/(str)=^wogfrodo^; [Instant Win. No AB]
    !!VR(newStr):S^wogfrodo^;
  !!en;
!!en;

!!SN&(newStr)<>^^:B(ptr)/d/(newStr);


// Assemble/Disassemble artifacts overhaul
// by Archer30
; On hero screen:
; Assemble artifacts with parts not fully equipped (some in the backpack)
; Disassemble artifacts in the backpack

; For one slot combination artifact only:
; Disassemble combination artifacts

!?FU(OnHeroScreenMouseClick)&i^mouse_action^=(MOUSE_RMB_PRESSED);
!!VR(slot:y):S(NO_ART_SLOT);
!!VR(item:y):Si^mouse_item^;

!!if&(item)>=2/(item)<=14|(item)=20;
  !!VR(slot):S(item) -2;
!!el&(item)>=40/(item)<=44;
  !!VR(slot):S(item) -21;
!!en;

!!FU&(slot)=(NO_ART_SLOT):E;

!!HE(CURRENT_HERO):N?(hero:y);
!!FU(gem_ManageArtifactMouseAction):P(hero)/(slot);

!?FU(OnHeroesMeetScreenMouseClick)&i^mouse_action^=(MOUSE_RMB_PRESSED);
!!VR(hero:y):S(NO_HERO);
!!VR(item:y):Si^mouse_item^;

!!if&(item)>=27/(item)<=39|(item)=45;
  !!VR(slot:y):S(item) -27;
  !!CM:H?(hero)/?(otherHero:y);
!!el&(item)>=89/(item)<=93;
  !!VR(slot):S(item) -70;
  !!CM:H?(hero)/?(otherHero:y);
!!el&(item)>=46/(item)<=58|(item)=64;
  !!VR(slot):S(item) -46;
  !!CM:H?(otherHero)/?(hero);
!!el&(item)>=94/(item)<=98;
  !!VR(slot):S(item) -75;
  !!CM:H?(otherHero)/?(hero);
!!en;

!!FU&(hero)=(NO_HERO):E;

!!FU(gem_ManageArtifactMouseAction):P(hero)/(slot);

!?FU(gem_ManageArtifactMouseAction);
!#VA(hero:x) (slot:x);

; Get (art) from the slot clicked, exit if it has no artifact, is a lock or is a spell scroll
!!HE(hero):A1/?(art:y)/(slot);
!!FU|(art)<=(NO_ART)/(art)=(ART_ARTIFACT_LOCK)/(art)>=(ART_META_SPELLBOOK):E;

!!FU(gem_AssembleCombiArt):P(hero)/(slot)/(art)/?(result:y);
; Disassemble artifact only when there is no chance to assemble
!!FU(gem_DisassembleCombiArt)&(result)=(FALSE):P(hero)/(slot)/(art);

!?FU(gem_AssembleCombiArt);
!#VA(hero:x) (slot:x) (art:x) (result:x);

!!VR(result):S(FALSE);

; Check if the artifact is a part of a combination
!!UN:A(art)/5/?(combiPart:y);
!!FU&(combiPart)<=(NO_ART):E;

; Loop through all the artifacts and get all the parts of the (art) set
!!FU(NewIntArray):P?(combinationPartsList:y);
!!FU(Array_Push):P(combinationPartsList)/(art); [Add the clicked artifact to the start of the array]
!!FU(GetMaxArtifactId):P?(lastArt:y);

!!re i/(ART_FIRST)/(lastArt);
  !!co&i=(art);                         [skip the clicked artifact]

  ; Check if the artifact is a part of a combination artifact
  !!UN:Ai/5/?(combiArtPart:y);

  ; Push the artifact ID to the array if it is a part of the (art) set
  !!FU(Array_Push)&(combiArtPart)=(combiPart):P(combinationPartsList)/i;
!!en;

; Check if clicked on a slot of equipment
!!VR(clickedEquipmentSlot:y):S(FALSE);
!!VR(clickedEquipmentSlot)&(slot)<=(ART_SLOT_EQUIPPED_LAST):S(TRUE);

; Check the conditions of parts
!!SN:M(combinationPartsList)/?(size:y);
!!FU(NewIntArray):P?(combinationSlotsList:y);
!!FU(Array_Push):P(combinationSlotsList)/(slot); [Add the clicked artifact to the start of the array]

!!re i/1/(size)/1/-1;
  !!SN:M(combinationPartsList)/i/?(artPart:y);
  !!HE(hero):A2/(artPart)/?(has:y)/?(equipped:y);

  ; Break thw loop if there is one component the hero hasn't got
  !!br&(has)<=0:E;

  ; Get whether remove the artifact from equipment or backpack
  !!VR(searchFromEquipped:y):S(FALSE);

  !!if&(clickedEquipmentSlot);
    !!VR(searchFromEquipped)&(equipped)>0:S(TRUE);
  !!el;
    !!VR(backpacked:y):S(has) -(equipped);

    !!VR(searchFromEquipped)&(backpacked)<=0:S(TRUE);
  !!en;

  ; Loop through equipment or backpack to find the slot to be removed
  !!if&(searchFromEquipped);
    !!VR(startInd:y):S(ART_SLOT_EQUIPPED_FIRST);
    !!VR(endInd:y):S(ART_SLOT_EQUIPPED_LAST);
  !!el;
    !!VR(startInd):S(ART_SLOT_BACKPACK_FIRST);
    !!VR(endInd):S(ART_SLOT_BACKPACK_LAST);
  !!en;

  !!re j/(startInd)/(endInd);
    !!HE(hero):A1/?(artOfSlot:y)/j;

    !!if&(artOfSlot)=(artPart);
      !!FU(Array_Push):P(combinationSlotsList)/j;

      !!br;                             [Break the loop in case there are duplicates]
    !!en;
  !!en;
!!en;

; Exit if the hero hasn't got all the parts
!!FU&i<(size):E;

!!CM:R0;

; Get the combination artifact ID
!!UN:A(combiPart)/?(combiArt:y)/d/d;

; Set up extended combination parts description
!!FU(gem_WorkWithArtifact)&i^Advanced_Classes_Mod_Active^=0:P(hero)/(art);
!!FU(ACM_WorkWithArtifact)&i^Advanced_Classes_Mod_Active^=1:P(hero)/(art);

!!SN:H^art^/(art)/1/?(desc:z);
!!SN:H^art^/(combiArt)/0/?(combiArtName:z);
!!SN:T^gem.hero.assemble^/?(str:z)/^art^/(combiArtName);
!!VRs^gem_msg^:S^%(desc)%T(gem.endl)%T(gem.endl)%(str)^;

!!if|(combiArt)=(ART_POWER_OF_THE_DRAGON_FATHER)/^Advanced_Classes_Mod_Active^;
  !!IF:Q2/^%s(gem_msg)^; [Temp change for Dragon Father set as the text is too long and the IF:Q artifact icon overlaps]
!!el;
  !!IF:Q2/(PIC_TYPE_ART)/(combiArt)/(MSG_TYPE_QUESTION)/^%s(gem_msg)^;
!!en;

!!VRs^gem_msg^:S^^;

; Restore extended combination parts description
!!FU(gem_AfterShowNewArtifactDescription):P;

!!FU&-2:E;

; Remove parts from the hero
!!re i/0/(size)/1/-1;
  !!SN:M(combinationSlotsList)/i/?(artSlot:y);
  !!FU(gem_RemoveArtFromSlot):P(hero)/(artSlot);
!!en;

; Equip the combination artifact
; If clicked on an equipment slot
!!if&(clickedEquipmentSlot);
  !!HE(hero):A4/(combiArt);
; If clicked on a backpack slot
!!el;
  !!re i/(ART_SLOT_BACKPACK_FIRST)/(ART_SLOT_BACKPACK_LAST);
    !!HE(hero):A1/?(artOfSlot)/i;

    !!br&(artOfSlot)<=(NO_ART);
  !!en;

  !!if&i<=(ART_SLOT_BACKPACK_LAST);
    !!HE(hero):A(combiArt);                  [Generate the artifact in the backpack]
  !!el;
    !!HE(hero):A4/(combiArt);                [Generate the artifact in a slot of the body]
  !!en;
!!en;

!!VR(result):S(TRUE);
!!SN:D;

; This function is needed as FU(UnequipArtFromSlot) cannot be used to remove artifact from the backpack. 
!?FU(gem_RemoveArtFromSlot);
!#VA(hero:x) (slot:x);

!!FU&(slot)<=(NO_ART_SLOT):E;

; Execute FU(UnequipArtFromSlot) if the artifact is equipped
!!if&(slot)<=(ART_SLOT_EQUIPPED_LAST);
  !!FU(UnequipArtFromSlot):P(hero)/(slot);
; Use HE:A if the artifact is in the backpack
!!el;
  !!HE(hero):A1/?(art:y)/(slot);
  !!HE(hero):A3/(art)/1/0;
!!en;

!?FU(gem_DisassembleCombiArt);
!#VA(hero:x) (slot:x) (art:x);

; Loop through all the artifacts and see if (art) is a combination artifact
!!FU(NewIntArray):P?(combinationPartsList:y);
!!FU(GetMaxArtifactId):P?(lastArt:y);

!!re i/(ART_FIRST)/(lastArt);
  ; Check if the artifact is a part of a combination artifact
  !!UN:Ai/5/?(combiArtPart:y);

  ; If the artifact is a part, get the combination artifact ID
  !!if&(combiArtPart)>(NO_ART);
    !!UN:A(combiArtPart)/?(combiArt:y)/d/d;

    ; Push the artifact ID to the array if it is a part of the (art) set
    !!FU(Array_Push)&(combiArt)=(art):P(combinationPartsList)/i;
  !!en;
!!en;

; Exit if (art) is not a combination artifact
!!SN:M(combinationPartsList)/?(size:y);
!!FU&(size)=0:E;

; Get the quantity of backpack slots available
!!VR(availBackpackSlots:y):S1;          [Initialise as 1 because the combination artifact slot can be used for one of the parts]

!!re i/(ART_SLOT_BACKPACK_FIRST)/(ART_SLOT_BACKPACK_LAST);
  !!HE(hero):A1/?(artOfSlot:y)/i;
  !!VR(availBackpackSlots)&(artOfSlot)<=(NO_ART):+1;
!!en;

; Exit if not enough slots for all the parts
!!FU(gem_CheckIfEnoughSlots):P(hero)/(combinationPartsList)/(availBackpackSlots)/?(result:y);
!!FU&(result)=0:E;

; Ask if the player wants to disassemble the artifact
!!CM:R0;

!!SN:H^art^/(art)/1/?(desc:z);
!!FU(GetTextFileString):P^genrltxt^/734/?(str:z);
!!VR(msg:z):S^%(desc)%T(gem.endl)%T(gem.endl)%(str)^;
!!IF:Q2/^%(msg)^;

; Exit if the player choose not to disassemble
!!FU&-2:E;

; Remove the combination artifact from the hero
!!FU(gem_RemoveArtFromSlot):P(hero)/(slot);

; Loop through all the parts of the array put them to the hero
; If the combination artifact is in the backpack, the parts have higher priority to be put in the backpack
!!re i/0/(size)/1/-1;
  !!SN:M(combinationPartsList)/i/?(artPart:y);

  ; If the combination is equipped
  !!if&(slot)<=(ART_SLOT_EQUIPPED_LAST);
    !!HE(hero):A4/(artPart);
  ; If the combination is in the backpack
  !!el;
    !!if&(availBackpackSlots)>0;
      !!HE(hero):A(artPart);            [Generate the artifact in the backpack]
      !!VR(availBackpackSlots):-1;
    !!el;
      !!HE(hero):A4/(artPart);          [Generate the artifact in a slot of the body]
    !!en;
  !!en;
!!en;

!!SN:D;

!?FU(gem_CheckIfEnoughSlots);
!#VA(hero:x);                           [Hero who has the combiniation artifact]
!#VA(combinationPartsList:x);           [Array of all the parts of the combination artifact]
!#VA(availBackpackSlots:x);             [number of backpack slots available]
!#VA(result:x);                         [Out. 0 - not enought slot available. 1 - enought slot available]

; Check if all the parts can be allocated
; The following script assumes that all the parts have regular slots for equipment (for example, there should never be an art that can be equipped both the head and the misc slots)
; War Mechines, spell book should never be a part of combination artifacts
; There should be at least one part uses the same slot with the combination artifact
!!VR(result):S(TRUE);

; Get the quantity of ring/misc slots available
!!VR(availRingSlots:y):S0;

!!re i/(ART_SLOT_RIGHT_RING)/(ART_SLOT_LEFT_RING);
  !!HE(hero):A1/?(artOfSlot:y)/i;
  !!VR(availRingSlots)&(artOfSlot)<=(NO_ART):+1;
!!en;

!!VR(availMiscSlots:y):S0;
!!VR(miscArtSlots[5]:y):C(ART_SLOT_MISC_1)/(ART_SLOT_MISC_2)/(ART_SLOT_MISC_3)/(ART_SLOT_MISC_4)/(ART_SLOT_MISC_5);

!!re i/0/(miscArtSlots[SIZE])/1/-1;
  !!HE(hero):A1/?(artOfSlot)/(miscArtSlots[i]);
  !!VR(availMiscSlots)&(artOfSlot)<=(NO_ART):+1;
!!en;

; Loop through all the parts and calculate how many backpack slots are needed
!!SN:M(combinationPartsList)/?(size:y);

!!re i/0/(size)/1/-1;
  !!SN:M(combinationPartsList)/i/?(artPart:y);
  
  !!UN:A(artPart)/2/?(artPosUNA:y);     [Note that there is a difference between UN:A slots and HE:A!]

  !!if&(artPosUNA)=0;
    !!VR(availBackpackSlots):-1;
  !!el&(artPosUNA)>=1/(artPosUNA)<=6|(artPosUNA)=8;
    !!if&(artPosUNA)=1;
      !!VR(artPosHEA:y):S(ART_SLOT_HEAD);
    !!el&(artPosUNA)=2;
      !!VR(artPosHEA):S(ART_SLOT_SHOULDERS);
    !!el&(artPosUNA)=3;
      !!VR(artPosHEA):S(ART_SLOT_NECK);
    !!el&(artPosUNA)=4;
      !!VR(artPosHEA):S(ART_SLOT_RIGHT_HAND);
    !!el&(artPosUNA)=5;
      !!VR(artPosHEA):S(ART_SLOT_LEFT_HAND);
    !!el&(artPosUNA)=6;
      !!VR(artPosHEA):S(ART_SLOT_TORSO);
    !!el&(artPosUNA)=8;
      !!VR(artPosHEA):S(ART_SLOT_FEET);
    !!en;

    !!HE(hero):A1/?(artOfSlot:y)/(artPosHEA);
    !!VR(availBackpackSlots)&(artOfSlot)>(NO_ART):-1;
  !!el&(artPosUNA)=7;                   [Rings]
    !!if&(availRingSlots)>0;
      !!VR(availRingSlots):-1;
    !!el;
      !!VR(availBackpackSlots):-1;
    !!en;
  !!el&(artPosUNA)=9;                   [Miscs]
    !!if&(availMiscSlots)>0;
      !!VR(availMiscSlots):-1;
    !!el;
      !!VR(availBackpackSlots):-1;
    !!en;
  !!en;

  !!br&(availBackpackSlots)<0;
!!en;

!!VR(result)&i<(size):S(FALSE);


// Fix passability after visiting prisons with game bug fixes extended enabled
// by Archer30
; This is a fix specifically for igrik's game bug fixes extended plugin
; The second tile of prison doesn't become passable after the prison's removal for some reason 
!$OB(OBJ_PRISON);
!!HEv998/v999/v1000:O?(owner:y);        [Check the owner of the visiting hero in the prison]

; Exit if the rescured hero does not belong to the current player for some reason
!!FU&(owner)<>i^timerOwner^:E;

; Exit if the second tile of prison is out of map
!!VR(x:y):Sv998 -1;                     [Get the tile to the left of the prison]
!!FU&(x)<0:E;

*!OB(x)/v999/v1000:T?(type:y);          [here the type only returns 62 (prison) so there is no point checking it]
!!TR(x)/v999/v1000:P1;


// Restrain hero level at 74 in random maps
// by Archer30
; Hero can reach no more than Level 74 in random maps
!?FU(OnAfterErmInstructions);
*!UN:J1/?(lv:y)/d;
*!FU&(lv)<>0:E;

!!UN:C(GAME_MANAGER)/(UNC_INT)/?(gameMgr:y);
!!UN:C(gameMgr)/128980/1/?(mapType:y);

!!if&(mapType)=114;
  !!UN:J1/74/d;
!!en;


// Prevent hero level to exceed the limit for all the cases
// by Archer30
; Not evn possible to break through the limit with HE:E
!?FU(gem_CreateERMHook);
!!SN:Ex1/1/5089718/(gem_OnCheckHeroLevelUp); 4DA9B6

!?FU(gem_OnCheckHeroLevelUp);
; Exit if there isn't a limit
!!UN:J1/?(maxLv:y)/?(var:y);           [UN:J1 result is not reliable. Don't use it!]
!!FU|(maxLv)<=0/(maxLv)>74:E;

!!SN:E5088784/(CALLCONV_FASTCALL)/(maxLv);
!!VR(maxExp:y):Sv1;

!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDI)/4/?(exp:y);
!!VR(exp):F0/(maxExp);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDI)/4/(exp);


// Fix resetting AI thinking radius to 4096 after loading a save game with HD mod feature
// by Archer30
; This is not a fix but simiply setting UN:J4 to ERA default, should secure the gameplay in most cases
; Discussion: http://wforum.heroes35.net/showthread.php?tid=4218&pid=138675#pid138675
!?FU(OnAfterErmInited);
!!UN:J4/?i^gem_aiThinkingRadius^;
!!VRi^gem_aiThinkingRadius^:F32000/(INT_MAX);

!?FU(OnGameEnter);
!!UN:J4/?(radius:y);
!!UN&(radius)<=4096:J4/i^gem_aiThinkingRadius^;


// Disable tactics message before tactics - 0x462D98 JMP SHORT 0x462DCA
!?FU(OnGameEnter);
!!UN:C4599192/2/12523;
!!UN:C4599194/4/2425393296;


// Enable combination artifacts and 5th misc slot for RoE/AB maps
// by Hawaiing
!?FU(OnGameEnter);
!!UN:C(GAME_MANAGER)/(UNC_INT)/?(gameMgr:y);
!!UN:C(gameMgr)/128664/(UNC_INT)/?(mapExpansion:y);
!!UN&(mapExpansion)<2:C(gameMgr)/128664/(UNC_INT)/2;


// Divide all the AI values by 5 in order to prevent negative values after gathering massive amount of troops
// by Archer30
!?FU(OnAfterErmInstructions);
; Divide AI values only when Peasant's AI value is original (15)
!!MA:I(MON_PEASANT)/?(aiValuePeasant:y);

!!if&(aiValuePeasant)=15;
  !!FU(GetMaxMonsterId):P?(lastMon:y);
  !!VR(arraySize:y):S(lastMon) +1;
  !!FU(NewIntArray):P(arraySize)/?i^gem_origAiValues^/(M_STORED);

  !!re i/(MON_FIRST)/(lastMon);
    !!MA:Ii/?(aiValue:y);
    !!SN:Vi^gem_origAiValues^/i/(aiValue);
  !!en;

  !!VRi^gem_aiValuesDivided^:S(TRUE);
!!en;

!!FU(gem_ManageAIValues):P1;

!?OB(OBJ_ALTAR_OF_SACRIFICE);
!!FU(gem_ManageAIValues):P0;

!$OB(OBJ_ALTAR_OF_SACRIFICE);
!!FU(gem_ManageAIValues):P1;

!?FU(gem_ManageAIValues)&i^gem_aiValuesDivided^;
!#VA(mode:x);                           [0 - restoration, 1 - division]

!!FU(GetMaxMonsterId):P?(lastMon:y);

; Restoration
!!if&(mode)=0;
  !!re i/(MON_FIRST)/(lastMon);
    !!SN:Vi^gem_origAiValues^/i/?(aiValue:y);
    !!MA:Ii/(aiValue);
  !!en;
; Division
!!el;
  !!re i/(MON_FIRST)/(lastMon);
    !!MA:Ii/d:5;
  !!en;

  !!VRi^gem_aiValuesDivided^:S(TRUE);
!!en;


// Other stuff
!?FU(OnGameEnter);

  !!UN:C6052891/1/4;                    [центрируем текст названия города в окне города (id 149)]
  ; радус открытия всей карты
  !!UN:C5196631/4/320;                  [чит-меню (ориг = 180)]
  !!UN:C4204282/4/360;                  [чит wogeyeofsauron (ориг = 200)]
  ; радус закрытия всей карты
  !!UN:C4204369/4/360;                  [чит wogeyeofsauron (ориг = 200)]
  !!UN:C5125902/4/34281 C5125907/1/144; [; отключить сообщение об ограничении опыта © Berserker]
  
  !!TL:E1; enable mulpiplayer timer

  // Fix of the speed overload
  !!SN:F^GetModuleHandleA^/^BattleSpeed.era^; [check plugin is loaded]
  !!if&v1<1;
    !!UN:C6916156/4/?(gameSpeed:y);     [if not loaded and speed >2]
    !!UN&(gameSpeed)>2:C6916156/4/2;    [set speed to 2]
  !!el;
    !!UN:C4203475/6/4/8;             [set gosolo speed as 9]
  !!en;
*!UN:C5021668/1/144; cartographer lvl revie only upper level
  // 4 lines of the creature description instead of 3 

  !!UN:C6241860/1/1/?(baseHeight:y); if the best of the plugin isn't active
  !!if&(baseHeight)=41;
    !!UN:C6241860/1/1/54  C6243439/1/1/54  C6244490/1/1/54; [UN:C 5F3E44/1/1/54  C 5F446F/1/1/54  C 5F488A/1/1/54; [height of the creature desc in Battle/notBattle/buy creature info DLGs]
    !!UN:C6241867/1/4/230 C6243446/1/4/230 C6244497/1/4/230; [yPos of the creature desc in Battle/notBattle/buy creature info DLGs]
  !!en;


  // fix AI behavior on the map >XL
  !!UN:X?(mapSize:y)/?y77;
  !!if&(mapSize)>145;
    !!re i/0/4;(end_value);
      !!UN:C7841770/i/1/?i^gem_ai_move_patch_%i^ C7841770/i/1/144;
      !!UN:C7841673/i/1/?i^gem_ai_move_patch_%i_1^ C7841673/i/1/144;
    !!en;
  !!en;

!?FU(OnGameLeave)&i^gem_ai_move_patch_1^;
  !!re i/0/4;(end_value);
    !!UN:C7841770/i/1/i^gem_ai_move_patch_%i^ C7841673/i/1/?i^gem_ai_move_patch_%i_1^; // skip ai move foo call
  !!en;


!?FU(gem_CreateERMHook);
!!SN:Ex1/1/5576191/(gem_OnRecruitCreatureDlgLeftClick);
!!SN:Ex1/1/4435778/(gem_AI_GetCloneCastValue);

// disable message about hiring army from dwelling after combat;
!!SN:Ex1/1/4856136/(gem_OnDwellingFreeJoin);
!!SN:Ex1/1/4856798/(gem_OnDwellingJoinMessage);

!?FU(gem_OnDwellingFreeJoin);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/?(dwellingMons:y);
!!re i/0/3;(end_value);
  !!VR(offset:y):Si*2;
  !!UN:C(dwellingMons)/(offset)/2/?k;
  !!if&k;
    !!VRi^gem_skipMsg^:S(TRUE);
    !!br;
  !!en;
!!en;

!?FU(gem_OnDwellingJoinMessage)&i^gem_skipMsg^;
!!VRi^gem_skipMsg^:S(FALSE);

!!UN:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/?(string:y);
!!SN:E4210992/(CALLCONV_THISCALL)/(string)/0;
!!SN:X?y99/0;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/4856803;

!?FU(gem_AI_GetCloneCastValue);
!!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y) C(cmbMgr)/78528/4/?(currentActiveSide:y);
!!VR(heroArmyMonCountOffset:y):S(currentActiveSide) *4 +21692;
!!UN:C(cmbMgr)/(heroArmyMonCountOffset:y)/4/?(numberOfStacks:y);

!!if&(numberOfStacks)>=20;

  !!SN:X?y99/0;
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/4435884;
!!en;

*!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(stack:y) C(stack)/244/4/?(side:y);


!?FU(gem_CreateERMHook);
!!SN:Ex1/1/5574304/(gem_OnOpenRecruitDlg);

!?FU(OnOpenRecruitDlg);
!!VRi^gem_RecruitDlg_NeedToGetData^:S1;

!?FU(OnCloseRecruitDlg);
!!VRi^gem_CurrentProc_Dlg^:S0;
!!VRi^gem_CurrentProc_Msg^:S0;
!!VRi^gem_RecruitDlg_CurrentDlg^:S0;

!?FU(gem_OnOpenRecruitDlg)&i^gem_RecruitDlg_NeedToGetData^;
!!FU(H3Dlg_GetCurrentDlg):P?i^gem_RecruitDlg_CurrentDlg^;
!!VRi^gem_RecruitDlg_NeedToGetData^:S0;

!!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?i^gem_CurrentProc_Dlg^ Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y)
C(ebp)/8/4/?i^gem_CurrentProc_Msg^;
!!FU(gem_RecruitDlg_SetMax):Px1;

!?FU(OnKeyPressed)&i^gem_CurrentProc_Dlg^;

!!if&x1>=(KEY_1)/x1<=(KEY_4)|x1=(KEY_RIGHT)/x1=(KEY_LEFT);
!!FU(H3Dlg_GetCurrentDlg):P?(currentDlg:y);
!!FU&i^gem_RecruitDlg_CurrentDlg^<>(currentDlg):E;
  !!VR(dlg:y):Si^gem_CurrentProc_Dlg^;
  !!UN:C(dlg:y)/88/4/?(currIndex:y);
  !#VA(items[4]:y);
  !!UN:C(dlg:y)/92/4/?(items[0]) C(dlg:y)/96/4/?(items[1]) C(dlg:y)/100/4/?(items[2]) C(dlg:y)/104/4/?(items[3]);
  !!VR(max:y):S-1;
  !!re i/0/3;

    !!if&(items[i])<>(NO_MON);
      !!VR(max:y):+1;
    !!en;
  !!en;

  !!if&(max:y);
    !!VR(saveIndex:y):S(currIndex);
    !!if&x1<(KEY_1);
      !!VR(offset:y):Sx1 -38;
      !!VR(currIndex):+(offset:y);
      !!if&(currIndex)>(max:y);
        !!VR(currIndex):S0;
      !!el&(currIndex)<0;
        !!VR(currIndex):S(max:y);
      !!en;
    !!el;
      !!VR(currIndex:y):Sx1 -(KEY_1);
    !!en;
    !!VR(currIndex):F0/(max:y);
    !!if&(saveIndex)<>(currIndex);
      !!VR(currIndex):+538;
      !!VR(msg:y):Si^gem_CurrentProc_Msg^;
      !!UN:C(msg)/4/4/12 C(msg)/4/512 C(msg)/8/4/(currIndex);
      !!SN:E5573952/(CALLCONV_THISCALL)/(dlg:y)/(msg:y);
    !!en;
  !!en;
!!en;

!?FU(gem_OnRecruitCreatureDlgLeftClick);
!!FU(gem_RecruitDlg_SetMax):Px1;

!?FU(gem_RecruitDlg_SetMax);
!#VA(hookContext:x);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDI)/4/?(isRmc:y);
!!FU&(isRmc):E;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?(dlg:y) C(dlg)/172/4/?(availableCreatures:y);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(msg:y) C(msg)/8/4/?(clickedItem:y);

!!if&(clickedItem)>=538/(clickedItem)<=541;
  !!VR(offset:y):S(clickedItem) -538 *4 +92;
  !!UN:C(dlg:y)/(offset:y)/4/?t;
  !!if&t<>(NO_MON);
    !!re j/0/(RES_GEMS);
      !!MA:Ct/j/?n;
      !!if&n;
        !!FU(gem_DlgDefProc):P508/j P529/j;;
        !!br;
      !!en;
    !!en;
  !!en;
!!en;

!!if&(clickedItem)<1000/(availableCreatures:y)>0; 

  !!UN:C(msg)/4/4/13 C(msg)/4/512 C(msg)/8/4/532;
  !!SN:E5573952/(CALLCONV_THISCALL)/(dlg)/(msg); [refresh with "max btn pressed" dlg]

!!en;

// disable mulpiplayer timer
!?FU(OnGameLeave);
  !!TL:E0; 

4C841C
// Fix crash in map veiew dlg with random Theme Music mod - currenlty disabled
*?FU(gem_OnOpenMapViewDlg);
  *!FU(gem_Buttons_Interaction):P(TRUE);

*?FU(gem_OnCLoseMapViewDlg);
  *!FU(gem_Buttons_Interaction):P;

// refresh screen after placing stack
!?FU(gem_CreateERMHook);
!!SN:Ex1/1/7696427/(gem_OnMonsterPlaceAtMap);

!?FU(gem_OnMonsterPlaceAtMap);
!!UN:R1;

// Fix rebuilding town (after demolishing) doesn't update the max level of Mage Guild in random maps
// by Archer30
; Note: This hack is only valid for random maps as it can't tell whether the restriction comes from town type or is it from the map author
; This script would conflict with mods that extends the max level of Mage Guilds in towns
!?FU(OnAfterBuildTownBuilding);
!#VA(townId:x) (buildingId:x);

; Check if it is a random map
!!UN:C(GAME_MANAGER)/(UNC_INT)/?(gameMgr:y);
!!UN:C(gameMgr)/128980/1/?(mapType:y);[114 [r]andom_maps)]
!!FU&(mapType)<>114:E;

; Exit if not building (demolishing) town hall
!!FU&(buildingId)<>10:E;

; Exit if not from town screen
!!FU(H3Dlg_GetCurrentDlgId):P?(result:y);
!!FU&(result)<>(DLG_TOWN_SCREEN):E;

; Get the town type to decide the max level of Mage Guilds
!!CA0/(townId):T?(townType:y);
!!VR(maxLevel:y):S2;

; For Castle, the max level is 4
!!if&(townType)=(TOWN_CASTLE);
  !!VR(maxLevel):S3;
; For the rest of the towns except for Stronghold and Fortress, the max level is 5
!!el&(townType)<>(TOWN_STRONGHOLD)/(townType)<>(TOWN_FORTRESS);
  !!VR(maxLevel):S4;
!!en;

; Allow 4th/5th level of Mage Guild to be built depending on town type
!!if|(maxLevel)=3/(maxLevel)=4;
  !!CA0/(townId):B4/3;
!!en;

!!CA0/(townId)&(maxLevel)=4:B4/4;

; Set available spells
!!FU(gem_Town_GetStruct):P(townId)/?(townStruct:y);
; Tricky way to set addresses to 0
!!VRz1:S^^;
!!SN:E6023680/(CALLCONV_THISCALL)/(townStruct)/?z1;

; Compatibility with Spell Research Mod
!!UN:C6848424/4/?(spellsTable:y);
!!FU(srm_SetUpTown):P(townId)/(spellsTable);


// Rebalance Hill Forts - the cost of upgrade is calculated based on the level of the upgraded monster instead of the pre-upgraded monster
// by Archer30
; This is considered a bug fix as in the original H3, every upgrade has the same creature level before and after
; In WoG with Extended Upgrade option, it's possible to upgrade Gremlins (level 1) to Santa Gremlins (leve 3) for free (since the fee is calculated based on Gremlins)
; This script fixes this so that such upgrade would costs a little amount of fee (but still with discount as Hill Forts always do to low level creatures)
!?FU(gem_CreateERMHook);
!!SN:Ex1/1/5144591/(gem_OnGetHillFortMonLevel); 5144591

!?FU(gem_OnGetHillFortMonLevel);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/?(mon:y);

!!if&(mon)>(NO_MON);
  !!FU(GetUpgradedMonster):P(mon)/?(upgMon:y);
  !!UN&(upgMon)>(NO_MON):Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/(upgMon);
!!en;


// Bad Fix: Prevent the curent movement points exceeds the max movement points
// by Archer30
; Many mod maker forgot to set both HE:W/G at the same time, resulting not possible to dig in a new day
; WoG - Bonus and Curse feature (HE:Y) also ignore this problem. Discussion: http://wforum.heroes35.net/showthread.php?tid=4218&pid=138991#pid138991
; Here we set HE:G to the same value with HE:W to prevent this issue happens
!?FU(OnEveryDay_Quit)&i^timerOnce^;
!!re i/(HERO_FIRST)/(HERO_LAST_WOG);
  !!HEi:W?(currMp:y)/1 G?(maxMp:y);
  !!HEi&(currMp)>(maxMp):G(currMp);
!!en;


************************************************************************
************************************************************************
***************************** BATTLE FIXES *****************************
************************************************************************
************************************************************************

// Fix infinite loop when a revived stack tries to defend when defended the same turn
// by Archer30
; For some reason, the AI's revived stack would try to defend even when it's defended in a turn
; This results in an infinite loop - AI could possibly try to defend again and again
; This script ensure defending status is removed on stack turn
; Latest report (not sure if it's this issue): https://discord.com/channels/665742159307341827/666205480808611861/1317824602222755841
!?FU(OnBattleStackObtainsTurn);         [The native defense restoration is at 00446BA7]
!!BMi^battle_current_stack^:F?(flags:y);
!!VR(isDefending:y):S(flags) &(MON_FLAG_DEFENDING);

!!if&(isDefending);
  !!VR(stack:y):Si^battle_current_stack^;
  !!BM(stack):Z?(stackStruct:y);

  !!UN:C(stackStruct)/1244/4/?(bonusDefense:y);
  !!BM(stack):Fd~(MON_FLAG_DEFENDING);
  !!BM(stack):D?(defense:y);
  !!VR(defense):-(bonusDefense) F0/(INT_MAX);
  !!BM(stack):D(defense);
!!en;

// Fix messing up creature stats with stack exp after battle replay when the stack was killed with Summoned flag
// by Archer30
// This should be fixed in BattleReplay plugin if possible
// Fix is needed only when the battle is visible before battle replay
; Discussion: http://wforum.heroes35.net/showthread.php?tid=4218&pid=139509#pid139509
!?FU(OnBeforeBattleReplay)&i^battle_isVisible^; [Execute OnBeforeBattleReplay only when the battle was visible. Otherwise stack exp data could be corrupted!]
*?FU(OnBattleReplay);                   [This is safer but potentially not soon enough for external scripts.]
!!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y);
!!UN:C(cmbMgr)/21700/4/?(atkStruct:y);
!!UN:C(cmbMgr)/21704/4/?(defStruct:y);
!!SN:E7500058/(CALLCONV_CDECL)/(atkStruct)/(defStruct); 72711A

// Fix missing background when battle on the sea with no boat
// by Archer30
; This can happen when there is a battle event on the sea and the hero uses Fly/Water Walk to get across
; This fix will be replaced later, as ideally, events on water should not be triggered at all if the hero stepping on is not on a boat
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!SN:E(setHook)/1/4604702/(gem_OnDetermineBattleBackground);

!?FU(gem_OnDetermineBattleBackground)&i^battle_hero_1^=(NO_HERO);
!#VA(hook:x);

!!TRi^battle_x^/i^battle_y^/i^battle_z^:T?(type:y)/?t/?t/?t/?t/?t/?t/?t;

!!if&(type)=8;
  !!SN:X?t/0;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/4604712;
!!en;

// Fix messing up spell immunity checks for stack exp spells
// by Archer30
; WoG doesn't use the native way to check spell immunity for stack exp spells, this script fixes its behaviours.
; Sorceress spell uses the same function, yet it seems to respect correct spell immunity, thus we igonre here.
; Discussion: http://wforum.heroes35.net/showthread.php?tid=4218&pid=139198#pid139198
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!SN:E(setHook)/1/7715330/(gem_OnCheckWoGSpellImmunity);

!?FU(gem_OnCheckWoGSpellImmunity);
!#VA(hook:x);

; Get spell id
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/24/4/?(spell:y);
*!UN:C42232368/4/?(spell:y);            [This method would be 60 if Sorceress]

; Exit if sorceress (-1 for random spells)
!!FU&(spell)=-1:E;

; Get the target structure
!!UN:C(ebp)/12/4/?(targetStruct:y);

; Get the current stack structure and the real side (reverse if hypnotized)
!!UN:C(COMBAT_MANAGER)/4/?(combatManager:y);
!!SN:E7712518/(CALLCONV_CDECL)/(combatManager); [export to v1]
!!VR(currStruct:y):Sv1;
!!UN:C(currStruct)/244/4/?(side:y);
!!UN:C(currStruct)/648/1/?(hypnotizeDuration:y);
!!VR(side)&(hypnotizeDuration)>0:X(TRUE);

; Check if the stack accepts the spell
!!SN:E5914512/(CALLCONV_THISCALL)/(combatManager)/(spell)/(side)/(targetStruct)/1/1;
!!VR(result:y):Sv1;

; Export the result
!!UN:C(ebp)/-4/4/(result);

; Set up i=0 (for CS_Spells table)
; Does not work for Sorceress here (but not needed)
!!UN:C(ebp)/-16/4/0;

; Jump over all the messy code
!!SN:X?t/0;
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/7717164; 75C12C

// Update the number of stacks when a summoned stack is killed
// by Archer30
; In the orignal H3, the total number of stacks allowed is 20 for one side of the battlefield
; Once we reaches 20 stacks and have some summoned stacks killed, we still can't summon more units

; At the moment both solutions are disabled. They do not work.

; First approach (disbaled for now)
; This approach is safe but the efficiency probably isn't the best - Not really, it gives false positive (summoned stack can be invisible)
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!FU:E;

!!SN:E(setHook)/1/5896030/(gem_OnCheckIfPossibleToClone);
!!SN:E(setHook)/1/5896307/(gem_OnCheckIfPossibleToSummon); 59F873

!?FU(gem_OnCheckIfPossibleToClone);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EAX)/4/?(usedStackQty:y);

; Double check if the all 20 stacks are occupied
!!if&(usedStackQty)>=20;
  ; Get the side
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
  !!UN:C(ebp)/-20/4/?(side:y);

  ; Check
  !!FU(gem_CheckIfPossibleToCreateMoreStacks):P(side)/?(result:y);

  ; If there is any slot that is killed/summoned, treat it as possible to summon
  !!if&(result);
    !!SN:X?t/0;
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/5896113;
  !!en;
!!en;

!?FU(gem_OnCheckIfPossibleToSummon);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EDI)/4/?(side:y);
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(combatManager:y);
!!VR(offset:y):S(side) *(UNC_INT) +21692; 54BC
!!UN:C(combatManager)/(offset)/4/?(usedStackQty:y);

; Double check if the all 20 stacks are occupied
!!if&(usedStackQty)>=20;
  ; Check
  !!FU(gem_CheckIfPossibleToCreateMoreStacks):P(side)/?(result:y);

  ; If there is any slot that is killed/summoned, treat it as possible to summon
  !!if&(result);
    !!SN:X?t/0;
    !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/5896317;
  !!en;
!!en;

!?FU(gem_CheckIfPossibleToCreateMoreStacks);
!#VA(side:x) (result:x);

!!VR(result):S(FALSE);

!!VR(startInd:y):S(side) *(BATTLE_STACKS_PER_SIDE);
!!VR(endInd:y):S(startInd) +19;

!!re i/(startInd)/(endInd);
  !!BMi:F?(flags:y);

  !!VR(isSummoned:y):S(flags) &(MON_FLAG_SUMMONED);
  !!VR(isDead:y):S(flags) &(MON_FLAG_DIED);

  !!br&(isSummoned)/(isDead);
!!en;

!!VR(result)&i<=(endInd):S(TRUE);

; Second Approach (disbaled for now)
; This solution doesn't work for some reason
; This approach assumes that combat manager->54BC isn't used anywhere except for Summon Elemental/Clone
; When a stack of summoned elemental is killed, the stack slot is free to be recycled, yet the total number of stack (combat manager->54BC) isn't updated
; This script updates 54BC when needed
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!FU:E;

!!SN:E(setHook)/1/4472412/(gem_HOOK_BattleStackKilled); 443E5C

!?FU(gem_HOOK_BattleStackKilled);
!#VA(hook:x);

!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_ESI)/4/?(stackStruct:y);
!!FU&(stackStruct)=(NULL):E;

!!UN:C(stackStruct)/132/4/?(flags:y);
!!VR(isSummoned:y):S(flags) &(MON_FLAG_SUMMONED);

!!if&(isSummoned);
  !!UN:C(stackStruct)/244/4/?(side:y);
  !!VR(offset:y):S(side) *(UNC_INT) +21692; 54BC
  !!UN:C(COMBAT_MANAGER)/(offset)/4/d-1;
!!en;

; Update the current stack quantity when summoning a new stack no matter whether the stack id is a new one or not
!?FU(OnGameEnter);
!!FU:E;

!!UN:C4692776/2/(OPCODE_NOP_2);


** Shackles of war (retreat vs neutrals bttles with SW)
!?FU(OnBeforeBattleAction)|i^battle_hero_1^<=(NO_HERO)/i^wog_72_randHeroActive^; [Works when the defender has no hero OR is a random hero (WoG Scripts)]
!!BG:A?(actionType:y);

!!if&(actionType)=(BATTLE_ACTION_RETREAT);
  !!UN:C4689325/1/(ART_GRAIL);          [replace checked artId on hero to Grail from Shakles]
!!en;

!?FU(OnAfterBattleUniversal);
!!UN:C4689325/1/(ART_SHACKLES_OF_WAR);           [set back correct art id]

!?FU(OnGameLeave);
!!UN:C4689325/1/(ART_SHACKLES_OF_WAR);           [set back correct art id]

!?FU(OnBattleScreenMouseClick)&i^mouse_battleHex^>=(BATTLE_HEX_FIRST)/i^mouse_battleHex^<=(BATTLE_HEX_LAST);
!!BU:Ei^mouse_battleHex^/?(stackId:y);

!!if&(stackId)>(NO_STACK);
  !!UN:P(WOG_OPT_STACK_EXPERIENCE)/?(isStackExp:y);
  !!VR(isStackExp):X1;
  !!UN:J11/(isStackExp);
!!en;

** War Machines Cost 1 gold when surrend
; Note: It's required to use 3 triggers as the battle may not be triggered (BA:D1), also there is battle replay
!?FU(OnBeforeBattleUniversal);
  !!UN:P73/?(isEnabled:y);              [check if option is enabled]

  !!if&(isEnabled)=(FALSE);
    !!re i/(MON_CATAPULT)/(MON_AMMO_CART);
      !!MA:Ci/(RES_GOLD)/?i^gem_%i_machine_cost^;
    !!en;
  !!en;

!?FU(OnSetupBattlefield);
  !!UN:P73/?(isEnabled:y);              [check if option is enabled]

  !!if&(isEnabled)=(FALSE);
    !!re i/(MON_CATAPULT)/(MON_AMMO_CART);
      !!MA:Ci/(RES_GOLD)/1;
    !!en;
  !!en;

!?FU(OnAfterBattleUniversal);
!!UN:P73/?(isEnabled:y);                [check if option is enabled]

!!if&(isEnabled)=(FALSE);
  !!re i/(MON_CATAPULT)/(MON_AMMO_CART);
    !!MA:Ci/(RES_GOLD)/i^gem_%i_machine_cost^;
    !!VRi^gem_%i_machine_cost^:S(NULL);
  !!en;
!!en;

!?FU(gem_OnOpenCreatureCombatDlg);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/8/4/?(stack:y);

!!UN:C(COMBAT_MANAGER)/4/?(cmbMgr:y) C(stack)/244/4/?(side:y);
!#VA(hero[2]:y) (armyPtr[2]:y);
!!UN:C(cmbMgr:y)/21440/4/?(ground:y) C(cmbMgr)/21452/4/?(hero[0]) C(cmbMgr)/21456/4/?(hero[1])
C(cmbMgr)/21700/4/?(armyPtr[0]) C(cmbMgr)/21704/4/?(armyPtr[1]);

!!VR(oppSide:y):S1 X(side);

!!if&(side);
  !!UN:C(cmbMgr)/21448/4/?(town:y);
!!el;
  !!VR(town:y):S(NULL);
!!en;

!!SN:E4447296/(CALLCONV_THISCALL)/(stack)/(hero[side])/(armyPtr[side])/(town)/(hero[oppSide])/(armyPtr[oppSide])/(ground);         [recalc luck and morale for stack only]

!?FU(gem_CreateERMHook);

// open creatureInfoIncombat;

!!SN:Ex1/1/6240062/(gem_OnOpenCreatureCombatDlg); // for morale stat changing


//stat changing
!!SN:Ex1/1/4500782/(gem_OnAfterArmySetNegativeMorale); // for morale stat changing

!!SN:Ex1/1/4501536/(gem_OnAfterArmySetNegativeLuck); for negative luck stat changing in combat only
!!SN:Ex1/1/4447391/(gem_OnAfterArmySetPositiveLuck); for positive luck stat changing in combat only

!!SN:Ex1/1/4501694/(gem_OnCreatureGetLuckLvl); for luck stat changing not in combat only


// text changing
!!SN:Ex1/1/4505906/(gem_OnCreatureLuckDescriptionHalfingPart);
!!SN:Ex1/1/4506010/(gem_OnCreatureLuckDescriptionSpellPartStart);
!!SN:Ex1/1/4506086/(gem_OnCreatureLuckDescriptionSpellPartEnd);


!!SN:Ex1/1/4505740/(gem_OnCreatureArchiDevilDescriptionCreate);
!!SN:Ex1/1/4504226/(gem_OnCreatureArchAngelDescriptionCreate);
!!SN:Ex1/1/4504330/(gem_OnCreatureGhostDragonDescriptionCreate);
!!SN:Ex1/1/4504347/(gem_OnCreatureGhostDragonDescriptionCreate);
  


!?FU(gem_OnCreatureArchAngelDescriptionCreate);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/?(namePtr:y);
  !!if&i^gem_MonPlusMoraleChanger^;
    !!SN:H^monname^/i^gem_MonPlusMoraleChanger^/1/?z3;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/9598952;                         [set new ptr at mon name]
    !!VRi^gem_MonPlusMoraleChanger^:S0;
    !!VR(power:y):S2;  
  !!el;
    !!VR(power:y):S1;
  !!en;
  !!FU(gem_BufferEndingEditor):P6969508/(power);



!?FU(gem_OnCreatureArchiDevilDescriptionCreate);
  !!if&i^gem_MonMinusLuckChanger^;
    !!SN:H^monname^/i^gem_MonMinusLuckChanger^/1/?z2;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/9598440;                         [set new ptr at mon name]
    !!VR(power:y):S2;
    !!VRi^gem_MonMinusLuckChanger^:S0;
  !!el;
    !!VR(power:y):S1;
  !!en;

  !!FU(gem_BufferEndingEditor):P6969512/(power);

!?FU(gem_BufferEndingEditor);
!#VA(bufferPtr:x) (newEnding:x);

  !!UN:C(bufferPtr:x)/4/?(facingPtr:y);
  !!SN:B(facingPtr:y)/d/?z1;
  !!SN:Kz1/?(length:y);
  !!VR(length):-1;
  !!SN:Kz1/(length:y)/^%(newEnding)^;
  !!SN:B(facingPtr:y)/d/z1;

!?FU(gem_OnCreatureLuckDescriptionHalfingPart)&i^gem_MonPlusLuckChanger^;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/16/4/?(monLuck:y) C(ebp)/20/4/?(heroLuck:y)
C(ebp)/16/4/d-i^gem_MonPlusLuckPower^ C(ebp)/20/4/di^gem_MonPlusLuckPower^;
*!VRi^weNeedReturn^:S(TRUE);
*!IF:L^%(monLuck) %(heroLuck:y)^;
!?FU(gem_OnCreatureLuckDescriptionSpellPartStart)&i^gem_MonPlusLuckChanger^;/i^weNeedReturn^;
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y); C(ebp)/16/4/?(bonusLuck:y) C(ebp)/20/4/?(luck:y);
*!if&i^weNeedReturn^;
*!IF:L^%^;
  !!SN:H^monname^/(MON_GHOST_BEHEMOTH)/1/?z3;
  !!FU(gem_BufferEndingEditor):P6969508/i^gem_MonPlusLuckPower^;

  !!UN:C6969508/4/?(txtPtr:y);
  !!SN:E6388190/(CALLCONV_CDECL)/?z2/(txtPtr:y)/z3;/0/0;
  !!FU(gem_BufferEndingEditor):P6969508/1;

  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/9598440 C(ebp)/16/4/di^gem_MonPlusLuckPower^;
  C(ebp)/20/4/d-i^gem_MonPlusLuckPower^ C(ebp)/20/4/d-i^gem_MonPlusLuckPower^ ;
  !!VRi^gem_MonPlusLuckPower^:S(NULL);
*!en;

!?FU(gem_OnCreatureLuckDescriptionSpellPartEnd)&i^gem_MonPlusLuckChanger^;/i^weNeedReturn^;
!!SN:X?y99/0;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/4505994; return dunction described above
!!VRi^gem_MonPlusLuckChanger^:S(NULL);


!?FU(OnGameEnter);      [block wog luck/morale combat bonuses]
!!re i/0/4;
  !!UN:C7725542/i/1/144;
!!en;

!?FU(gem_OnAfterArmySetNegativeMorale);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBX)/4/?(morale:y);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/?(oppArmy:y);

  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/-4/4/?(ownArmy:y);
  !!FU(gem_ArmyCompareTypeIteraror):P(ownArmy)/(MON_SUPREME_ARCHANGEL)/?(result:y);

  !!VR(moraleChanger:y):S0;
  !!if&(result:y);
    !!VRi^gem_MonPlusMoraleChanger^:S(MON_SUPREME_ARCHANGEL);
    !!VR(moraleChanger:y):+1;
  !!el;
    !!VRi^gem_MonPlusMoraleChanger^:S(NULL);
  !!en;


  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/20/4/?(oppArmy:y);

  !!if&(oppArmy:y);
    !!VR(currentDecrease:y):S0;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/?(bone:y); using native iterator value as bone/ghost dragon already there;
    !!VR(decrease:y):S0;
    !!if&(bone)<>7;
      !!VR(currentDecrease:y):S1;
    !!en;
    
    !!FU(gem_ArmyCompareTypeIteraror):P(oppArmy)/(MON_BLOOD_DRAGON)/?(result:y);
    !!if&(result);
      !!VR(minusMoralMonId:y):S(MON_BLOOD_DRAGON);
      !!VR(decrease:y):S2;
    !!el;
      !!FU(gem_ArmyCompareTypeIteraror):P(oppArmy)/(MON_DRACOLICH)/?(result:y);
      !!if&(result:y);
        !!VR(minusMoralMonId:y):S(MON_DRACOLICH);
        !!VR(decrease:y):S1;
      !!el;
        !!VR(minusMoralMonId:y):S(NULL);
      !!en;
    !!en;
    !!VRi^gem_MonMinusMoralePower^:S(decrease) F(currentDecrease)/(decrease);
    !!VRi^gem_MonMinusMoraleChanger^:S(minusMoralMonId);
    !!if&(decrease);
      !!VR(moraleChanger):-(decrease) +(currentDecrease);
    !!en;

  !!en;
  !!if&(moraleChanger:y);
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBX)/4/d(moraleChanger:y);
  !!en;
!?FU(gem_OnCreatureGhostDragonDescriptionCreate)&i^gem_MonMinusMoralePower^;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/?(dragonId:y);
!!if&(dragonId:y)=(NO_MON);
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/i^gem_MonMinusMoraleChanger^;
!!el;
  !!if&i^gem_MonMinusMoraleChanger^;
    !!VR(dragonId):Si^gem_MonMinusMoraleChanger^;
  !!en;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/(dragonId:y);
    !!VRi^gem_MonMinusMoraleChanger^:S(NULL);
    !!VR(power:y):Si^gem_MonMinusMoralePower^;
    !!VRi^gem_MonMinusMoralePower^:S(NULL);
    !!FU(gem_BufferEndingEditor):P6969512/(power);
!!en;


!?FU(gem_OnAfterArmySetNegativeLuck);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/20/4/?(oppArmy:y);

  !!FU(gem_ArmyCompareTypeIteraror):P(oppArmy)/(MON_HELL_BARON)/?(result:y);
  !!if&(result:y);
    !!VR(luckChanger:y):S-2;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/?(arch:y); using native iterator value as devil/archdevil already there;
    !!if&(arch:y)<>7;
      !!VR(luckChanger):+1;
    !!en;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/d(luckChanger:y); change luck by hostile creatures 
    !!VRi^gem_MonMinusLuckChanger^:S(MON_HELL_BARON);
  !!en;

!?FU(gem_OnAfterArmySetPositiveLuck);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/12/4/?(ownArmy:y);
  !!FU(gem_ArmyCompareTypeIteraror):P(ownArmy)/(MON_GHOST_BEHEMOTH)/?(result:y);
  *!IF:L^%^;

  !!if&(result);
    !!VR(luckChanger:y):S2;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/d(luckChanger:y); change luck by ally creatures
    !!VRi^gem_MonPlusLuckChanger^:S(MON_GHOST_BEHEMOTH);
    !!VRi^gem_MonPlusLuckPower^:S2;
  !!el;
    !!VRi^gem_MonPlusLuckChanger^:S(NULL);
    !!VRi^gem_MonPlusLuckPower^:S(NULL);
  !!en;

!?FU(gem_OnCreatureGetLuckLvl);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?(ownArmy:y);
  !!FU(gem_ArmyCompareTypeIteraror):P(ownArmy)/(MON_GHOST_BEHEMOTH)/?(result:y);
  !!if&(result);
    !!VR(luckChanger:y):S2;
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/d(luckChanger:y); change luck by ally creatures
    !!VRi^gem_MonPlusLuckChanger^:S(MON_GHOST_BEHEMOTH);
    !!VRi^gem_MonPlusLuckPower^:S2;
  !!el;
    !!VRi^gem_MonPlusLuckChanger^:S(NULL);
    !!VRi^gem_MonPlusLuckPower^:S(NULL);
  !!en;

!?FU(gem_ArmyCompareTypeIteraror);
!#VA(armyPtr:x) (monId:x) (result:x);
!!VR(result):S(NULL);
!!if&(armyPtr);
  !!re i/0/(ARMY_SLOT_LAST);
    !!VR(offset:y):Si *(SIZEOF_INT);
    !!UN:C(armyPtr)/(offset)/4/?t;
    !!if&t=(monId);
      !!VR(result):S(TRUE);
      !!br;
    !!en;
  !!en;
!!en;


// Magog's Fireball attack to indirect targets respecsts fire immunity (as in HotA)
// by Archer30
!?FU(gem_CreateERMHook);
!#VA(address:x);

!!SN:E(address)/1/4454655/(gem_OnCalcMonsterDamage);                      [trigger on calculating monster damage]

!?FU(gem_OnCalcMonsterDamage);
!#VA(address:x);

!!UN:C(address)/(STRUCT_HOOK_CONTEXT_EDI)/4/?(stackPtr:y);
!!UN:C(stackPtr)/244/4/?(side:y) C(stackPtr)/248/4/?(stackPerSide:y);
!!VR(stack:y):S(side) *(BATTLE_STACKS_PER_SIDE) +(stackPerSide);

; Exit if for some reaosn the stack ID is wrong
!!FU|(stack)<(BATTLE_STACK_FIRST)/(stack)>(BATTLE_STACK_LAST):E;
; Exit if the stack is the one being targeted
!!BG:E?(targetStack:y);
!!FU&(stack)=(targetStack):E;

; Check if the stack has fire immunity
!!BM(stack):F?(flags:y);
!!VR(isFireImmune:y):S(flags) &(MON_FLAG_FIRE_IMMUNITY);
!!FU&(isFireImmune)=(FALSE):E;

; Jump if the target has fire immunity
!!SN:X?(var:y)/0;
!!UN:C(address)/(STRUCT_HOOK_CONTEXT_RET)/4/4454786;


// Enable AI's Berserk casting
// by Archer30
; This script replaces 50% of AI's Fireball/Inferno/Meteor Shower casting to Berserk
; This script assumes that Berserk is a fire spell. AI will only cast Berserk when it has Advanced/Expert Fire Magic
; This script requires BG:E returns a valid stack to work
; This script checks the targeted stack and see if it can receive Berserk - may be improved to include the surroudning stacks and evalute whether casting Berserk is ideal
!?FU(OnBeforeBattleAction)&i^battle_ai_%i(battle_acting_side)^;
; Exit if it is not hero casting
!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_HERO_CAST):E;

; Exit if the hero does not learn Berserk
!!BG:H?(hero:y);
!!HE(hero):M(SPELL_BERSERK)/?(hasBerserk:y);
!!FU&(hasBerserk)<>(TRUE):E;

; Exit if the hero does not have Fire Magic level greater than Advanced
!!HE(hero):S(SKILL_FIRE_MAGIC)/?(spellLv:y);
!!TRi^battle_x^/i^battle_y^/i^battle_z^:G?(overlay:y);
!!VR(spellLv)|(overlay)=46/(overlay)=226:S(SKILL_EXPERT);
!!FU&(spellLv)<=(SKILL_BASIC):E;

; Now there is a chance to change the target spell to Berserk if it is casting Fireball/Inferno/Meteor Shower
!!BG:S?(spell:y);

!!if|(spell)=(SPELL_FIREBALL)/(spell)=(SPELL_INFERNO)/(spell)=(SPELL_METEOR_SHOWER);
  ; Check if the hero has sufficient mana to cast Berserk
  !!SS(spell):C(spellLv)/?(cost:y);
  !!SS(SPELL_BERSERK):C(spellLv)/?(newCost:y);

  !!HE(hero):I?(mana:y)/1;
  !!VR(newMana:y):S(mana) +(cost) -(newCost);

  !!if&(newMana)>0;
    ; Check if the target can receive Berserk (only the target but not the surrounding)
    !!BG:E?(stack:y);

    !!if&(stack)>(NO_STACK);            [The target must be alive]
      !!BM(stack):Z?(stackStruct:y);
      !!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
      !!SN:E5914512/(CALLCONV_THISCALL)/(cmbMgr)/(SPELL_BERSERK)/i^battle_acting_side^/(stackStruct)/1/1; [can stack apply buff/debuff]

      !!if&v1;
        ; Check if it is lucky enough to replace (50% chance)
        !!VR(random:y):R0/0/1;          [Customise the chance here]

        !!if&(random)=0;
          !!HE(hero):I(newMana)/1;
          !!BG:S(SPELL_BERSERK);
        !!en;
      !!en;
    !!en;
  !!en;
!!en;


!?FU(OnBattleRound_Quit);
// Bad Fix: Make sure the first acting stack is correct in the first round
// by Archer30
; Now we just disable it as the issue is better fixed from the root

; Many mod makers forget about giving speed on FU(OnBattleRound) won't change the first creature acting. 
; Ideally this script needs to be executed as late as possible to ensure overflow doesn't happen, like in a script with "-1000" as the prefix of filename
; It must be executed twice to avoid changing the orignal acting stack to another (if was right from the start)
*!FU(ActivateNextStack)&i^battle_round^=0:P P;


// Bad Fix: Fix final damage on the battlefield overflowing
// by Archer30
; Ideally this script needs to be executed as late as possible to ensure overflow doesn't happen, like in a script with "-1000" as the prefix of filename
!?FU(OnMonsterPhysicalDamage_Quit);
!!MF:F?(damage:y);

!!if&(damage)<0;
  !!MF:F(INT_MAX);
!!en;


// Bad Fix: Correct Dragon Heart's position to summon
// by Archer30
; Here we just recreate the summoning behaviour with the Summon Elemental way to avoid the wrong position to summon
; Discussion: http://wforum.heroes35.net/showthread.php?tid=4218&pid=138936#pid138936
!?FU(gem_CreateERMHook);
!!SN:Ex1/1/7764469/(gem_OnDragonHeartSummonDragons);

!?FU(gem_OnDragonHeartSummonDragons);
!#VA(hook:x);

; Get details for summon
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/-24/4/?(side:y) C(ebp)/-28/4/?(mon:y) C(ebp)/-12/4/?(num:y);

; Get the values from memory and set
!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(cmbMgr:y);
!!UN:C(cmbMgr)/78528/(UNC_INT)/?(origActiveSide:y) C(cmbMgr)/78528/(UNC_INT)/(side);

!!VR(summonedMonOffset:y):S(side) *(UNC_INT) +78504;
!!UN:C(cmbMgr)/(summonedMonOffset)/(UNC_INT)/?(origSummonedMon:y); [The monster summoned by Summon Elemental spell]

!!SS(SPELL_EARTH_ELEMENTAL):E0/?(origEff:y) E0/1;

; Summon
!!SN:E5927824/(CALLCONV_THISCALL)/(cmbMgr)/(SPELL_EARTH_ELEMENTAL)/(mon)/(num)/0;

; Restore values to the memory
!!UN:C(cmbMgr)/(summonedMonOffset)/(UNC_INT)/(origSummonedMon);
!!UN:C(cmbMgr)/78528/(UNC_INT)/(origActiveSide);

!!SS(SPELL_EARTH_ELEMENTAL):E0/(origEff:y);

; Skip the native summon
!!SN:X?t/0;
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/7764855;


// Fix wrong combat stack defence calculations from attacker
!?FU(OnGameEnter);
!!UN:C7722341/2/(OPCODE_NOP_2);

************************************************************************
************************************************************************
************************** ADVENTURE MAP FIXES *************************
************************************************************************
************************************************************************

// Enable the tier 2 dwellings for every town in random maps
!?FU(OnAfterErmInstructions);
  !!UN:C(GAME_MANAGER)/(UNC_INT)/?(gameMgr:y);
  !!UN:C(gameMgr)/128980/1/?(mapType:y);[114 [r]andom_maps)]

  !!if&(mapType)=114;
    !!UN:U(OBJ_TOWN)/(ANY_OBJ)/?(townsAmount:y);
    !!UN:U(OBJ_RANDOM_TOWN)/(ANY_OBJ)/?(randomTownsAmount:y);
    !!VR(townsAmount)&(randomTownsAmount):+(randomTownsAmount);

    !!re i/(MAP_TOWN_FIRST)/(townsAmount)/1/-1;
      !!FU(Town_CanBuildingBuilt):Pi/31/?(canBuild:y);
      !!CA0/i&(canBuild):B6/31;
    !!en;
  !!en;


// Fix hero scouting after closing hero screen with new arts equipped // see gem_fixes.erm
!?FU(OnAfterHeroInteraction);
!!FU(gem_CalculateScoutingRadiousForAllHeroes):P;

!?FU(OnCloseHeroScreen);
!!FU(gem_CalculateScoutingRadiousForAllHeroes):P;

!?FU(gem_CalculateScoutingRadiousForAllHeroes);
  !!OW:Cd/?(clickedPlayer:y);

  !!if&(clickedPlayer)=i^timerOwner^;
    !!FU(gem_Player_GetActiveHeroesList):P(clickedPlayer)/?(herArray:y);

    !!if&(herArray)<>0;
      !!FU(gem_UpdateScoutingRange):Pd/(herArray);
    !!en;

  !!en;


// Fix Hd mod clicks outside Swap Mgr
!?FU(OnHeroesMeetScreenMouseClick)|i^mouse_action^=(MOUSE_LMB_PRESSED)/i^mouse_action^=(MOUSE_RMB_PRESSED);
  !!FU(H3Dlg_GetCurrentDlg):P?(currentDlg:y);

  !!UN:C(currentDlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(dlgWidth:y);
  !!UN:C(currentDlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(dlgHeight:y);

  !!if|i^mouse_x^<0/i^mouse_y^<0/i^mouse_x^>(dlgWidth)/i^mouse_y^>(dlgHeight);
    !!CM:R0;
  !!en;


// Bad fix: Fix occasionally a neutral stack with invalid quantity is put on the map. These stacks would be removed from the map here.
// by Archer30
!?FU(OnEveryDay)&i^timerOnce^;
; 904 - Disable Erm error report
; 905 - Option for checking whethere there was an error report generated
!!UN:P904/(TRUE) P905/(FALSE);

!!VR(x:y):S-1;

!!re i;
  !!UN:U(OBJ_MONSTER)/(ANY_OBJ)/-1/(x)/(y:y)/(z:y);
  !!br&(x)<0;

  !!MO(x)/(y)/(z):G?(qty:y);
  !!UN:P905/?(hasError:y);

  !!if|(qty)=4095/(hasError);           [4095 is the magic number]
    !!UN:P905/(FALSE);
    !!UN:O(x)/(y)/(z)/1;                [Debug msg can be added here to help collect debug info from players]

  !!el&(qty)<=0;
    !!MO(x)/(y)/(z):G1;
  !!en;
!!en;

!!UN:P904/(FALSE) P905/(FALSE);


// Fix a bug where the hero could fight himself/herself with spacebar pressing when flying over the entrance of an enemy's town.
// by Archer30
!?FU(OnKeyPressed_AdvMap)&i^key^=(KEY_SPACE);
!#VA(key:x) (preventDefault:x);

; Check if there is a hero active
!!OW:Ai^timerOwner^/?(hero:y);

!!if&(hero)>(NO_HERO);
  ; Check if the hero's current location is the entrance of a town
  !!HE(hero):P?(x:y)/?(y:y)/?(z:y);
  !!UN:P904/(TRUE) P905/(FALSE);        [904 - option for disabling erm error report. 905 - option for checking whether there is an erm error]
  !!CA(x)/(y)/(z):P?(townX:y)/?(townY:y)/?(townZ:y);
  !!UN:P905/?(hasError:y);

  !!if&(hasError)<>(TRUE)/(x)=(townX)/(y)=(townY)/(z)=(townZ);
    ; Check if the hero and the town belongs to different team
    !!CA(x)/(y)/(z):O?(townOwner:y);

    !!if&(townOwner)=(NO_OWNER);
      ; Prevent default action (battle initialization) if the town belongs to no one
      !!VR(preventDefault):S(TRUE);
    !!el&i^timerOwner^<>(townOwner);
      !!OW:Ti^timerOwner^/?(timerTeam:y) T(townOwner)/?(townTeam:y);

      ; Prevent default action (battle initialization) if the hero and the town are in different teams
      !!VR(preventDefault)&(timerTeam)<>(townTeam):S(TRUE);
    !!en;
  ; Reset option 905 if we got an error (a.k.a. the hero's current location is not a town)
  !!el;
    !!UN:P905/(FALSE);
  !!en;

  ; Reset option 904 in any case
  !!UN:P904/(FALSE);
!!en;


// Added the text of Keymaster's Tent visiting status when hovering over/right-clicing on Border Gates/Guards
// by Archer30
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!SN:E(setHook)/1/4240003/(gem_OnBorderGatesHover); [Hint]
!!SN:E(setHook)/1/4275108/(gem_OnBorderGatesRightClick); [Right-click]

; Hiint
!?FU(gem_OnBorderGatesHover);
!#VA(hook:x);

; Check if Keymaster's Tent visited
!!FU(gem_Border_CheckIfTentVisited):P(hook)/?(result:y);

; Set up new text depending on the status
!!SN:B6911016/d/?(text:z);

!!if&(result)=0;
  !!VR(text):+^ %T(gem.map.keymastersTent0)^;
!!el;
  !!VR(text):+^ %T(gem.map.keymastersTent1)^;
!!en;

!!SN:B6911016/d/(text);

; Right-click
!?FU(gem_OnBorderGatesRightClick);
!#VA(hook:x);

; Check if Keymaster's Tent visited
!!FU(gem_Border_CheckIfTentVisited):P(hook)/?(result:y);

; Set up new text depending on the status
!!SN:B6911016/d/?(text:z);

!!if&(result)=0;
  !!VR(text):+^

%T(gem.map.keymastersTent0)^;
!!el;
  !!VR(text):+^

%T(gem.map.keymastersTent1)^;
!!en;

!!SN:B6911016/d/(text);

!?FU(gem_Border_CheckIfTentVisited);
!#VA(hook:x) (result:x);

; Get the subtype
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBX)/4/?(objStruct:y);
!!UN:C(objStruct)/34/2/?(subtype:y); [dword]

; Check if it is visited
!!UN:C(GAME_MANAGER)/4/?(gameMgr:y);
!!VR(offset:y):S(subtype) +320356;
!!UN:C(gameMgr)/(offset)/1/?(value1:y);
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y);
!!UN:C(ebp)/-20/4/?(value2:y);
!!VR(result):S(value2) &(value1);

; Unused implementation
; This implementation is text free - using the not visited/visited text from the game
; I felt it wrong using the original text becasue it usually indicates the status of the object itself (instead of the keymaster's tent)
!?FU(OnGameEnter);
!!FU:E;

!!UN:C4275108/4/2425366507;
!!UN:C4275112/1/(OPCODE_NOP_1);

!!UN:C4240003/4/2425366507;
!!UN:C4240007/1/(OPCODE_NOP_1);


** Fix of the heroes and towns reordering
!?FU(OnAdventureMapLeftMouseClick)&999/i^mouse_action^=(MOUSE_LMB_PRESSED);/i^WOG_IsHdMod^=(TRUE);
  !!UN:J8/1/^wog scripts.pac^;  // if wog scripts mod is loaded

  !!if&-(TRUE);
    !!if&i^mouse_item^>39/i^mouse_item^<=43:;  heroes listing
      
      !!VR(itemID:y):Si^mouse_item^-39; 
      
      !!if&i^key_alt^;
        !#VA(hero[8]:y);
        !!OW:O(CURRENT_PLAYER)/?(hrOnMap:y)/?(hero[0])/?(hero[1])/?(hero[2])/?(hero[3])/?(hero[4])/?(hero[5])/?(hero[6])/?(hero[7]);
        !!OW:O(CURRENT_PLAYER)/(itemID)/?(clickHero:y);

        !!if&(clickHero)<>(NO_HERO);
          !!re i/0/(hrOnMap)/1/-1;
            !!if&(hero[i])=(clickHero);
              !!VR(hero[i]):S(hero[0]);
              !!VR(hero[0]):S(clickHero);
              !!OW:O(CURRENT_PLAYER)/(hrOnMap)/(hero[0])/(hero[1])/(hero[2])/(hero[3])/(hero[4])/(hero[5])/(hero[6])/(hero[7]);
              !!CM:R0;
              !!UN:R1;
              !!br;
            !!en;
          !!en;
        !!en;

        !!FU:E;
      !!en;

      !!if&i^key_shift^;
        !!OW:O(CURRENT_PLAYER)/1/(itemID)/0;
        !!CM:R0;
        !!UN:R1;
        !!FU:E;
      !!en;

    !!el&i^mouse_item^>32/i^mouse_item^<=36;
      !!VR(itemID:y):Si^mouse_item^-32; 

      !!if&i^key_alt^;
        !!OW:W(CURRENT_PLAYER)/?(townsOnMap:y) N(CURRENT_PLAYER)/(itemID)/?(clickTown:y);

        !!re i/0/(townsOnMap)/1/-1;
          !!OW:W(CURRENT_PLAYER)/i/?(townId:y);

          !!if&(clickTown)=(townId);
            !!OW:W(CURRENT_PLAYER)/0/?(firstTownId:y) W(CURRENT_PLAYER)/0/(townId) W(CURRENT_PLAYER)/i/(firstTownId);
            !!CM:R0;
            !!UN:R1;
            !!br;
          !!en;
        !!en;

        !!FU:E;
      !!en;

      !!if&i^key_shift^;
        !!OW:N(CURRENT_PLAYER)/1/(itemID)/0;
        !!CM:R0;
        !!UN:R1;
      !!en;
    !!en;
  !!en;


  *** Instant Reveal Scouting Radius

!$OB81;                                         // Trigger after visiting Scolar
!!FU(gem_UpdateScoutingRange):P(CURRENT_HERO);

!$OB104;                                        // Trigger after visiting University
!!FU(gem_UpdateScoutingRange):P(CURRENT_HERO);

!$OB113;                                        // Trigger after visiting Witch Hut
!!FU(gem_UpdateScoutingRange):P(CURRENT_HERO);

!$OB5/(ART_SPECULUM);                           // Trigger after visiting Speculum
!!FU(gem_UpdateScoutingRange):P(CURRENT_HERO);

!$OB5/(ART_SPYGLASS);                           // Trigger after visiting Spyglass
!!FU(gem_UpdateScoutingRange):P(CURRENT_HERO);

!?FU(OnAfterHeroGainLevel);                     // Trigger after lvl-up
!!FU(gem_UpdateScoutingRange):P(CURRENT_HERO);

!?FU(OnEveryDay)&i^timerDay^=1/i^timerOnce^;    // Trigger after game starts
!!re i/(HERO_FIRST)/(HERO_LAST_WOG);            // For each hero
  !!FU(gem_UpdateScoutingRange):Pi;
!!en;

  ** End of Script **


** Reduce heros' max walking speed on "Replay Opponent Turn"
; This restrains the max walking speed on replay as usually when you replay, you missed something and you want to watch carefully
!?FU(OnGameEnter);
!!UN:C4838745/1/3;                      [original: 4]
!!UN:C4838760/4/3;

************************************************************************
************************************************************************
**************************** COMMANDER FIXES ***************************
************************************************************************
************************************************************************

; Fixed losing Double Strike/Strike all around after the commander learns shooting with igrik's ChooseAttack plugin
; Ideally this should be fixed in the plugin
; by Archer30
!?FU(OnBeforeBattleAction);
!!SN:F^PluginExists^/^ChooseAttack^;
!!FU&v1<>(TRUE):E;

!!BG:A?(action:y);
!!FU&(action)<>(BATTLE_ACTION_WALK_AND_ATTACK):E;

!!BMi^battle_acting_stack^:T?(type:y);

!!if&(type)>=(MON_PALADIN_A)/(type)<=(MON_ASTRAL_SPIRIT_D);
  !!BMi^battle_acting_stack^:F?(flags:y) Fd~(MON_FLAG_SHOOTER);
  !!VRi^gem_NPC_canShoot^:S(flags) &(MON_FLAG_SHOOTER);
!!en;

!?FU(OnBattleActionEnd)&i^gem_NPC_canShoot^;
; Double check the creature type
!!BMi^battle_acting_stack^:T?(type:y);

!!if&(type)>=(MON_PALADIN_A)/(type)<=(MON_ASTRAL_SPIRIT_D);
  !!BMi^battle_acting_stack^:Fd|(MON_FLAG_SHOOTER);
!!en;

!!VRi^gem_NPC_canShoot^:S(FALSE);

!?FU(gem_CreateERMHook);
  // Removing message about deacreasing army before combat and placing
  // them into combat log
  !!SN:Ex1/1/7786558/(gem_OnAstralAttackMessage);
  !!SN:Ex1/1/7787216/(gem_OnAstralDefendMessage);
  !!SN:Ex1/1/7772772/(gem_OnBruteGoldBonusMessage);

  // ART_SLAVAS_RING_OF_POWER's fixes
  !!SN:Ex1/1/7782812/(gem_OnNPCBattleStackInit);
  !!SN:Ex1/1/7771289/(gem_OnNPCGetRingBonus);
  !!UN:C7771553/-1/1/1;                 [Change the number to check the skill level at 0x76959C cmp     dword ptr [eax+edx*4+38h], 2 / jg      short loc_7695E3]
  *!SN:Ex1/1/7779070/(gem_OnNPCBattleDescriptionGet);


!?FU(gem_OnBruteGoldBonusMessage); // replace brute message with adv map dlg info panel message
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/?(strPtr:y) Cx1/(STRUCT_HOOK_CONTEXT_EBP)/4/?(ebp:y) C(ebp)/-64/4/?(gold:y);
  !!UN:C(ADV_MANAGER)/4/?(advMgr:y);
  !!FU(GetTextTableString):P^znpc00^/175/1/?(npcMes:z);
  !!SN:E4284352/(CALLCONV_THISCALL)/(advMgr)/(npcMes:z)/(RES_GOLD)/(gold); [show message]
  !!SN:X?y99/0;
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/7772811;                            [return to stack end]

!?FU(gem_OnAstralAttackMessage);
  !!SN:X?y99/0;
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/7786697;
  !!FU(gem_PreapareNpcMessage):P(BATTLE_RIGHT);

!?FU(gem_OnAstralDefendMessage);
  !!SN:X?y99/0;
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/7787355;
  !!FU(gem_PreapareNpcMessage):P(BATTLE_LEFT);

!?FU(gem_PreapareNpcMessage);
!#VA(side:x) (localStr:z);
  !!VRo:S(side) *56;                        [weird offset btw - 14 intead of 7]

  !!re i/0/(ARMY_SLOT_LAST);                [iterate all army slots]
    !!UN:C42338576/o/4/?t C42338604/o/4/?n; [take stolen army types and numbers]
    !!if&n;
      !!VRs:Sn -1 B;
      !!SN:H^monname^/t/s/?(monName:z) T^gem.battle.astralCustomText^/?(add:z)/^monNum^/n/^monName^/(monName:z);
      !!VR(localStr:z):+(add:z);
    !!en;
    !!VRo:+4;
  !!en;

  !!SN:K(localStr:z)/?(size:y);d-2;
  !!if&(size)>2;
    !!VR(size):-2;
    !!FU(Substr):P(localStr)/0/(size)/?(localStr);
    !!VR(localStr):+^%T(gem.period)^;
    !!VRs^gem_NPC_DecreeasesArmyMessage%(side)^:S(localStr:z);+^%n %(monName:z), ^;
    !!VRi^gem_NPC_DecreeasesArmyMessage%(side)^:S(TRUE);
  !!en;
!?FU(OnCombatRound)&i^battle_isVisible^/v997=0;
*!IF:L^%i(battle_humanOnly) %i(battle_isQuick)^;

  !!re i/1/0/-1;/(BATTLE_RIGHT);
    !!if&i^gem_NPC_DecreeasesArmyMessage%i^;
      *!VR(hint:z):S^%T(gem.endl)^;     [Archer30: The script works without new line and looks nicer in battle log dlg]
      *!MM:S(hint:z);

      !!SN:T^gem.battle.armyDecrease%i^/?(head:z);
      !!MM:S(head:z);
      !!VR(hint:z):Ss^gem_NPC_DecreeasesArmyMessage%i^;
      !!MM:S(hint:z);
    !!en;
  !!en;

!?FU(OnAfterBattleUniversal);
!!SN:W^gem_NPC_DecreeasesArmyMessage0^ W^gem_NPC_DecreeasesArmyMessage1^;:S(FALSE);




!?FU(gem_OnNPCGetRingBonus);
!!if&x1;
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/?(npc:y) Cx1/(STRUCT_HOOK_CONTEXT_EAX)/4/?(skillIndex:y); [получаем указатель на NPC и индекс проверяемого навыка]

  !!VR(skillLevelPtr:y):S(skillIndex) *(SIZEOF_DWORD) +(npc) +56;                                [we get a pointer to the value of the skill being checked]

  !!UN:C(skillLevelPtr)/4/?(skillLevel:y);                                                       [get skill value]
  !!if&(skillLevel)<2;                                                                           [if less than 2]
    !!SN:E7791165/(CALLCONV_THISCALL)/(npc)/(ART_SLAVAS_RING_OF_POWER);                          [check if NPC has a ring]
    !!if&v1;                                                                                     [if there is]
      !!SN:X?y99/0;
      !!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/7771478; [jumping directly to the calculation of bonuses from the ring, bypassing the addition of standard bonuses]
    !!en;
  !!en;
!!en;


!?FU(gem_OnNPCBattleDescriptionGet);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/1/?(skillLevel:y);                 [get skill value]
  !!if&(skillLevel)<2;                                                  [if less than 2]
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_ECX)/4/?(npc:y);
    !!SN:E7791165/(CALLCONV_THISCALL)/(npc)/(ART_SLAVAS_RING_OF_POWER); [check if NPC has a ring]
    !!if&v1;                                                            [if there is]
      !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/1/2;                           [set skill cast value as at advanced skill lvl]
    !!en;
  !!en;

!?FU(gem_OnNPCBattleStackInit);
  !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/1/?(skillLevel:y);                 [get skill value]
  !!if&(skillLevel)<2;                                                  [if less than 2]
    !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EDX)/4/?(npc:y);
    !!SN:E7791165/(CALLCONV_THISCALL)/(npc)/(ART_SLAVAS_RING_OF_POWER); [check if NPC has a ring]
    !!if&v1;                                                            [if there is]
      !!UN:Cx1/(STRUCT_HOOK_CONTEXT_EAX)/1/2;                           [set skill cast value as at advanced skill lvl]
    !!en;
  !!en;


// Fix Brute's Gold bonus overflowing
// by Berserker
!?FU(gem_CreateERMHook);
!!SN:Ex1/1/7772754/(gem_Brute_AddGold);

!?FU(gem_Brute_AddGold);
!!SN:X?(hook:y);
!!UN:C(hook)/(STRUCT_HOOK_CONTEXT_EBP)/(UNC_UINT32)/?(ebp:y);
!!UN:C(ebp)/-64/(UNC_INT32)/?(bruteGold:y);
!!UN:C(ebp)/-68/(UNC_INT32)/?(playerGold:y);

; Fix calculated Brute gold bonus overflow
!!VR(bruteGold)&(bruteGold)<0:S(INT_MAX);
!!FU(gem_Brute_SafeAdd):P(playerGold)/(bruteGold)/?(finalGold:y);
!!VR(playerGold):S(finalGold) -(bruteGold);
!!UN:C(ebp)/-64/(UNC_INT32)/(bruteGold);
!!UN:C(ebp)/-68/(UNC_INT32)/(playerGold);

!?FU(gem_Brute_SafeAdd);
!#VA(value1:x);
!#VA(value2:x);
!#VA(result:x);

!!VR(result):S(value1) +(value2);
!!VR(sign1:y):S1;
!!VR(sign1)&(value1)<0:S-1;
!!VR(sign2:y):S1;
!!VR(sign2)&(value2)<0:S-1;

!!if&(sign1)=(sign2);
  !!VR(sign3:y):S1;
  !!VR(sign3)&(result)<0:S-1;

  ; Overflow changed result sign
  !!if&(sign1)<>(sign3);
    !!VR(result)&(sign1)<0:S(INT_MIN);
    !!VR(result)&(sign1)>=0:S(INT_MAX);
  !!en;
!!en;


// Fix occasionally commanders receiving incorrect exp with when transfering between campaign zones
// by Archer30
; This happens in SoD scenarios - Commanders' exp are reset to 0

!?FU(OnTransferHero);
  !#VA(hero:x);

  !!UN:P(WOG_OPT_DISABLE_COMMANDERS)/?(cmdDisabled:y);
  !!FU&(cmdDisabled):E;

  !!CO(hero):X1/?i^gem_cmdExp_%(hero)^;

!?FU(OnAfterErmInstructions);
  !!UN:P(WOG_OPT_DISABLE_COMMANDERS)/?(cmdDisabled:y);
  !!FU&(cmdDisabled):E;

  !!SN:F^IsCampaign^;
  !!FU&v1<>(TRUE):E;

  !!re i/(HERO_FIRST)/(HERO_LAST_WOG);
    !!co&i^gem_cmdExp_%i^=0;

    !!COi:X1/i^gem_cmdExp_%i^;
    !!VRi^gem_cmdExp_%i^:S0;
  !!en;

************************************************************************
************************************************************************
******************************* LUCK FIXES *****************************
************************************************************************
************************************************************************

!?FU(OnBeforeCombatLuckEvent);
!#VA(stackId:x) (stackLuck:x) (luckLimit:x) (isRange:x) (maxChance:x) (damageMultiplier:x);

!?FU(gem_CreateERMHook);
!!SN:Ex1/1/4461853/(gem_CheckMeleeNegativeLuck);
!!SN:Ex1/1/4453947/(gem_CheckRangeNegativeLuck);

!?FU(gem_CheckMeleeNegativeLuck);
!!SN:X?y99/0;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/4461866;                                                 [Jump over hero check]
!!FU(gem_CheckNegativeLuck):Px1;

!?FU(gem_CheckRangeNegativeLuck);
!!SN:X?y99/0;
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_RET)/4/4453960;                                                 [Jump over hero check]
!!FU(gem_CheckNegativeLuck):Px1;

!?FU(gem_CheckNegativeLuck);
!!UN:Cx1/(STRUCT_HOOK_CONTEXT_ESI)/4/?(currentStackPtr:y) C(currentStackPtr)/1260/4/?(luck:y); 
!!UN:C(currentStackPtr)/248/4/?(currentStack:y) C(currentStackPtr)/244/4/?(side:y);

!!VR(currentStack)&(side): +(BATTLE_STACKS_PER_SIDE);                                         [For right side]

!!if&(luck)<0;
  !!UN:C4605324/1/?(maxBadLuck:y);                                                            [Read max value from bad morale and use it for misfortune]
  !!VR(maxBadLuck)&(maxBadLuck:y)<0: *-1;                                                             
  !!VR(luck):*-1 F1/(maxBadLuck);
  !!VR(rand:y):R0/1/12;
  !!if&(rand)<=(luck);
    !!UN:C(currentStackPtr)/112/4/-1;                                                         [set stack atrr "isLucky" to -1]
    !!BA:Q?(isQuick:y);
    !!if&(isQuick)=0;
      !!FU(GetTextFileString):P^genrltxt^/45/?(str:z);
      !!BM(currentStack):T?t N?n;
      !!VRn:-1 F0/1;
      !!SN:H^monname^/t/n/?(name:z);
      !!SN:E6388190/(CALLCONV_CDECL)/?(varStr:z)/(str:z)/(name);                              [Replace %s in str with name and put result into varStr]
      !!MM:S(varStr:z);
      !!SN:P^BADLUCK^;
      !!BM(currentStack):V48;
    !!en;
  !!en;
!!en;

!?FU(OnStackToStackDamage_Quit)&x9=0;                                                         [(x1 - atck stack, x2 - def stack, x4 - final dmg)]
!!BMx1:Z?(structure:y);
!!UN:C(structure)/112/4/?(isLucky:y);

!!if&(isLucky)=-1;
  !!VRx4:Sd>>1;                                                                               [decrease base damage]
  !!UN:C(structure)/112/4/(NULL);                                                             [reset luck flag]
!!en;

************************************************************************
************************************************************************
*************************** CAMPAIGN FIXES *****************************
************************************************************************
************************************************************************

// Fix Griffin Cliff (from Long Live the Queen) not winning after capturing all the 7 Griffin Towers
// by Archer30
; Ideally, we should also change the text of "Capturing all the dwellings" to "Capturing all the Griffin Towers" as it's possibly that we haven't capture some other dwellings
!?FU(gem_CreateERMHook);
!#VA(setHook:x);

!!SN:F^IsCampaign^;
!!FU&v1<>(TRUE):E;

!!SN:F^GetCampaignFileName^/?(campaignFileName:z);
!!SN:E6448768/(CALLCONV_CDECL)/(campaignFileName)/^Good1.h3c^/4; [Compare string (case-insensitively)]
!!FU&v1:E;                              [If the filename is the same, it returns 0]

!!SN:F^GetCampaignMapInd^;
!!FU&v1<>2:E;

; It's Griffin Cliff from Long Live the Queen
; Set hook at checking owenrs of all the dwellings to decide whether it's a victory
!!SN:E(setHook)/1/6236710/(gem_OnCheckDwellingOwners); 005F2A26

!?FU(gem_OnCheckDwellingOwners);
!#VA(hook:x);

!!VR(x:y):S-1;

!!re i;
  !!UN:U(OBJ_CREATURE_GENERATOR_1)/25/-1/(x)/(y:y)/(z:y); [25 - Griffin Tower]
  !!br&(x)<0;

  !!DW(x)/(y)/(z):O?(player:y);
  !!br&(player)<>i^timerOwner^;
!!en;

!!SN:X?t/0;

; If the search was performed without interuption, meaning every Griffin tower is captured by the current player, return TRUE
!!if&(x)=-1;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/6236822; 5F2A96
; Otherwise return FALSE
!!el;
  !!UN:C(hook)/(STRUCT_HOOK_CONTEXT_RET)/4/6236846; 5F2AAE
!!en;

************************************************************************
************************************************************************
****************************** FUNCTIONS *******************************
************************************************************************
************************************************************************
