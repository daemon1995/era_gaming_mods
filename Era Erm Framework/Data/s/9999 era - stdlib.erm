ZVSE2
; ========== EVENTS ==========
; Temporary stack to hold events chain saved data
!#SN:M(M_AUTO_ID)/0/(M_INT)/(M_TEMP)/?i^savedEventData^;
!#VRi^savedEventDataPos^:S0;

!?FU(ClearEventChainData);
!!SN:Mi^savedEventData^/0;
!!VRi^savedEventDataPos^:S0;

!?FU(SaveEventData);
; Saves all passed integer arguments in event data storage. You MUST restore the same number of arguments
; in the same order by calling RestoreEventData function in the same event.
!#VA(firstArg:x); ... Integer arguments to save

!!FU:A?(numArgs:y);
!!FU&(numArgs)<=0:E;

!!VR(allocSpace:y):S(numArgs) +1;
!!VR(savedEventData:y):Si^savedEventData^;
!!SN:M(savedEventData)/?(listSize:y);
!!VR(eventDataPos:y):Si^savedEventDataPos^;
!!VR(finalEventDataPos:y):S(eventDataPos) +(allocSpace);
!!VRi^savedEventDataPos^:S(finalEventDataPos);
!!SN&(finalEventDataPos)>(listSize):M(savedEventData)/(finalEventDataPos);

!!VR(argPtr:y):S(@firstArg);

!!re i/1/(numArgs);
  !!SN:V(savedEventData)/(eventDataPos)/x(argPtr);
  !!VR(eventDataPos):+1;
  !!VR(argPtr):+1;
!!en;

!!SN:V(savedEventData)/(eventDataPos)/(numArgs);
!!VR(eventDataPos):+1;

!?FU(RestoreEventData);
; Restores previously saved arguments from event data storage. They same number of arguments in the same order MUST HAVE BEEN
; saved in the same event previously using SaveEventData function.
!#VA(firstArg:x); ... Integer arguments to restore using ?$ syntax

!!FU:A?(numArgs:y);
!!FU&(numArgs)<=0:E;

!!VR(dataSpace:y):S(numArgs) +1;
!!VR(savedEventData:y):Si^savedEventData^;
!!SN:M(savedEventData)/?(listSize:y);

!!if&(listSize)<(dataSpace);
  !!SN:F^ShowErmError^/^Invalid number of arguments for RestoreEventData. Asked to restore %(numArgs) arguments from buffer of size %(listSize)^;
  !!FU(ClearEventChainData):P;
  !!SN:Q;
!!en;

!!SN:V(savedEventData)/-1/?(savedNumArgs:y);

!!if&(listSize)<(dataSpace);
  !!SN:F^ShowErmError^/^Invalid number of arguments for RestoreEventData. Asked to restore %(numArgs) arguments, while %(listSize)^;
  !!FU(ClearEventChainData):P;
  !!SN:Q;
!!en;

!!VR(eventDataPos:y):Si^savedEventDataPos^ -(dataSpace);
!!VRi^savedEventDataPos^:-(dataSpace);

!!VR(argPtr:y):S(@firstArg);

!!re i/1/(numArgs);
  !!SN:V(savedEventData)/(eventDataPos)/?x(argPtr);
  !!VR(eventDataPos):+1;
  !!VR(argPtr):+1;
!!en;

!?FU(SavePrevKeyModsState);
!!FU(SaveEventData):Pi^key^/i^key_down^/i^key_leftAlt^/i^key_rightAlt^/i^key_alt^/i^key_leftCtrl^/i^key_rightCtrl^/i^key_ctrl^/i^key_leftShift^/i^key_rightShift^/i^key_shift^;

!?FU(RestorePrevKeyModsState);
!!FU(RestoreEventData):P?i^key^/?i^key_down^/?i^key_leftAlt^/?i^key_rightAlt^/?i^key_alt^/?i^key_leftCtrl^/?i^key_rightCtrl^/?i^key_ctrl^/?i^key_leftShift^/?i^key_rightShift^/?i^key_shift^;

!?FU(GetKeyModsState);
!!SN:F^GetKeyState^/(KEY_LMENU);
!!VR(leftKeyPressed:y):Sv1 Sd>>7 &1;
!!VRi^key_leftAlt^:S(leftKeyPressed);

!!SN:F^GetKeyState^/(KEY_RMENU);
!!VR(rightKeyPressed:y):Sv1 Sd>>7 &1;
!!VRi^key_rightAlt^:S(rightKeyPressed);

!!VRi^key_alt^:S(leftKeyPressed) |(rightKeyPressed);

!!SN:F^GetKeyState^/(KEY_LCONTROL);
!!VR(leftKeyPressed:y):Sv1 Sd>>7 &1;
!!VRi^key_leftCtrl^:S(leftKeyPressed);

!!SN:F^GetKeyState^/(KEY_RCONTROL);
!!VR(rightKeyPressed:y):Sv1 Sd>>7 &1;
!!VRi^key_rightCtrl^:S(rightKeyPressed);

!!VRi^key_ctrl^:S(leftKeyPressed) |(rightKeyPressed);

!!SN:F^GetKeyState^/(KEY_LSHIFT);
!!VR(leftKeyPressed:y):Sv1 Sd>>7 &1;
!!VRi^key_leftShift^:S(leftKeyPressed);

!!SN:F^GetKeyState^/(KEY_RSHIFT);
!!VR(rightKeyPressed:y):Sv1 Sd>>7 &1;
!!VRi^key_rightShift^:S(rightKeyPressed);

!!VRi^key_shift^:S(leftKeyPressed) |(rightKeyPressed);

!?FU(CollectMouseEventData);
!!CM:A?i^mouse_x^/?i^mouse_y^ D?i^mouse_battleHex^ F?i^mouse_flags^ H?i^mouse_hero_0^/?i^mouse_hero_1^ I?i^mouse_item^ P?i^mouse_mapX^/?i^mouse_mapY^/?i^mouse_mapZ^
     S?i^mouse_action^ T?i^dlg_action^;

; Replace tricky MOUSE_EXIT_BTN_LMB_RELEASED action with regular MOUSE_LMB_RELEASED action
!!VRi^mouse_action^&i^mouse_action^=(MOUSE_EXIT_BTN_LMB_RELEASED):S(MOUSE_LMB_RELEASED);

; Handle keyboard event for custom dialogs
!!VRi^mouse_action^&i^dlg_action^=(DLG_ACTION_KEY_PRESSED):S?i^key^ S0;

!?FU(SavePrevMouseEventData);
!!FU(SaveEventData):Pi^mouse_x^/i^mouse_y^/i^mouse_battleHex^/i^mouse_flags^/i^mouse_hero_0^/i^mouse_item^/i^mouse_mapX^/i^mouse_mapY^/i^mouse_mapZ^/i^mouse_action^;

!?FU(RestorePrevMouseEventData);
!!FU(RestoreEventData):P?i^mouse_x^/?i^mouse_y^/?i^mouse_battleHex^/?i^mouse_flags^/?i^mouse_hero_0^/?i^mouse_item^/?i^mouse_mapX^/?i^mouse_mapY^/?i^mouse_mapZ^/?i^mouse_action^;

!?FU(OnSavegameRead);
!!FU(ClearEventChainData):P;

!?FU(OnKeyPressed);
!#VA(key:x) (preventDefault:x) (isDown:x);
!!FU(SavePrevKeyModsState):P;

!!VRi^key^:S(key);
!!VRi^key_down^:S(isDown);

!!FU(GetKeyModsState):P;

!?FU(OnKeyReleased);
!#VA(key:x) (preventDefault:x);
!!FU(SavePrevKeyModsState):P;

!!VRi^key^:S(key);

!!FU(GetKeyModsState):P;

!?FU(EnterMouseEvent);
!!FU(SavePrevKeyModsState):P;
!!FU(SavePrevMouseEventData):P;
!!FU(GetKeyModsState):P;
!!FU(CollectMouseEventData):P;

!?FU(LeaveMouseEvent);
!!FU(RestorePrevMouseEventData):P;
!!FU(RestorePrevKeyModsState):P;

!?FU(OnAdventureMapRightMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnTownMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnHeroScreenMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnHeroesMeetScreenMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnBattleScreenMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnAdventureMapLeftMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnRecruitDlgMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnTownHallMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnKingdomOverviewMouseClick);
!!FU(EnterMouseEvent):P;

!?FU(OnBattleMouseHint);
!!FU(EnterMouseEvent):P;

!?FU(OnTownMouseHint);
!!FU(EnterMouseEvent):P;

!?FU(OnCustomDialogEvent);
!#VA(dlgId:x);
!!FU(EnterMouseEvent):P;
!!FU(SaveEventData):Pi^dlg_id^;
!!VRi^dlg_id^:S(dlgId);

!?FU(OnAfterErmInstructions);
!!VRi^era_everyDayTimerLastDay^:S-1;

; Extended OnEveryDay trigger. The following global variables are automatically set:
; - i^timerDay^:        1..+inf
; - i^timerWeekDay^:    1..7
; - i^timerMonthDay^:   1..28
; - i^timerWeek^:       1..+inf
; - i^timerMonthWeek^:  1..4
; - i^timerMonth^:      1..+inf
; - i^timerOnce^:       0..1
; - i^timerOwner^:      0..7
; - i^timerIsAi^:       0..1
; - i^timerIsHuman^:    0..1
!?FU(OnEveryDay);
!#VA(day:x) (weekDay:x) (once:x) (owner:x) (isAi:x);

!!OW:C?(owner) I(owner)/?(isAi);
!!VR(day):Sc;
!!VR(weekDay):S(day) -1 %7 +1;

!!VR(lastTimerDay:y):Si^era_everyDayTimerLastDay^;
!!VRi^era_everyDayTimerLastDay^:S(day);
!!VR(once):S(FALSE);
!!VR(once)&(lastTimerDay)<>(day):S(TRUE);

!!VRi^timerDay^:S(day);
!!VRi^timerWeekDay^:S(weekDay);
!!VRi^timerMonthDay^:S(day) -1 %(DAYS_IN_MONTH) +1;
!!VRi^timerWeek^:S(day) -1 :(DAYS_IN_WEEK) +1;
!!VRi^timerMonthWeek^:S(day) -1 %(DAYS_IN_MONTH) :(DAYS_IN_WEEK) +1;
!!VRi^timerMonth^:S(day) -1 :(DAYS_IN_MONTH) +1;
!!VRi^timerOnce^:S(once);
!!VRi^timerOwner^:S(owner);
!!VRi^timerIsAi^:S(isAi);
!!VRi^timerIsHuman^:S(TRUE) -(isAi);

!?FU(OnBeforeBattle);
!!VRi^battle_round^:S(INT_MIN);
!!FU(UpdateBattleVars):P;

!?FU(OnBeforeBattleUniversal);
!!VRi^battle_round^:S(INT_MIN);
!!VRi^battle_current_side^:S(BATTLE_LEFT);
!!VRi^battle_current_stack^:S(NO_STACK);
!!VRi^battle_acting_stack^:S(NO_STACK);
!!VRi^battle_acting_side^:S(BATTLE_LEFT);
!!FU(UpdateBattleVars):P;

!?FU(OnBattleRound);
!!VRi^battle_round^:Sv997;

!?FU(OnBeforeBattleStackTurn);
!#VA(activeStack:x);
!!BM(activeStack:x):I?i^battle_current_side^;
!!VRi^battle_current_stack^:S(activeStack);
!!VRi^battle_isActingSideUiUser^:Si^battle_localHuman_%i(battle_current_side)^;

!?FU(OnBattleStackObtainsTurn);
!#VA(stackSide:x) (stackInd:x);
!!VRi^battle_current_side^:S(stackSide);
!!VRi^battle_current_stack^:S(stackSide) *(BATTLE_STACKS_PER_SIDE) +(stackInd);

!!BMi^battle_current_stack^:G(SPELL_HYPNOTIZE)/?(isHypnotized:y)/?t;
!!VRi^battle_current_side^&(isHypnotized):X1;

!!VRi^battle_isActingSideUiUser^:Si^battle_localHuman_%i(battle_current_side)^;

!?FU(OnBeforeBattleAction);
!!BG:N?i^battle_acting_stack^ Q?i^battle_acting_side^;
!!BA:Q?i^battle_isQuick^; can be changed during battle (!)
!!VRi^battle_isVisible^:Si^battle_aiOnly^ |i^battle_isQuick^ X(TRUE);
!!VRi^battle_isActingSideUiUser^:Si^battle_localHuman_%i(battle_current_side)^;
; ======== END EVENTS ========


; ========== ARRAYS ==========
!?FU(NewIntArray);
; Creates and returns trigger local array of integers.
; Alternative function arguments:
;  (?result)                     The result array will have 0 items.
;  (size)/(?result)              The result array will have (size) items with 0 value.
;  (size)/(fillValue)/(?result)  The result array will have (size) items will (fillValue) value
;  You may optionally specify (storageType) parameter after (?result) argument with value like M_STORED or M_TEMP.
!#VA(arg1:x);
!#VA(arg2:x);
!#VA(arg3:x);

!!FU:A?(numArgs:y);
!!VR(storageType:y):S(M_TRIGGER_LOCAL);

!!if&(numArgs)>=2;
  !!VR(penultimateArgInd:y):S(numArgs) -1;
  !!FU:S(penultimateArgInd)/?(penultimateArgSyntax:y);

  !!if&(penultimateArgSyntax)=(ARG_SYNTAX_GET);
    !!VR(storageType):Sx(numArgs);
    !!VR(numArgs):-1;
  !!en;
!!en;

!!if&(numArgs)<=1;
  !!SN:M(M_AUTO_ID)/0/(M_INT)/(storageType)/?(arg1);
  !!SN&(storageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(arg1);
!!el&(numArgs)<=2;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_INT)/(storageType)/?(arg2);
  !!SN&(storageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(arg2);
!!el&(numArgs)<=3;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_INT)/(storageType)/?(arg3);
  !!SN&(storageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(arg3);
  !!FU(Array_Fill):P(arg3)/(arg2)/0;
!!en;

!?FU(NewStrArray);
; Creates and returns trigger local array of strings.
; Alternative function arguments:
;  (?result)                     The result array will have 0 items.
;  (size)/(?result)              The result array will have (size) items with ^^ value.
;  (size)/(fillValue)/(?result)  The result array will have (size) items will (fillValue) value
;  You may optionally specify (storageType) parameter after (?result) argument with value like M_STORED or M_TEMP.
!#VA(arg1:x);
!#VA(arg2:x);
!#VA(arg3:x);

!!FU:A?(numArgs:y);
!!VR(storageType:y):S(M_TRIGGER_LOCAL);

!!if&(numArgs)>=2;
  !!VR(penultimateArgInd:y):S(numArgs) -1;
  !!FU:S(penultimateArgInd)/?(penultimateArgSyntax:y);

  !!if&(penultimateArgSyntax)=(ARG_SYNTAX_GET);
    !!VR(storageType):Sx(numArgs);
    !!VR(numArgs):-1;
  !!en;
!!en;

!!if&(numArgs)<=1;
  !!SN:M(M_AUTO_ID)/0/(M_STR)/(storageType)/?(arg1:x);
  !!SN&(storageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(arg1);
!!el&(numArgs)<=2;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_STR)/(storageType)/?(arg2:x);
  !!SN&(storageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(arg2);
!!el&(numArgs)<=3;
  !!SN:M(M_AUTO_ID)/(arg1)/(M_STR)/(storageType)/?(arg3:x);
  !!SN&(storageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(arg3);

  !!re i/0/(arg1)/1/-1;
    !!SN:V(arg3)/i/z(arg2);
  !!en;
!!en;

!?FU(Array_Push);
; Adds new items to the end of the array, resizing it automatically.
!#VA(list:x);      ID of array to push items to
!#VA(firstItem:x); ... Up to 15 arguments to append to list

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(itemsType:y)/d;
!!FU&(listSize)<0:E;

!!FU:A?(numArgs:y);
!!FU&(numArgs)<=(@list):E;

!!VR(newListSize:y):S(listSize) +(numArgs) -1;
!!SN:M(list)/(newListSize);

!!re i/(listSize)/(newListSize)/1/-1;
  !!VR(arg:y):Si -(listSize) +(@firstItem) Sx(arg);

  !!if&(itemsType)=(M_INT);
    !!SN:V(list)/i/(arg);
  !!el;
    !!SN:V(list)/i/z(arg);
  !!en;
!!en;

!?FU(Array_Pop);
; Removes items from the end of the array one by one, returning their values and resizing array automatically.
; At least single item is removed from the array, if possible.
; Example: P{list}/?{lastItem}/?{beforeLastItem}.
!#VA(list:x);      ID of array to pop items from.
!#VA(firstItem:x); OUT parameters... Up to 15 arguments to pop from the list. If item cannot be popped, it will be assigned zero value or empty string.

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(itemsType:y)/d;
!!FU&(listSize)<0:E;

!!FU:A?(numArgs:y);
!!VR(emptyStr:z):S^^;

!!VR(numPops:y):S(numArgs) -(@firstItem) +1;
!!VR(numPops)&(numPops)<1:S1;

!!VR(newListSize:y):S(listSize) -(numPops);
!!VR(newListSize)&(newListSize)<0:S0;
!!VR(numRealPops:y):S(listSize) -(newListSize);

!!re i/0/(numPops)/1/-1;
  !!VR(argInd:y):S(@firstItem) +i;

  !!if&i<(numRealPops);
    !!VR(listInd:y):S-1 -i;

    !!if&(itemsType)=(M_INT);
      !!SN:V(list)/(listInd)/?x(argInd);
    !!el;
      !!SN:V(list)/(listInd)/?s^temp^;
      !!VRx(argInd):Zs^temp^;
    !!en;
  !!el;
    !!if&(itemsType)=(M_INT);
      !!VRx(argInd):S0;
    !!el;
      !!VRx(argInd):S(@emptyStr);
    !!en;
  !!en; el
!!en; re

!!SN:M(list)/(newListSize);
!!VRs^temp^:S^^;

!?FU(Array_Move);
; Copies part of the array into another part of the array, overwriting existing values in a smart way.
; The parts may have overlapping indexes. The size of array never changes.
; Example: X X X [A B C] X X {X X X} => X X X [A B C] X X {A B C}
; Example: X X X [A {B C] X} X X X X => X X X [A {A B] C} X X X X
!#VA(list:x);    Array ID.
!#VA(offset:x);  Index to start copy from.
!#VA(length:x);  Number of items to copy.
!#VR(destInd:x); Position in array to copy items to (overwriting existing values).

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(itemsType:y)/d;
!!FU&(listSize)<0:E;

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@destInd);
  !!SN:F^ShowErmError^/^Array_Move: invalid number of function arguments^;
  !!FU:E;
!!en;

!!FU|(offset)>=(listSize)/(destInd)>=(listSize)/(offset)=(destInd)/(length)=0:E;

!!if&(offset)<0;
  !!SN:F^ShowErmError^/^Array_Move: invalid 'offset' argument: %(offset)^;
  !!FU:E;
!!en;

!!if&(length)<0;
  !!SN:F^ShowErmError^/^Array_Move: invalid 'length' argument: %(length)^;
  !!FU:E;
!!en;

!!if&(destInd)<0;
  !!SN:F^ShowErmError^/^Array_Move: invalid 'destInd' argument: %(destInd)^;
  !!FU:E;
!!en;

!!VR(maxSrcChunkLength:y):S(listSize) -(offset);
!!VR(maxDstChunkLength:y):S(listSize) -(destInd);
!!VR(length):F0/(maxSrcChunkLength) F0/(maxDstChunkLength);

!!if&(itemsType)=(M_INT);
  !!SN:M(list)/?(listAddr:y)/0;
  !!VR(srcAddr:y):S(offset) *(SIZEOF_INT) +(listAddr);
  !!VR(dstAddr:y):S(destInd) *(SIZEOF_INT) +(listAddr);
  !!VR(numBytesToCopy:y):S(length) *(SIZEOF_INT);
  !!SN:K(numBytesToCopy)/(srcAddr)/(dstAddr)/1;
!!el;
  !!VR(srcChunkEndInd:y):S(offset) +(length) -1;

  !!VR(srcInd:y):S(offset);
  !!VR(dstInd:y):S(destInd);
  !!VR(step:y):S1;

  ; If source and destination chunks overlap and we need to copy left part to the right, then we need to reverse copying order (from chunks end to start)
  ; Otherwise source chunk would overwrite itself
  !!if&(offset)<(destInd)/(srcChunkEndInd)>=(destInd);
    !!VR(srcInd):+(length) -1;
    !!VR(dstInd):+(length) -1;
    !!VR(step):S-1;
  !!en;

  !!re i/1/(length);
    !!SN:M(list)/(srcInd)/?s^temp^ M(list)/(dstInd)/s^temp^;
    !!VR(srcInd):+(step);
    !!VR(dstInd):+(step);
  !!en;
!!en; else

!!VRs^temp^:S^^;

!?FU(Array_Splice);
; Deletes specified number of items from start index and inserts new items in the same position afterwards.
; The function can be used for items deletion, insertion or replacement.
!#VA(list:x);              ID of array to perform splicing in.
!#VA(startIndex:x);        Index of first item to delete. If it's negative, it means "from array end". Thus -1 is the last array item.
!#VA(numItemsToDelete:x);  Optional. Number of items to delete.
;                          If not specified, all items are deleted from start index till array end.
;                          If it is positive, then that many elements will be removed.
;                          If it is negative, then the end of the removed portion will be that many elements from the end of the array.
;                          If it is zero, no elements will be removed.
!#VA(firstItemToInsert:x); ... Up to 13 arguments to insert in the position of deleted items.

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(itemsType:y)/d;
!!FU&(listSize)<0:E;

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@startIndex);
  !!SN:F^ShowErmError^/^Array_Splice: invalid number of function arguments^;
  !!FU:E;
!!en;

!!VR(startIndex)&(startIndex)<0:+(listSize);
!!VR(startIndex):F0/(listSize);

!!VR(maxItemsToDelete:y):S(listSize) -(startIndex);
!!VR(numItemsToDelete)&(numArgs)<(@numItemsToDelete):S(listSize);
!!VR(numItemsToDelete)&(numItemsToDelete)<0:S(listSize) +(numItemsToDelete) -(startIndex);
!!VR(numItemsToDelete):F0/(maxItemsToDelete);

!!VR(numInsertions:y):S(numArgs) -(@firstItemToInsert) +1;
!!VR(listSizeDiff:y):S(numInsertions) -(numItemsToDelete);
!!VR(newListSize:y):S(listSize) +(listSizeDiff);

; Determine, where to move the right (tail) part of array
!!VR(chunkStartInd:y):S(startIndex) +(numItemsToDelete);
!!VR(chunkDestInd:y):S(chunkStartInd) +(listSizeDiff);

; The number of deleted items is greater, than the number of inserted ones. We should shift tail items to the left BEFORE array is shrinked
; L L L [insert 1] [insert 2] [deleted 3] [deleted 4] R R R R => L L L [insert 1] [insert 2] R R R R [garbage] [garbage]
!!FU(Array_Move)&(listSizeDiff)<0:P(list)/(chunkStartInd)/(listSize)/(chunkDestInd);

; Perform array resize only if its length actually changed
!!SN&(listSizeDiff)<>0:M(list)/(newListSize);

; The number of inserted items is greater, than the number of deleted ones. We should shift tail items to the right AFTER array is expanded
; L L L [replaced 1] [replaced 2] [R vs insert 3] [R vs insert 4] R R => L L L [replaced 1] [replaced 2] [insert 3] [insert 4] R R R R
!!FU(Array_Move)&(listSizeDiff)>0:P(list)/(chunkStartInd)/(listSize)/(chunkDestInd);

; Write inserted/replaced items
!!if&(numInsertions)>0;
  !!VR(endIndex:y):S(startIndex) +(numInsertions) -1;
  !!VR(insertedItemPtr:y):S(@firstItemToInsert);

  !!re i/(startIndex)/(endIndex);
    !!if&(itemsType)=(M_INT);
      !!SN:M(list)/i/x(insertedItemPtr);
    !!el;
      !!VR(strPtr:y):Sx(insertedItemPtr);
      !!SN:M(list)/i/z(strPtr);
    !!en;

    !!VR(insertedItemPtr):+1;
  !!en;
!!en;

!!VRs^temp^:S^^;

!?FU(Array_Copy);
; Resizes destination array to match source array size and copies all source items into destination array.
; Both arrays must have the same items type.
!#VA(srcArray:x); ID of array to copy items from (source).
!#VA(dstArray:x); ID of array to copy items to (destination).

!!VR(numSrcItems:y):S-1;
!!SN:M(srcArray)/?(numSrcItems)/?(srcItemsType:y)/d;
!!FU&(numSrcItems)<0:E;

!!VR(numDstItems:y):S-1;
!!SN:M(dstArray)/?(numDstItems)/?(dstItemsType:y)/d;
!!FU&(numDstItems)<0:E;

!!if&(srcItemsType)<>(dstItemsType);
  !!SN:F^ShowErmError^/^Array_Copy: cannot copy items between arrays of different types^;
  !!FU:E;
!!en;

!!SN:M(dstArray)/(numSrcItems);
!!FU&(numSrcItems)<=0:E;

!!if&(srcItemsType)=(M_INT);
  !!SN:M(srcArray)/?(srcArrayAddr:y)/0 M(dstArray)/?(dstArrayAddr:y)/0;
  !!VR(numBytesToCopy:y):S(numSrcItems) *(SIZEOF_INT);
  !!SN:K(numBytesToCopy)/(srcArrayAddr)/(dstArrayAddr)/1;
!!el;
  !!re i/0/(numSrcItems)/1/-1;
    !!SN:M(srcArray)/?(strAddr:y)/i M(dstArray)/i/(strAddr);
  !!en;
!!en;

!?FU(Array_Clone);
; Creates trigger local copy of array.
!#VA(srcArray:x); ID of array to clone.
!#VA(result:x);   ID of result trigger local array.

!!VR(numSrcItems:y):S-1;
!!SN:M(srcArray)/?(numSrcItems)/?(srcItemsType:y)/d;
!!FU&(numSrcItems)<0:E;

!!SN:M(M_AUTO_ID)/0/(srcItemsType)/(M_TRIGGER_LOCAL)/?(result) F^ExtendArrayLifetime^/(result);
!!FU(Array_Copy):P(srcArray)/(result);

!?FU(Array_Merge);
; Given destination array and arbitrary number of source arrays. Appends all items from all source arrays
; to the destination array.
; Example. Given listA = [100, 200, 300], listB = [500, 600]. P(listA)/(listB) => [100, 200, 300, 500, 600]
!#VA(dstArray:x);          Destination array to append new items to.
!#VA(firstArrayToMerge:x); ... Arrays to merge with the first one

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@firstArrayToMerge);
  !!SN:F^ShowErmError^/^Array_Merge: invalid arguments number. Expected at least %(@firstArrayToMerge) arguments^;
  !!FU:E;
!!en;

!!VR(dstArraySize:y):S-1;
!!SN:M(dstArray)/?(dstArraySize)/?(dstArrayItemsType:y)/d;
!!FU&(dstArraySize)<0:E;

!!VR(numNewItems:y):S0;

!!re (argInd:y)/(@firstArrayToMerge)/(numArgs);
  !!VR(array:y):Sx(argInd);
  !!VR(arraySize:y):S-1;
  !!SN:M(array)/?(arraySize)/?(arrayItemsType:y)/d;
  !!FU&(arraySize)<0:E;

  !!if&(arrayItemsType)<>(dstArrayItemsType);
    !!SN:F^ShowErmError^/^Array_Merge: cannot merge arrays of different types. Invalid argument #%(argInd)^;
    !!FU:E;
  !!en;

  !!VR(numNewItems):+(arraySize);
!!en;

!!FU&(numNewItems)<=0:E;
!!SN:M(dstArray)/d(numNewItems) M(dstArray)/?t/d/d/?(dstArrayAddr:y);
!!VRi:S(dstArraySize);

!!re (argInd:y)/(@firstArrayToMerge)/(numArgs);
  !!VR(array:y):Sx(argInd);
  !!SN:M(array)/?(arraySize)/d/d/?(arrayAddr:y);
  !!co&(arraySize)<=0:E;

  !!if&(dstArrayItemsType)=(M_INT);
    !!VR(numBytesToCopy:y):S(arraySize) *(SIZEOF_INT);
    !!VR(dstAddr:y):Si *(SIZEOF_INT) +(dstArrayAddr);
    !!SN:K(numBytesToCopy)/(arrayAddr)/(dstAddr)/(DUMMY);
    !!VRi:+(arraySize);
  !!el;
    !!re j/0/(arraySize)/1/-1;
      !!VR(itemAddr:y):Sj *(SIZEOF_PTR) +(arrayAddr);
      !!UN:C(itemAddr)/(UNC_INT)/?(strAddr:y);
      !!SN&(strAddr)<>(NULL):M(dstArray)/i/(strAddr);
      !!VRi:+1;
    !!en; re
  !!en; el
!!en; re

!?FU(Array_Slice);
; Returns part of original array as new trigger-local array.
!#VA(list:x);   Array to get slice of.
!#VA(start:x);  Initial index, starting from zero. Negative offset means 'from the end'.
!#VA(count:x);  Number of items to copy. Negative value means "skipping" that number of items from list end.
!#VA(result:x); Result array.
!#VA(arrayStorageType:x); OPT. Special storage type for result like M_STORED. Default: M_TRIGGER_LOCAL.

!!VR(result):S(NULL);
!!FU:A?(numArgs:y);

!!if&(numArgs)<(@result);
  !!SN:F^ShowErmError^/^Array_Slice: invalid arguments number. Expected at least %(@result) arguments^;
  !!FU:E;
!!en;

!!VR(listSize:y):S-1;
!!SN:M(list)/?(listSize)/?(listItemsType:y)/d/?(listAddr:y);
!!FU&(listSize)<=0:E;

!!VR(arrayStorageType)&(numArgs)<(@arrayStorageType):S(M_TRIGGER_LOCAL);
!!SN:M(M_AUTO_ID)/0/(listItemsType)/(arrayStorageType)/?(result);
!!SN&(arrayStorageType)=(M_TRIGGER_LOCAL):F^ExtendArrayLifetime^/(result);

!!VR(start)&(start)<0:+(listSize) F0/(INT_MAX);
!!FU&(start)>=(listSize):E;

!!VR(maxItemsToCopy:y):S(listSize) -(start);

!!if&(count)<0;
  !!VR(maxItemsToCopy):+(count);
  !!VR(count):S(maxItemsToCopy);
!!en;

!!VR(count):F0/(maxItemsToCopy);
!!FU&(count)<=0:E;

!!SN:M(result)/(count) M(result)/?t/d/d/?(resultAddr:y);

!!if&(listItemsType)=(M_INT);
  !!VR(srcAddr:y):S(start) *(SIZEOF_INT) +(listAddr);
  !!VR(numBytesToCopy:y):S(count) *(SIZEOF_INT);
  !!SN:K(numBytesToCopy)/(srcAddr)/(resultAddr)/(DUMMY);
!!el;
  !!VR(lastIndToCopy:y):S(start) +(count) -1;
  !!VRj:S0;

  !!re i/(start)/(lastIndToCopy);
    !!VR(itemAddr:y):Si *(SIZEOF_INT) +(listAddr);
    !!UN:C(itemAddr)/(UNC_INT)/?(strAddr:y);
    !!SN&(strAddr)<>(NULL):M(result)/j/(strAddr);
    !!VRj:+1;
  !!en;
!!en;

!?FU(Array_Join);
; Concatenates array items into single string, using passed glue string. Works with both numeric and string arrays.
; Example: ['one', 'two', 'three'] with glue ' --- ' become 'one --- two --- three'.
!#VA(list:x);      Array ID.
!#VA(resultPtr:x); OUT. Result string
!#VA(gluePtr:x);   Optional. Glue string. Default: ''.

!!VRs^result^:S^^;
!!VR(emptyStr:z):S^^;

!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d;
!!FU&(numItems)<0:E;

!!VR(gluePtr)&(gluePtr)=0:S(@emptyStr);

!!VR(lastItemInd:y):S(numItems) -1;

!!if&(itemsType)=(M_INT);
  !!re i/0/(numItems)/1/-1;
    !!SN:V(list)/i/?(item:y);
    !!VRs^result^:+^%(item)^;
    !!VRs^result^&i<(lastItemInd):+z(gluePtr);
  !!en;
!!el;
  !!re i/0/(numItems)/1/-1;
    !!SN:V(list)/i/?s^temp^;
    !!VRs^result^:+s^temp^;
    !!VRs^result^&i<(lastItemInd):+z(gluePtr);
  !!en;

  !!VRs^temp^:S^^;
!!en;

!!VR(resultPtr):Zs^result^;
!!VRs^result^:S^^;

!?FU(Array_Sort);
; Sorts array items in ascending order. Allows to sort specific array subrange.
!#VA(list:x);     Array ID.
!#VA(startInd:x); Optional. Start index of array subrange to sort. Default: 0.
!#VA(endInd:x);   Optional. End index of array subrange to sort. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>=(endInd):E;

; Perform sorting
!!VR(savedV1:y):Sv1;

!!if&(itemsType)=(M_STR);
  !!SN:F^Erm_SortStrArray^/(listAddr)/(startInd)/(endInd);
!!el;
  !!SN:F^Erm_SortInt32Array^/(listAddr)/(startInd)/(endInd);
!!en;

!!VRv1:S(savedV1);

!?FU(CompareStrings_Bridge_INTERNAL);
!#VA(str1Addr:x) (str2Addr:x) (bridgeState:x) (result:x);

!!if&(str1Addr)<>0;
  !!SN:X?t X(str1Addr) X?s^temp^ Xt;
  !!VR(value1:y):Zs^temp^;
  !!VRs^temp^:S^^;
!!el;
  !!VR(value1:y):Z^^;
!!en;

!!if&(str2Addr)<>0;
  !!SN:X?t X(str2Addr) X?s^temp^ Xt;
  !!VR(value2:y):Zs^temp^;
  !!VRs^temp^:S^^;
!!el;
  !!VR(value2:y):Z^^;
!!en;

!!SN:V(bridgeState)/0/?(compareFunc:y)/?(compareFuncState:y);
!!FU(compareFunc):P(value1)/(value2)/(compareFuncState)/?(result);

!?FU(Array_CustomSort);
; Sorts array items in ascending order user custom comparator function. Allows to sort specific array subrange.
; It's possible to perform any complex sorting in any direction and by unlimited number of criteria, using this method.
; It's a stable sorting method, i.e. items, which we be reported as equal, will retain their relative position to each other.
; For example, if sorting 'Ann', 'David' and 'Ken' by name length, the result will be 'Ann', 'Ken', 'David' and not 'Ken', 'Ann', 'David'.
; When sorting string array, comparator function will receive z-indexes of strings as arguments.
!#VA(list:x);        Array ID.

!#VA(compareFunc:x); Comparison ERM function ID. It will be called multiple times with the following arguments:
                   ; (value1, value2, state, result), where 'state' is any custom value, you specify on call to Array_CustomSort.
                   ; Usually state is some array ID or external structure address, that client use to compare items.
                   ;
                   ; The function must return value:
                   ; < 0 if value1-item should be placed before value2-item
                   ; > 0 if value1-item should be placed after value2-item
                   ; 0 if the ordering between two items should be left as is.

!#VA(state:x);    Optional. Custom value to be always passed to comparison function as the third argument. Default: 0.
!#VA(startInd:x); Optional. Start index of array subrange to sort. Default: 0.
!#VA(endInd:x);   Optional. End index of array subrange to sort. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Check compare function
!!if&(compareFunc)<0;
  !!SN:F^ShowErmError^/^Invalid comparison custom function for Array_CustomSort: %(compareFunc)^;
  !!FU:E;
!!en;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>=(endInd):E;

; Perform sorting
!!VR(savedV1:y):Sv1;

!!if&(itemsType)=(M_STR);
  !!SN:M(M_AUTO_ID)/2/(M_INT)/(M_TRIGGER_LOCAL)/?(bridgeState:y);
  !!SN:V(bridgeState)/0/(compareFunc)/(state);
  !!SN:F^Erm_CustomStableSortInt32Array^/(listAddr)/(startInd)/(endInd)/(CompareStrings_Bridge_INTERNAL)/(bridgeState);
!!el;
  !!SN:F^Erm_CustomStableSortInt32Array^/(listAddr)/(startInd)/(endInd)/(compareFunc)/(state);
!!en;

!!VRv1:S(savedV1);

!?FU(Array_SortedUnique);
; Leaves only unique sorted integer items in the array.
; Calling on [15, 4, 3, 3, 1, 20, 15] list will rearrange and truncate list to the following:
; [1, 3, 4, 15, 20]
!#VA(list:x); Array ID

!!SN:M(list)/?(listSize:y)/?(itemsType:y)/d;
!!FU&(listSize)<=1:E;

!!if&(itemsType)<>(M_INT);
  !!SN:F^ShowErmError^/^Array_SortedUnique function supports only integer arrays^;
  !!FU:E;
!!en;

!!FU(Array_Sort):P(list);
!!SN:V(list)/0/?(prevItem:y);

; Find first non-unique item
!!re i/1/(listSize)/1/-1;
  !!SN:V(list)/i/?(item:y);
  !!br&(item)=(prevItem);
  !!VR(prevItem):S(item);
!!en;

; Non-unique item was found
!!if&i<(listSize);
  ; Loop though rest items, copying only unique to the left part
  !!VRj:Si +1;

  !!re j/j/(listSize)/1/-1;
    !!SN:V(list)/j/?(item:y);

    !!if&(item)<>(prevItem);
      !!SN:V(list)/i/(item);
      !!VRi:+1;
    !!en;

    !!VR(prevItem):S(item);
  !!en;

  ; Truncate non-unique items
  !!SN:M(list)/i;
!!en;

!?FU(Array_Shuffle);
; Randomly shuffles all items in the list.
!#VA(list:x); Array ID.

!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d/?(listAddr:y);
!!FU&(numItems)<=1:E;

!!VR(lastIndex:y):S(numItems) -1;

!!re i/0/(numItems)/1/-1;
  !!VR(randomInd:y):R0/i/(lastIndex);

  !!if&(itemsType)=(M_INT);
    !!SN:V(list)/(randomInd)/?t V(list)/i/?(currItem:y) V(list)/(randomInd)/(currItem) V(list)/i/t;
  !!el;
    !!VR(currItemAddr:y):Si *(SIZEOF_INT) +(listAddr);
    !!VR(randomItemAddr:y):S(randomInd) *(SIZEOF_INT) +(listAddr);
    !!UN:C(randomItemAddr)/(UNC_INT)/?(randomItem:y) C(currItemAddr)/(UNC_INT)/?(currItem:y) C(randomItemAddr)/(UNC_INT)/(currItem) C(currItemAddr)/(UNC_INT)/(randomItem);
  !!en;
!!en;

!?FU(Array_Revert);
; Reverts order of itmes in the array. Allows to reverse the order of specific array subrange only.
!#VA(list:x);     Array ID.
!#VA(startInd:x); Optional. Start index of array subrange. Default: 0.
!#VA(endInd:x);   Optional. End index of array subrange. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/d/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>=(endInd):E;

; Perform reversing
!!VR(savedV1:y):Sv1;
!!SN:F^Erm_RevertInt32Array^/(listAddr)/(startInd)/(endInd);
!!VRv1:S(savedV1);

!?FU(Array_Fill);
; Fills array or arrays subrange with incrementing/decrementing values.
; Example: FU(Array_Fill):P(array)/100/2; Will fill items with 100, 102, 104, 106...
!#VA(list:x);       Array ID.
!#VA(startValue:x); Starting value to fill with.
!#VA(step:x);       Value to add to increase filler on each step. Default: 0.
!#VA(startInd:x);   Optional. Start index of array subrange. Default: 0.
!#VA(endInd:x);     Optional. End index of array subrange. Default: numItems - 1.

; Get num items, exit for invalid array
!!VR(numItems:y):S0;
!!SN:M(list)/?(numItems)/d/d/?(listAddr:y);
!!FU&(numItems)<=0:E;

; Handle optional parameters
!!FU:A?(numArgs:y);
!!VR(startInd)&(numArgs)<(@startInd):S0;
!!VR(endInd)  &(numArgs)<(@endInd):S(numItems) -1;

; Normalize range to process
!!VR(startInd)&(startInd)<0:S0;
!!VR(endInd)&(endInd)>=(numItems):S(numItems) -1;
!!FU&(startInd)>(endInd):E;

; Perform filling
!!VR(savedV1:y):Sv1;
!!SN:F^Erm_FillInt32Array^/(listAddr)/(startInd)/(endInd)/(startValue)/(step);
!!VRv1:S(savedV1);

!?FU(Array_Resize);
; Changes array size, optionally filling new items with default value.
!#VA(list:x);      Array ID.
!#VA(newSize:x);   New array size.
!#VA(fillValue:x); Optional. Fill value for new items. Default: ^^ or 0.

; Get num items, exit for invalid array
!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems)/?(itemsType:y)/d;
!!FU&(numItems)<0:E;

; Perform resizing
!!SN:M(list)/(newSize);
!!FU&(newSize)<=(numItems):E;

; Exit if no fill value is set
!!FU&(fillValue)=0:E;
!!FU&(itemsType)=(M_STR)/z(fillValue)=^^:E;

; Fill new items value
!!if&(itemsType)=(M_INT);
  !!re i/(numItems)/(newSize)/1/-1;
    !!SN:V(list)/i/(fillValue);
  !!en;
!!el;
  !!re i/(numItems)/(newSize)/1/-1;
    !!SN:V(list)/i/z(fillValue);
  !!en;
!!en;

!?FU(Array_EnsureMinSize);
; Checks, if array has at least specified minimal size and increasing the size if not, filling new items
; with optional default value.
!#VA(list:x);      Array ID.
!#VA(minSize:x);   Minimal desired array size.
!#VA(fillValue:x); Optional. Fill value for new items. Default: ^^ or 0.

!!VR(numItems:y):S-1;
!!SN:M(list)/?(numItems);
!!FU|(numItems)<0/(numItems)>=(minSize):E;

!!FU(Array_Resize):P(list)/(minSize)/(fillValue);

!?FU(Array_CountValue);
; Returns number of array items, equal to specified value.
!#VA(list:x);            Array ID.
!#VA(value:x);           Value to count. Strings are supported.
!#VA(result:x);          Result.
!#VA(caseInsensitive:x); Optional. If true, strings will be compared case insensitively. Default: false.

!!VR(result):S0;
!!SN:M(list)/?(numItems:y)/?(itemsType:y)/?t/?(firstItemAddr:y);
!!FU&(numItems)<=0:E;

!!if&(itemsType)=(M_INT);
  !!re i/0/(numItems)/1/-1;
    !!SN:M(list)/i/?(item:y);
    !!VR(result)&(item)=(value):+1;
  !!en;
!!el;
  !!VR(savedV1:y):Sv1;
  !!VR(comparisonFuncName:z):S^lstrcmpA^;
  !!VR(comparisonFuncName)&(caseInsensitive):S^lstrcmpiA^;

  !!re i/0/(numItems)/1/-1;
    !!VR(itemAddr:y):Si *(SIZEOF_PTR) +(firstItemAddr);
    !!UN:C(itemAddr)/(UNC_INT)/?(itemStrAddr:y);
    !!SN:F(comparisonFuncName)/(itemStrAddr)/z(value);
    !!VR(result)&v1=0:+1;
  !!en;

  !!VRv1:S(savedV1);
!!en;

!?FU(Array_IndexOf);
; Returns index of the first array item with specified value or -1 in case of failure.
!#VA(list:x);            Array ID.
!#VA(value:x);           Value to search for.
!#VA(result:x);          Result index or -1 in case of failure.
!#VA(caseInsensitive:x); Optional. If true, strings will be compared case insensitively. Default: false.

!!VR(result):S-1;
!!SN:M(list)/?(numItems:y)/?(itemsType:y)/?t/?(firstItemAddr:y);
!!FU&(numItems)<=0:E;

!!if&(itemsType)=(M_INT);
  !!re i/0/(numItems)/1/-1;
    !!SN:M(list)/i/?(item:y);

    !!if&(item)=(value);
      !!VR(result):Si;
      !!br;
    !!en;
  !!en;
!!el;
  !!VR(savedV1:y):Sv1;
  !!VR(comparisonFuncName:z):S^lstrcmpA^;
  !!VR(comparisonFuncName)&(caseInsensitive):S^lstrcmpiA^;

  !!re i/0/(numItems)/1/-1;
    !!VR(itemAddr:y):Si *(SIZEOF_PTR) +(firstItemAddr);
    !!UN:C(itemAddr)/(UNC_INT)/?(itemStrAddr:y);
    !!SN:F(comparisonFuncName)/(itemStrAddr)/z(value);

    !!if&v1=0;
      !!VR(result):Si;
      !!br;
    !!en;
  !!en;

  !!VRv1:S(savedV1);
!!en;

!?FU(Array_Find);
; Returns index of the first array item, for which custom callback function returns (TRUE) or -1 in case of failure.
!#VA(list:x);      Array ID.
!#VA(callback:x);  Callback function F(itemValue, ?result, [listId], [customArg]), where result is (TRUE) or (FALSE). (FALSE) is passed by default.
                ;  listID is array ID and customArg is anything, specified as custom argument to Array_Find. Zero by default.
!#VA(result:x);    Result index or -1 in case of failure.
!#VA(customArg:x); Custom argument to pass to callback as the 4-th parameter.

!!VR(result):S-1;
!!SN:M(list)/?(numItems:y)/?(itemsType:y)/?t;
!!FU&(numItems)<=0:E;

!!if&(itemsType)=(M_INT);
  !!re i/0/(numItems)/1/-1;
    !!SN:M(list)/i/?(item:y);
    !!VR(found:y):S(FALSE);
    !!FU(callback):P(item)/?(found)/(list)/(customArg);

    !!if&(found);
      !!VR(result):Si;
      !!br;
    !!en;
  !!en;
!!el;
  !!re i/0/(numItems)/1/-1;
    !!SN:M(list)/i/?(itemStr:z);

    !!VR(found:y):S(FALSE);
    !!FU(callback):P(itemStr)/?(found)/(list)/(customArg);

    !!if&(found);
      !!VR(result):Si;
      !!br;
    !!en;
  !!en;
!!en;

; ======== END ARRAYS ========


; ========== MATH ==========

!?FU(Pow);
; Raises value to specified power. All arguments and result are floats.
!#VA(base:x) (power:x) (result:x);

!!SN:F^.Erm_Pow^/(base)/(power);
!!VR(result):Ce1;

!?FU(Sqrt);
; Returns value square root. All arguments and result are floats.
!#VA(value:x) (result:x);

!!SN:F^.Erm_Sqrt^/(value);
!!VR(result):Ce1;

!?FU(IntLog2);
; Returns Ceil(Log2(N)) or 0 for invalid values (<= 0).
!#VA(value:x) (result:x);

!!if&(value)<=0;
  !!VR(result):S0;
  !!FU:E;
!!en;

!!VR(savedV1:y):Sv1;
!!SN:F^Erm_IntLog2^/(value);
!!VR(result):Sv1;
!!VRv1:S(savedV1);

!?FU(ConstructBitMask);
; Accepts up to 15 bit/flag positions (0..31). Returns mask with corresponding bit flags set.
; Actually, given Xi arguments, returns Sum(2 ^ xi).
; For example, P0/3/7/?(mask:y) will give 2 ^ 0 + 2 ^ 3 + 2 ^ 7 = 1 + 8 + 128 = 137.
!#VA(args:x);   ... Up to 15 bit/flag positions.
!#VA(result:x); The last argument will contain the result mask.

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@result);
  !!SN:F^ShowErmError^/^ConstructBitMask function expects at least 2 arguments. Given %(numArgs) arguments^;
  !!FU:E;
!!en;

!!VR(mask:y):S0;

!!re i/(@args)/(numArgs)/1/-1;
  !!VR(arg:y):Sxi;

  !!if&(arg)>=0/(arg)<=31;
    !!VR(bit:y):S1 Sd<<(arg);
    !!VR(mask):|(bit);
  !!el;
    !!SN:F^ShowErmError^/^Invalid bit/flag position: %(arg). Arg #%i. Expected value 0..31^;
    !!FU:E;
  !!en;
!!en;

!!VRxi:S(mask);

!?FU(DeconstructBitMask);
; Deconstructs bit mask into list of bit/flag positions (each with 0..31 value).
; For example, P137/(list) will fill the list with [0, 3, 7] values, because
; 2 ^ 0 + 2 ^ 3 + 2 ^ 7 = 1 + 8 + 128 = 137. It means, that bits 0, 3 and 7 are set.
!#VA(mask:x);   Bit mask.
!#VA(result:x); Will contain new trigger local array ID with bit/flag positions.

!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_TRIGGER_LOCAL)/?(result) F^ExtendArrayLifetime^/(result);

!!VR(bit:y):S1;

!!re i/0/31;
  !!VR(test:y):S(mask) &(bit);
  !!SN&(test)<>0:M(result)/d1 V(result)/-1/i;
  !!VR(bit):Sd<<1;
!!en;

!?FU(PackUnion);
; Safely packs union fields into single 32-bits integer, allowing to store multiple values in a single variable.
; Arguments are pairs of (field value, field size in bits). The first field is written at bit 0-th position.
; The last argument is result.
; Example: P(x)/8/ (y)/8/ (z)/8/ (heroId)/8/ ?(result:y);
!#VA(firstArg:x); ... Pairs of (field value)/(field size)

!!FU:A?(numArgs:y);
!!VRt:S(numArgs) %2;

!!if&t<>1;
  !!SN:F^ShowErmError^/^PackUnion: invalid arguments number: %(numArgs)^;
  !!FU:E;
!!en;

!!VRx(numArgs):S0;
!!FU&(numArgs)<=1:E;

!!VR(result:y):S0;
!!VR(numPairs:y):S(numArgs) :2;
!!VR(totalFieldsSize:y):S0;

!!re i/0/(numPairs)/1/-1;
  !!VR(argInd:y):Si *2 +(@firstArg);
  !!VR(fieldValue:y):Sx(argInd);
  !!VR(argInd):+1;
  !!VR(fieldSize:y):Sx(argInd);

  !!if|(fieldSize)<0/(fieldSize)>(BITS_IN_INT32);
    !!SN:F^ShowErmError^/^PackUnion: invalid field size: %(fieldSize). Expected 1..%(BITS_IN_INT32)^;
    !!FU:E;
  !!en;

  !!VR(fieldMask:y):S1 Sd<<(fieldSize) -1;

  !!if&(fieldValue)>(fieldMask);
    !!VRi:+1;
    !!SN:F^ShowErmError^/^PackUnion: value in pair #%i = %(fieldValue) exceeds maximum possible value %(fieldMask) for field of %(fieldSize) bits^;
    !!FU:E;
  !!en;

  !!VR(fieldValue):&(fieldMask) Sd<<(totalFieldsSize);
  !!VR(totalFieldsSize):+(fieldSize);

  !!if&(totalFieldsSize)>(BITS_IN_INT32);
    !!SN:F^ShowErmError^/^PackUnion: total fields size %(totalFieldsSize) exceeds maximum of %(BITS_IN_INT32) bits^;
    !!FU:E;
  !!en;

  !!VR(result):|(fieldValue);
!!en; re

!!VRx(numArgs):S(result);

!?FU(UnpackUnion);
; Safely unpacks single 32-bits integer value into multiple field values.
; The first argument is packed value.
; Other arguments are pairs of (?field value, field size in bits). The first field is read at bit 0-th position.
; Example: P45683/ ?(x:y)/8/ ?(y:y)/8/ ?(z:y)/8/ ?(heroId:y)/8;
!#VA(packedValue:x);
!#VA(firstFieldArg:x);

!!FU:A?(numArgs:y);
!!VRt:S(numArgs) %2;

!!if|t<>1/(numArgs)<(@firstFieldArg);
  !!SN:F^ShowErmError^/^UnpackUnion: invalid arguments number: %(numArgs)^;
  !!FU:E;
!!en;

!!VR(numPairs:y):S(numArgs) :2;
!!VR(totalFieldsSize:y):S0;

!!re i/0/(numPairs)/1/-1;
  !!VR(argInd:y):Si *2 +(@firstFieldArg) +1;
  !!VR(fieldSize:y):Sx(argInd);
  !!VR(argInd):-1;

  !!if|(fieldSize)<0/(fieldSize)>(BITS_IN_INT32);
    !!SN:F^ShowErmError^/^UnpackUnion: invalid field size: %(fieldSize). Expected 1..%(BITS_IN_INT32)^;
    !!FU:E;
  !!en;

  !!VR(fieldMask:y):S1 Sd<<(fieldSize) -1;
  !!VRx(argInd:y):S(packedValue) Sd>>(totalFieldsSize) &(fieldMask);
  !!VR(totalFieldsSize):+(fieldSize);

  !!if&(totalFieldsSize)>(BITS_IN_INT32);
    !!SN:F^ShowErmError^/^UnpackUnion: total fields size %(totalFieldsSize) exceeds maximum of %(BITS_IN_INT32) bits^;
    !!FU:E;
  !!en;
!!en; re

!?FU(Tm32Encode);
; Fast and reversable int32 hashing. Link: https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
!#VA(value:x) (result:x);

!!VRf:S(value) Sd>>16 X(value) *73244475;
!!VRg:Sf Sd>>16 Xf *73244475;
!!VR(result):Sg Sd>>16 Xg;

!?FU(Tm32Decode);
; Fast and reversable int32 hashing. Link: https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
!#VA(value:x) (result:x);

!!VRf:S(value) Sd>>16 X(value) *295559667;
!!VRg:Sf Sd>>16 Xf *295559667;
!!VR(result):Sg Sd>>16 Xg;

!?FU(Hash32);
; Calculates int32 digest (hash sum) of arbitrary sequence of bytes.
!#VA(data:x);    Pointer to data first byte or string
!#VA(dataLen:x); Length of data in bytes
!#VA(result:x);  Result hash

!!VR(savedV1:y):Sv1;
!!SN:F^Hash32^/(data)/(dataLen);
!!VR(result):Sv1;
!!VRv1:S(savedV1);

!?FU(MakeRngSeed);
; Generates deterministic int32 seed for pseudo random number generator, consuming up to 15 arbitrary int32 parameters.
; Example: FU(MakeRngSeed):P(x)/(y)/(z)/(heroId)/?(seed:y); get prng seed, which will be the same for given coordinates and hero
!#VA(firstArg:x);

!!FU:A?(numArgs:y);
!!FU&(numArgs)=0:E;

!!VR(savedV1:y):Sv1;
!!VR(resultPtr:y):S(numArgs);
!!VR(dataLen:y):S(numArgs) -1 *(SIZEOF_INT);
!!SN:F^Hash32^/?(firstArg)/(dataLen);
!!VRx(resultPtr):Sv1;
!!VRv1:S(savedV1);

!?FU(SplitMix32);
; Generates new random value using SplitMix32 algorithm and modifies input seed value.
; Possible syntaxes:
;  FU:P?(seed:y) ?(result:y);             Generate random int32 value (negative or positive)
;  FU:P?(seed:y)/(min)/(max) ?(result:y); Generate random int32 value in [min..max] range
!#VA(seed:x);   OUT. Previous generator seed. Pass by reference (using ?), because this value will change after generation
!#VA(min:x);    Minimum value.
!#VA(max:x);    Maximum value.
!#VA(result:x); OUT. Result number

!!FU:A?(numArgs:y);

!!if&(numArgs)<>2/(numArgs)<>4;
  !!SN:F^ShowErmError^/^SplitMix32: invalid number of arguments^;
  !!FU:E;
!!en;

!!if&(numArgs)=2;
  !!VR(minValue:y):S(INT_MIN);
  !!VR(maxValue:y):S(INT_MAX);
  !!VR(resultPtr:y):S(@min);
!!el;
  !!VR(minValue:y):S(min);
  !!VR(maxValue:y):S(max);
  !!VR(resultPtr:y):S(@result);
!!en;

!!VR(savedV1:y):Sv1;
!!SN:F^SplitMix32^/?(seed)/(minValue)/(maxValue);
!!VRx(resultPtr):Sv1;
!!VRv1:S(savedV1);
; ======== END MATH ========


; ================ STRINGS ================
!?FU(GetStrAtAddr);
; Reads null terminated string at specified address into s^result^ variable.
; Null address (0) results in empty string.
!#VA(strAddr:x);   Address of null-terminated string in memory or 0.
!#VA(resultPtr:x); String variable, to copy string contents to.

!!SN:B(strAddr)/d/?s^temp^;
!!VR(resultPtr):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(CompareStrings);
; Compares two strings. Returns value <0, =0 or >0, corresponding to items relation.
!#VA(str1Ptr:x) (str2Ptr:x) (result:x);

!!VR(result):S0;

!!if&z(str1Ptr)<z(str2Ptr);
  !!VR(result):S-1;
!!el&z(str1Ptr)>z(str2Ptr);
  !!VR(result):S1;
!!en;

!?FU(StrToUpper);
; Converts given string to upper case.
!#VA(strPtr:x);    Source string.
!#VA(resultPtr:x); OUT. Result string.

!!SN:M(M_AUTO_ID)/1/(M_STR)/(M_TRIGGER_LOCAL)/?(buf:y) M(buf)/0/z(strPtr) M(buf)/?(strAddr:y)/0;

!!VR(savedV1:y):Sv1;
!!SN:F^CharUpperA^/(strAddr);
!!VRv1:S(savedV1);

!!SN:M(buf)/0/?s^temp^;
!!VR(resultPtr):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(StrToLower);
; Converts given string to lower case.
!#VA(strPtr:x);    Source string.
!#VA(resultPtr:x); OUT. Result string.

!!SN:M(M_AUTO_ID)/1/(M_STR)/(M_TRIGGER_LOCAL)/?(buf:y) M(buf)/0/z(strPtr) M(buf)/?(strAddr:y)/0;

!!VR(savedV1:y):Sv1;
!!SN:F^CharLowerA^/(strAddr);
!!VRv1:S(savedV1);

!!SN:M(buf)/0/?s^temp^;
!!VR(resultPtr):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(Substr);
; Returns substring from existing string.
!#VA(strPtr:x); Original string.
!#VA(start:x);  Initial offset, starting from zero. Negative offset means 'from the end'.
!#VA(count:x);  Number of characters to copy. Negative value means "skipping" that number of characters from string end.
!#VA(result:x); Result substring.

!!VR(emptyStr:z):S^^;
!!VR(result):S(@emptyStr);

!!if&(strPtr)=(NULL);
  !!SN:F^ShowErmError^/^Substr: invalid strPtr argument: 0^;
  !!FU:E;
!!en;

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@count);
  !!SN:F^ShowErmError^/^Substr: invalid arguments number. Expected at least %(@count) arguments^;
  !!FU:E;
!!en;

!!VRz(strPtr):M4/?(strLen:y);
!!FU&(strLen)<=0:E;

!!VR(start)&(start)<0:+(strLen) F0/(INT_MAX);
!!FU&(start)>=(strLen):E;

!!VR(maxCharsToCopy:y):S(strLen) -(start);

!!if&(count)<0;
  !!VR(maxCharsToCopy):+(count);
  !!VR(count):S(maxCharsToCopy);
!!en;

!!VR(count):F0/(maxCharsToCopy);
!!FU&(count)<=0:E;

!!SN:Bz(strPtr)/?(startAddr:y);
!!VR(startAddr):+(start);
!!VR(endAddr:y):S(startAddr) +(count);
!!VR(resultSize:y):S(count) +1;
!!VR(savedV1:y):Sv1;

!!SN:E(FUNC_MEM_ALLOC)/(CALLCONV_CDECL)/(resultSize);
!!VR(buf:y):Sv1;
!!SN:K(count)/(startAddr)/(buf)/0 K(buf)/(count)/^^ B(buf)/d/?s^temp^;
!!SN:E(FUNC_MEM_FREE)/(CALLCONV_CDECL)/(buf);

!!VRv1:S(savedV1);
!!VR(result):Zs^temp^;
!!VRs^temp^:S^^;

!?FU(DecorateInt);
; Converts integer to string, separating each three digit group by "era.locale.thousand_separator" characer.
; Example: P74276689 => "74 276 689"
!#VA(value:x);              Number to decorate.
!#VA(resultPtr:x);          OUT. Result string.
!#VA(ignoreSmallNumbers:x); Optional boolean. If set to DONT_DECORATE_SMALL_INTS, values <= 9999 are not decorated. Default: false.

!!VR(savedV1:y):Sv1;
!!SN:F^DecorateInt^/(value)/?(text:z)/(ignoreSmallNumbers);
!!VR(resultPtr):S(@text);
!!VRv1:S(savedV1);

!?FU(FormatQuantity);
; Formats given positive or negative quantity to human-readable string with desired constraints on length and maximal number of digits.
; Uses game locale settings and metric suffixes like "K", "M" and "G".
; Example: P-1234567890/6/4 => "-1.23G"
!#VA(value:x);     Quantity to format.
!#VA(resultPtr:x); OUT. Result string.
!#VA(maxLen:x);    Optional. Maximum desired string length in logical characters. Default: 5.
!#VA(maxDigits:x); Optional. Maximum number of digits to use in result (the more digits to display, the slower the number is read by humans). Default: 4.

!!FU:A?(numArgs:y);
!!VR(maxLen)&(numArgs)<(@maxLen):S5;
!!VR(maxDigits)&(numArgs)<(@maxDigits):S4;

!!VR(savedV1:y):Sv1;
!!SN:F^FormatQuantity^/(value)/?(text:z)/(SIZEOF_ZSTR)/(maxLen)/(maxDigits);
!!VR(resultPtr):S(@text);
!!VRv1:S(savedV1);
; ============== END STRINGS ==============


; ================ FILE SYSTEM ================
!?FU(FileExists);
; Returns true if file (not directory) exists.
!#VA(filePathPtr:x); Absolute or relative path to file
!#VA(result:x);      Boolean. (TRUE) if file exists and is not a directory

!!VR(savedV1:y):Sv1;
!!SN:F^GetFileAttributesA^/z(filePathPtr);
!!VR(result):S(FALSE);
!!VR(dirFlag:y):Sv1 &(FILE_ATTRIBUTE_DIRECTORY);
!!VR(result)&v1<>(INVALID_FILE_ATTRIBUTES)/(dirFlag)=0:S(TRUE);
!!VRv1:S(savedV1);

!?FU(DirExists);
; Returns true if a directory (not a file) exists.
!#VA(dirPathPtr:x); Absolute or relative path to directory
!#VA(result:x);     Boolean. (TRUE) if directory exists and is not a directory

!!VR(savedV1:y):Sv1;
!!SN:F^GetFileAttributesA^/z(dirPathPtr);
!!VR(result):S(FALSE);
!!VR(dirFlag:y):Sv1 &(FILE_ATTRIBUTE_DIRECTORY);
!!VR(result)&v1<>(INVALID_FILE_ATTRIBUTES)/(dirFlag)<>0:S(TRUE);
!!VRv1:S(savedV1);

!?FU(DeleteFile);
; Deletes specified file and returns success flag.
!#VA(filePathPtr:x); Absolute or relative path to file
!#VA(result:x);      Boolean. (TRUE) if file existed and was deleted

!!VR(savedV1:y):Sv1;
!!SN:F^DeleteFileA^/z(filePathPtr);
!!VR(result):S(FALSE);
!!VR(result)&v1<>0:S(TRUE);
!!VRv1:S(savedV1);

!?FU(ClearIniCache);
; Erases all cached ini file data from memory. You can safely delete ini file afterwards.
!#VA(filePathPtr:x); Absolute or relative path to ini file

!!VR(savedV1:y):Sv1;
!!SN:F^ClearIniCache^/z(filePathPtr);
!!VRv1:S(savedV1);

!?FU(CreateDir);
; Creates new directory if it does not exist.
!#VA(dirPathPtr:x); Absolute or relative path to directory

!!VR(savedV1:y):Sv1;
!!SN:F^CreateDirectoryA^/z(dirPathPtr)/0;
!!VRv1:S(savedV1);

!?FU(SaveIni);
; Saves ini file, if it was earlier cached in memory (any read/write operation was performed).
!#VA(filePathPtr:x); Absolute or relative path to ini file

!!VR(savedV1:y):Sv1;
!!SN:F^SaveIni^/z(filePathPtr);
!!VRv1:S(savedV1);

!?FU(WriteIniInts);
; Writes multiple integer values to ini file in memory, but postpones saving data to disk. Call "SaveIni" to flush cached data.
; Example: P^Runtime/my mod.ini^/^hero levels^/(HERO_ORRIN)/13/(HERO_XERON)/41;
!#VA(filePathPtr:x);    Absolute or relative path to ini file
!#VA(sectionNamePtr:x); Section name in ini file.
!#VA(firstKeyPtr:x);    ... Up to 7 key, value pairs to write.
!#VA(firstValue:x);

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@firstValue);
  !!SN:F^ShowErmError^/^WriteIniInts: invalid arguments number. Expected at least %(@firstValue) arguments^;
  !!FU:E;
!!en;

!!VR(numKeyValueArgs:y):S(numArgs) -(@firstKeyPtr) +1;
!!VR(numPairs:y):S(numKeyValueArgs) :2;

!!VRt:S(numKeyValueArgs) %2;

!!if&t<>0;
  !!SN:F^ShowErmError^/^WriteIniInts: invalid arguments number. The last key-value pair is lack of value argument^;
  !!FU:E;
!!en;

!!re i/0/(numPairs)/1/-1;
  !!VR(keyArgInd:y):Si *2 +(@firstKeyPtr);
  !!VR(keyPtr:y):Sx(keyArgInd);
  !!VR(valueArgInd:y):S(keyArgInd) +1;

  !!SN:F^WriteStrToIni^/z(keyPtr)/^%x(valueArgInd)^/z(sectionNamePtr)/z(filePathPtr);
!!en;

!?FU(WriteIniStrings);
; Writes multiple string values to ini file in memory, but postpones saving data to disk. Call "SaveIni" to flush cached data.
; Example: P^Runtime/my mod.ini^/^custom hero names^/^%(HERO_ORRIN)^/^Perrin R^/^%(HERO_XERON)^/^Berson^;
!#VA(filePathPtr:x);    Absolute or relative path to ini file
!#VA(sectionNamePtr:x); Section name in ini file.
!#VA(firstKeyPtr:x);    ... Up to 7 key, value pairs to write.
!#VA(firstValue:x);

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@firstValue);
  !!SN:F^ShowErmError^/^WriteIniStrings: invalid arguments number. Expected at least %(@firstValue) arguments^;
  !!FU:E;
!!en;

!!VR(numKeyValueArgs:y):S(numArgs) -(@firstKeyPtr) +1;
!!VR(numPairs:y):S(numKeyValueArgs) :2;

!!VRt:S(numKeyValueArgs) %2;

!!if&t<>0;
  !!SN:F^ShowErmError^/^WriteIniStrings: invalid arguments number. The last key-value pair is lack of value argument^;
  !!FU:E;
!!en;

!!re i/0/(numPairs)/1/-1;
  !!VR(keyArgInd:y):Si *2 +(@firstKeyPtr);
  !!VR(keyPtr:y):Sx(keyArgInd);
  !!VR(valueArgInd:y):S(keyArgInd) +1;
  !!VR(valuePtr:y):Sx(valueArgInd);

  !!SN:F^WriteStrToIni^/z(keyPtr)/z(valuePtr)/z(sectionNamePtr)/z(filePathPtr);
!!en;

!?FU(ReadIniStrings);
; Reads multiple string values from ini file or from memory if ini file was read/written to earlier.
; Example: P(filePath)/(sectionName)/^%(HERO_ORRIN)^/?(orrinName:z)/^Orrin^/^%(HERO_XERON)^/?(xeronName:z)/^Xeron^;
!#VA(filePathPtr:x);    Absolute or relative path to ini file
!#VA(sectionNamePtr:x); Section name in ini file.
!#VA(firstKeyPtr:x);    ... Up to 4 (key, ?value, defaultValue) tripples to read.
!#VA(firstValue:x);
!#VA(firstValueDefault:x);

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@firstValueDefault);
  !!SN:F^ShowErmError^/^ReadIniStrings: invalid arguments number. Expected at least %(@firstValueDefault) arguments^;
  !!FU:E;
!!en;

!!VR(numVariadicArgs:y):S(numArgs) -(@firstKeyPtr) +1;
!!VR(numTripples:y):S(numVariadicArgs) :3;

!!VRt:S(numVariadicArgs) %3;

!!if&t<>0;
  !!SN:F^ShowErmError^/^ReadIniStrings: invalid arguments number. The last (key, value, default value) tripple is incomplete^;
  !!FU:E;
!!en;

!!re i/0/(numTripples)/1/-1;
  !!VR(keyArgInd:y):Si *3 +(@firstKeyPtr);
  !!VR(keyPtr:y):Sx(keyArgInd);
  !!VR(valueArgInd:y):S(keyArgInd) +1;
  !!VR(defValueArgInd:y):S(valueArgInd) +1;
  !!VR(defValuePtr:y):Sx(defValueArgInd);

  !!SN:F^ReadStrFromIni^/z(keyPtr)/z(sectionNamePtr)/z(filePathPtr)/?(valueStr:z);

  !!VR(valueStr)&(valueStr)=^^:Sz(defValuePtr);
  !!VRx(valueArgInd):Z(valueStr);
!!en;

!?FU(ReadIniInts);
; Reads multiple integer values from ini file or from memory if ini file was read/written to earlier.
; Example: P(filePath)/^hero levels^/^%(HERO_ORRIN)^/?(orrinLevel:y)/1/^%(HERO_XERON)^/?(xeronLevel:y)/1;
!#VA(filePathPtr:x);    Absolute or relative path to ini file
!#VA(sectionNamePtr:x); Section name in ini file.
!#VA(firstKeyPtr:x);    ... Up to 4 (key, ?value, defaultValue) tripples to read.
!#VA(firstValue:x);
!#VA(firstValueDefault:x);

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@firstValueDefault);
  !!SN:F^ShowErmError^/^ReadIniInts: invalid arguments number. Expected at least %(@firstValueDefault) arguments^;
  !!FU:E;
!!en;

!!VR(numVariadicArgs:y):S(numArgs) -(@firstKeyPtr) +1;
!!VR(numTripples:y):S(numVariadicArgs) :3;

!!VRt:S(numVariadicArgs) %3;

!!if&t<>0;
  !!SN:F^ShowErmError^/^ReadIniInts: invalid arguments number. The last (key, value, default value) tripple is incomplete^;
  !!FU:E;
!!en;

!!re i/0/(numTripples)/1/-1;
  !!VR(keyArgInd:y):Si *3 +(@firstKeyPtr);
  !!VR(keyPtr:y):Sx(keyArgInd);
  !!VR(valueArgInd:y):S(keyArgInd) +1;
  !!VR(defValueArgInd:y):S(valueArgInd) +1;
  !!VR(defValue:y):Sx(defValueArgInd);

  !!SN:F^ReadStrFromIni^/z(keyPtr)/z(sectionNamePtr)/z(filePathPtr)/?(valueStr:z);

  !!if&(valueStr)=^^;
    !!VRx(valueArgInd):S(defValue);
  !!el;
    !!VRx(valueArgInd):V(valueStr);
  !!en;
!!en;

!?FU(LoadIntGlobalsFromJson);
; Loads global mod/script settings from json config right into prefixed named global variables.
; Supports usage of any constant name instead of numbers in JSON. For example, you want to load
; json values "umt.randomizationIntervalDays" and "umt.playAltThemesSequently" to global variables
; i^umt_randomizationIntervalDays^ and i^umt_playAltThemesSequently^ and want to be able to write in json:
; "umt.playAltThemesSequently": "TRUE".
;
; Example: P^umt.^/^umt_^/^randomizationIntervalDays^/^playAltThemesSequently^;
!#VA(jsonKeysPrefixPtr:x);   Name of json keys prefix like ^mix.globals.^ for {"mix": {"globals": { ... }}}
!#VA(globalVarsPrefixPtr:x); Name of global variables prefix. Usually mod prefix like "mix_" or "umt_".
!#VA(firstKeyNamePtr:x);     ... Up to 14 json key names to read and convert into global variables

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@firstKeyNamePtr);
  !!SN:F^ShowErmError^/^LoadIntGlobalsFromJson: invalid arguments number^;
  !!FU:E;
!!en;

!!VR(numConfigKeys:y):S(numArgs) -(@firstKeyNamePtr) +1;

!!re i/0/(numConfigKeys)/1/-1;
  !!VR(configKeyPtr:y):S(@firstKeyNamePtr) +i Sx(configKeyPtr);
  !!VR(key:z):S^%z(jsonKeysPrefixPtr)%z(configKeyPtr)^;
  !!SN:T(key)/?(strValue:z);
  !!SN:C(strValue)/?(intValue:y)/?(constExists:y);

  !!if&(constExists)=(TRUE);
    !!VRi^%z(globalVarsPrefixPtr)%z(configKeyPtr)^:S(intValue);
  !!el&(key)<>(strValue);
    !!VR(intValue):V(strValue);
    !!VRi^%z(globalVarsPrefixPtr)%z(configKeyPtr)^:S(intValue);
  !!en;
!!en;

!?FU(ScanDir);
; Reads directory contents, filling specified list with file names.
; Example: P^Mp3^/(fileList)/(SCAN_FILES_ONLY);
!#VA(dirPathPtr:x); Absolute or relative path to directory to scan.
!#VA(fileList:x);   ID of array to store file names in.
!#VA(itemsType:x);  OPT. Type of items to collect: files, directories or both. One of SCAN_XXX constants. Default: SCAN_FILES_AND_DIRS.
!#VA(fullPaths:x);  OPT boolean. If true, result items will be have dirPath predended. Default: false.

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@fileList);
  !!SN:F^ShowErmError^/^ScanDir: invalid arguments number^;
  !!FU:E;
!!en;

!!VR(listSize:y):S-1;
!!SN:M(fileList)/?(listSize)/?(listItemsType:y)/d;
!!FU&(listSize)<0:E;

!!if&(listItemsType)<>(M_STR);
  !!SN:F^ShowErmError^/^ScanDir: expected list of strings to store file names^;
  !!FU:E;
!!en;

!!VR(savedV1:y):Sv1;
!#VA(foundData[SIZEOF_WIN32_FIND_DATA_IN_INTS]:y);

!!SN:M(fileList)/0;

!!SN:B?(foundData)/?(foundDataAddr:y);
!!VR(fileAttrsAddr:y):S(foundDataAddr) +(STRUCT_WIN32_FIND_DATA_ATTRS);
!!VR(fileNameBuf:y):S(foundDataAddr) +(STRUCT_WIN32_FIND_DATA_FILENAME);

!!SN:F^FindFirstFileA^/^%z(dirPathPtr)/*^/?(foundData);
!!VR(searchHandle:y):Sv1;
!!FU&(searchHandle)=(INVALID_HANDLE_VALUE):E;

!!re i;
  !!SN:B(fileNameBuf)/d/?(fileName:z);

  !!if&(fileName)<>^.^/(fileName)<>^..^;
    !!SN:B(fileAttrsAddr)/d/?(fileAttrs:y);
    !!VR(isDir:y):S(fileAttrs) &(FILE_ATTRIBUTE_DIRECTORY) F0/1;

    !!VR(itemMatches:y):S(TRUE);
    !!VR(itemMatches)&(itemsType)=(SCAN_FILES_ONLY)/(isDir)=(TRUE):S(FALSE);
    !!VR(itemMatches)&(itemsType)=(SCAN_DIRS_ONLY)/(isDir)=(FALSE):S(FALSE);

    !!if&(itemMatches)=(TRUE);
      !!VR(fileName)&(fullPaths)<>(FALSE):S^%z(dirPathPtr)/%(fileName)^;
      !!SN:M(fileList)/d1 V(fileList)/-1/(fileName);
    !!en;
  !!en;

  !!SN:F^FindNextFileA^/(searchHandle)/?(foundData);
  !!br&v1=0;
!!en; re

!!SN:F^FindClose^/(searchHandle);

!!VRv1:S(savedV1);
; ============== END FILE SYSTEM ==============


; ============== GAME PROCESS ==============
!?FU(SaveGame);
!#VA(fileNamePtr:x);     File name without extension to save game to.
!#VA(appendExtension:x); OPT boolean. If true, automatical extension will be appended to file name. Default: TRUE.
!#VA(compressFile:x);    OPT boolean. If true, saved file is gzipped. Otherwise the file is written without compression. Default: TRUE.
!#VA(saveToData:x);      OPT boolean. If true, saving is performed to Data directory instead of "Games" directory. Default: FALSE.
!#VA(markInList:x);      OPT boolean. If true, saved game will be marked in Save/Load dialogs as selected. Default: TRUE.

!!VR(savedV1:y):Sv1;
!!FU:A?(numArgs:y);

!!VR(appendExtension)&(numArgs)<(@appendExtension):S(TRUE);
!!VR(compressFile)&(numArgs)<(@compressFile):S(TRUE);
!!VR(markInList)&(numArgs)<(@markInList):S(TRUE);

!!UN:C(GAME_MANAGER)/(UNC_INT)/?(gameManager:y);
!!SN:E4975456/(CALLCONV_THISCALL)/(gameManager)/z(fileNamePtr)/(appendExtension)/1/(compressFile)/(saveToData);

!!SN&(markInList)<>(FALSE):F^lstrcpyA^/(ADDR_MARKED_SAVEGAME_NAME)/z(fileNamePtr);
!!VRv1:S(savedV1);
; ============ END GAME PROCESS ============


; ============== ERROR HANDLING ==============
!?FU(DisableErrors);
; Disables ERM error messages and resets error option.
!!UN:P(WOG_OPT_MUTE_ERRORS)/(TRUE) P(WOG_OPT_LAST_ERROR)/(FALSE);

!?FU(EnableErrors);
; Enables ERM error messages and returns last error flag (TRUE or FALSE).
!#VA(result:x);
!!UN:P(WOG_OPT_MUTE_ERRORS)/(TRUE) P(WOG_OPT_LAST_ERROR)/?(result);
; ============ END ERROR HANDLING ============


; =============== DIALOGS ===============
!?FU(H3Dlg_StopAnimation);
; Stops current dialogs animation
!!SN:E5864096/1;

!?FU(H3Dlg_ResumeAnimation);
; Resumes stopped dialogs animation
!!SN:E5864272/1;

!?FU(H3Dlg_ShowPopup);
; Shows H3 dialog as RMB popup.
!#VA(h3Dlg:x); H3 dialog object address

!!FU(H3Dlg_StopAnimation):P;
!!SN:E6245264/(CALLCONV_THISCALL)/(h3Dlg);
!!FU(H3Dlg_ResumeAnimation):P;

!?FU(H3Dlg_Coords);
; Allows to access H3 dialog display coordinates. Automatically fixed invalid coordinates.
!#VA(h3Dlg:x); H3 dialog object address.
!#VA(x:x);     X-coordinate, supports GET/SET/ADD syntax
!#VA(y:x);     Y-coordinate, supports GET/SET/ADD syntax

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@y);
  !!SN:F^ShowErmError^/^H3Dlg_Coords: invalid number of argumnets^;
  !!FU:E;
!!en;

!!if&(h3Dlg)=(NULL);
  !!SN:F^ShowErmError^/^H3Dlg_Coords: h3Dlg is NULL^;
  !!FU:E;
!!en;

!!FU:S(@x)/?(xSyntax:y) S(@y)/?(ySyntax:y);

!!UN:C(h3Dlg)/(STRUCT_H3DLG_X)/(UNC_INT)/?(origX:y);

!!if&(xSyntax)=(ARG_SYNTAX_GET);
  !!VR(x):S(origX);
!!el;
  !!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(dlgWidth:y);
  !!UN:C(ADDR_GAME_SCREEN_WIDTH)/(UNC_INT16)/?(gameScreenWidth:y);
  !!VR(maxX:y):S(gameScreenWidth) -(dlgWidth) -(DLG_BOX_SHADOW_WIDTH);

  !!VR(x)&(xSyntax)=(ARG_SYNTAX_ADD):+(origX);
  !!VR(x):F0/(maxX);

  !!UN:C(h3Dlg)/(STRUCT_H3DLG_X)/(UNC_INT)/(x);
!!en;

!!UN:C(h3Dlg)/(STRUCT_H3DLG_Y)/(UNC_INT)/?(origY:y);

!!if&(ySyntax)=(ARG_SYNTAX_GET);
  !!VR(y):S(origY);
!!el;
  !!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(dlgHeight:y);
  !!UN:C(ADDR_GAME_SCREEN_HEIGHT)/(UNC_INT16)/?(gameScreenHeight:y);
  !!VR(maxY:y):S(gameScreenHeight) -(dlgHeight) -(DLG_BOX_SHADOW_WIDTH);

  !!VR(y)&(ySyntax)=(ARG_SYNTAX_ADD):+(origY);
  !!VR(y):F0/(maxY);

  !!UN:C(h3Dlg)/(STRUCT_H3DLG_Y)/(UNC_INT)/(y);
!!en;

!?FU(H3Dlg_CenterAtMouse);
; Does place H3Dlg at mouse click pos and center it there

!#VA(h3Dlg:x); H3 dialog object address.
!!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(dlgWidth:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(dlgHeight:y);

!!SN:E5297920/(CALLCONV_STDCALL)/?(x:y)/?(y:y);
!!VR(dlgWidth):Sd>>1;
!!VR(dlgHeight):Sd>>1;
!!VR(x):-(dlgWidth);
!!VR(y):-(dlgHeight);
!!SN:E6289408/(CALLCONV_THISCALL)/(h3Dlg)/(x)/(y);


!?FU(H3Dlg_GetRootDlg);
; Returns root dialog object or NULL. Most of the time it's Adventure Map dialog.
!#VA(result:x);

!!UN:C(WND_MANAGER)/(UNC_INT)/?(wndMan:y) C(wndMan)/80/(UNC_INT)/?(result);

!?FU(H3Dlg_GetCurrentDlg);
; Returns topmost dialog object or NULL. It may be message box, custom dialog or any in-game dialog.
!#VA(result:x);

!!UN:C(WND_MANAGER)/(UNC_INT)/?(wndMan:y) C(wndMan)/84/(UNC_INT)/?(result);

!?FU(H3Dlg_GetCurrentDlgId);
; Returns topmost dialog unique ID (DLG_XXX constant). It may be message box, custom dialog or any in-game dialog.
!#VA(result:x);

!!UN:C(WND_MANAGER)/(UNC_INT)/?(wndMan:y) C(wndMan)/84/(UNC_INT)/?(result);

!!if&(result)<>(NULL);
  !!UN:C(result)/(UNC_INT)/?(vmt:y);
  !!UN:C(vmt)/(UNC_INT)/?(result);
!!en;

!?FU(H3Dlg_SendCmdToItem);
; Sends command to h3 dialog item like DL:A.
!#VA(h3Dlg:x);      H3 dialog object address.
!#VA(itemId:x);     Dialog item ID.
!#VA(cmdSubtype:x); Command subtype. See DLG_CMD_XXX constants.
!#VA(param:x);      User-specified value. Some numeric parameter or string in case of DLG_CMD_SET_TEXT.
!#VA(cmdType:x);    Optional. Type of command/action. Default: (DLG_CMD_TYPE_DEFAULT)

!!if&(h3Dlg)=(NULL);
  !!SN:F^ShowErmError^/^H3Dlg_SendCmdToItem: h3Dlg is NULL^;
  !!FU:E;
!!en;

!!FU:A?(numArgs:y);
!!VR(cmdType)&(numArgs)<(@cmdType):S(DLG_CMD_TYPE_DEFAULT);

!!VR(savedV1:y):Sv1;

!!if|(cmdSubtype)=(DLG_CMD_SET_TEXT)/(cmdSubtype)=(DLG_CMD_SET_DEF)/(cmdSubtype)=(DLG_CMD_SET_PCX);
  !!SN:E6288384/(CALLCONV_THISCALL)/(h3Dlg)/(cmdType)/(cmdSubtype)/(itemId)/z(param);
!!el;
  !!SN:E6288384/(CALLCONV_THISCALL)/(h3Dlg)/(cmdType)/(cmdSubtype)/(itemId)/(param);
!!en;

!!VRv1:S(savedV1);

!?FU(H3Dlg_DrawItemOnScreen);
; WoG function, drawing dialog item or the whole dialog on the screen.
!#VA(h3Dlg:x);
!#VA(itemId:x); Dialog item ID or (ALL_ITEMS).

!!if&(h3Dlg)=(NULL);
  !!SN:F^ShowErmError^/^H3Dlg_DrawItemOnScreen: h3Dlg is NULL^;
  !!FU:E;
!!en;

!!VR(dlgAddr:y):S(h3Dlg);
!!VR(savedV1:y):Sv1;
!!SN:E7510525/(CALLCONV_THISCALL)/?(dlgAddr)/(itemId);
!!VRv1:S(savedV1);

!?FU(H3Dlg_UpdateItemRange);
; Sends update command (0/0) to dialog items in specified range. Additionally forces dialog to update its internal state.
; Use the function after sending commands to native H3 dialogs and before trying to redraw them.
!#VA(h3Dlg:x);     H3 dialog object address
!#VA(minItemId:x); Minimal item ID to update
!#VA(maxItemId:x); Maximal item ID to update

!!if&(h3Dlg)=(NULL);
  !!SN:F^ShowErmError^/^H3Dlg_UpdateItemRange: h3Dlg is NULL^;
  !!FU:E;
!!en;

!!VR(savedV1:y):Sv1;
!!UN:C(h3Dlg)/(STRUCT_H3DLG_VTABLE)/(UNC_INT)/?(dlgVirtTable:y) C(dlgVirtTable)/20/(UNC_INT)/?(redrawDlgFunc:y);
!!SN:E(redrawDlgFunc)/(CALLCONV_THISCALL)/(h3Dlg)/0/200/200; 0 is drawVideoFrame?
!!VRv1:S(savedV1);

!?FU(DL_FindById);
; Returns DL dialog object address by DL id or (NULL) .
!#VA(dlgId:x);
!#VA(result:x);

!!SN:E7510739/1/(dlgId);
!!VR(result):Sv1;

!?FU(DL_Destroy);
; Destroys DL dialog object.
!#VA(dlgObj:x);

!!SN:E7518240/2/(dlgObj);

!?FU(DL_ShowPopup);
; Shows DL dialog as RMB popup.
; The dialog will be destroyed after showing. Call DL:N again to recreate it.
;  GrayFace
!#VA(dlgId:x); DL dialog ID.

!!VR(savedV1:y):Sv1;
!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)<>(NULL);
  !!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
  !!FU(H3Dlg_ShowPopup):P(h3Dlg);
  !!FU(DL_Destroy):P(dlgObj);
!!en;

!!VRv1:S(savedV1);

!?FU(DL_Coords);
; Allows to access DL-dialog display coordinates. Call DL:N before trying to access coordinates.
;  igrik
!#VA(dlgId:x); DL dialog ID
!#VA(x:x);     X-coordinate, supports GET/SET/ADD syntax
!#VA(y:x);     Y-coordinate, supports GET/SET/ADD syntax

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!FU:A?(numArgs:y);

!!if&(numArgs)<(@y);
  !!SN:F^ShowErmError^/^DL_Coords: invalid number of argumnets^;
  !!FU:E;
!!en;

!!if&(dlgObj)=(NULL);
  !!SN:F^ShowErmError^/^DL_Coords: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!FU:S(@x)/?(xSyntax:y) S(@y)/?(ySyntax:y);

!!FU(H3Dlg_Coords):P(h3Dlg)/?(origX:y)/?(origY:y);

!!VR(x)&(xSyntax)=(ARG_SYNTAX_GET):S(origX);
!!VR(x)&(xSyntax)=(ARG_SYNTAX_ADD):+(origX);
!!VR(y)&(ySyntax)=(ARG_SYNTAX_GET):S(origY);
!!VR(y)&(ySyntax)=(ARG_SYNTAX_ADD):+(origY);

!!FU(H3Dlg_Coords)|(xSyntax)<>(ARG_SYNTAX_GET)/(ySyntax)<>(ARG_SYNTAX_GET):P(h3Dlg)/(x)/(y);

!?FU(DL_GetSize);
; Returns DL-dialog width and height.
!#VA(dlgId:x);  DL dialog ID
!#VA(width:x);  OUT. Dialog width
!#VA(height:x); OUT. Dialog height

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)=(NULL);
  !!SN:F^ShowErmError^/^DL_GetSize: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(width);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(height);

!?FU(DL_SetSize);
; Changes DL-dialog width and height.
!#VA(dlgId:x);  DL dialog ID
!#VA(width:x);  Optional. Dialog width. 0 means "preserve as is".
!#VA(height:x); Optional. Dialog height. 0 means "preserve as is".

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)=(NULL);
  !!SN:F^ShowErmError^/^DL_SetSize: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!UN&(width)<>0:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/(width);
!!UN&(height)<>0:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/(height);

!?FU(DL_AlignDlg);
; Aligns dialog display position. Call DL:N before trying to use this function.
!#VA(dlgId:x);     DL dialog ID
!#VA(alignment:x); Bit-mask of TEXT_ALIGN_XXX constants.

!!FU(DL_FindById):P(dlgId)/?(dlgObj:y);

!!if&(dlgObj)=(NULL);
  !!SN:F^ShowErmError^/^DL_AlignDlg: DL-dialog %(dlgId) is not loaded^;
  !!FU:E;
!!en;

!!UN:C(dlgObj)/(UNC_INT)/?(h3Dlg:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_WIDTH)/(UNC_INT)/?(dlgWidth:y);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_HEIGHT)/(UNC_INT)/?(dlgHeight:y);
!!UN:C(ADDR_GAME_SCREEN_WIDTH)/(UNC_INT16)/?(gameScreenWidth:y);
!!UN:C(ADDR_GAME_SCREEN_HEIGHT)/(UNC_INT16)/?(gameScreenHeight:y);

!!VR(alignCenter:y):S(alignment) &(TEXT_ALIGN_CENTER);
!!VR(alignRight:y):S(alignment) &(TEXT_ALIGN_RIGHT);
!!VR(alignMiddle:y):S(alignment) &(TEXT_ALIGN_MIDDLE);
!!VR(alignBottom:y):S(alignment) &(TEXT_ALIGN_BOTTOM);

!!VR(x:y):S0;

!!if&(alignCenter)<>(FALSE);
  !!VR(x):S(gameScreenWidth) -(dlgWidth) :2;
!!el&(alignRight)<>(FALSE);
  !!VR(x):S(gameScreenWidth) -(dlgWidth);
!!en;

!!VR(y:y):S0;

!!if&(alignMiddle)<>(FALSE);
  !!VR(y):S(gameScreenHeight) -(dlgHeight) :2;
!!el&(alignBottom)<>(FALSE);
  !!VR(y):S(gameScreenHeight) -(dlgHeight);
!!en;

!!UN:C(h3Dlg)/(STRUCT_H3DLG_X)/(UNC_INT)/(x);
!!UN:C(h3Dlg)/(STRUCT_H3DLG_Y)/(UNC_INT)/(y);

!?FU(ClearScreenLog);
; Clears green screen log messages
!!VR(savedV1:y):Sv1;
!!SN:E5588144/2/6936576;
!!VRv1:S(savedV1);

!?FU(AdvMap_SetHint);
; Immediately shows adventure map hint with new text. Chat box text may become hidden until new character input.
!#VA(newHint:x); New hint string.

!!FU(H3Dlg_GetRootDlg):P?(rootDlg:y);
!!FU&(rootDlg)=(NULL):E;

!!UN:C(rootDlg)/(STRUCT_H3DLG_VTABLE)/(UNC_INT)/?(virtTable:y) C(virtTable)/(UNC_INT)/?(dlgId:y);
!!FU&(dlgId)<>(DLG_ADVMAP):E;

!!FU(H3Dlg_SendCmdToItem):P(rootDlg)/(ITEM_ADVMAP_HINT)/(DLG_CMD_SET_TEXT)/z(newHint);
!!FU(H3Dlg_UpdateItemRange):P(rootDlg)/(ITEM_ADVMAP_HINT)/(ITEM_ADVMAP_HINT);
!!FU(H3Dlg_DrawItemOnScreen):P(rootDlg)/(ITEM_ADVMAP_HINT);

!#DC(NO_RADIO_DLG_ITEM)         = -1;
!#DC(RADIO_DLG_MAX_ITEMS)       = 12;
!#DC(RADIO_DLG_FLAG_BTN_CANCEL) = 1;

!#SN:M(M_AUTO_ID)/(RADIO_DLG_MAX_ITEMS)/(M_STR)/(M_STORED)/?i^radioDlg_captions^;
!#SN:M(M_AUTO_ID)/0/(M_STR)/(M_STORED)/?i^radioDlg_tags^;
!#SN:M(M_AUTO_ID)/0/(M_INT)/(M_STORED)/?i^radioDlg_values^;

!#VRs^radioDlg_title^:S^^;
!#VRi^radioDlg_numItems^:S0;
!#VRi^radioDlg_selectedItemInd^:S0;
!#VRi^radioDlg_flags^:S0;
!#VRi^radioDlg_freeSpaceAlerted^:S(FALSE);

!?FU(RadioDlg_Reset);
; Resets all radio dialog settings to empty values.
!!SN:Mi^radioDlg_captions^/0 Mi^radioDlg_captions^/(RADIO_DLG_MAX_ITEMS);
!!SN:Mi^radioDlg_tags^/0;
!!SN:Mi^radioDlg_values^/0;

!!VRs^radioDlg_title^:S^^;
!!VRi^radioDlg_numItems^:S0;
!!VRi^radioDlg_selectedItemInd^:S(NO_RADIO_DLG_ITEM);
!!VRi^radioDlg_flags^:S0;
!!VRi^radioDlg_freeSpaceAlerted^:S(FALSE);

!?FU(RadioDlg_SetTitle);
; Changes radio dialog title.
!#VA(titlePtr:x); New dialog title.

!!VRs^radioDlg_title^:Sz(titlePtr);

!?FU(RadioDlg_AddCancelButton);
; Adds cancel button to dialog. Decreases maximum number of items in dialog by one.
!!VR(hasCancelBtn:y):Si^radioDlg_flags^ &(RADIO_DLG_FLAG_BTN_CANCEL) F(FALSE)/(TRUE);
!!FU&(hasCancelBtn)<>(FALSE):E;

; Always add cancel button, removing the last item if necessary
!!VRi^radioDlg_flags^:|(RADIO_DLG_FLAG_BTN_CANCEL);

!!VR(numFreeItems:y):S(RADIO_DLG_MAX_ITEMS) -i^radioDlg_numItems^;

!!if&(numFreeItems)<=0;
  !!SN&i^radioDlg_freeSpaceAlerted^=(FALSE):F^ShowErmError^/^RadioDlg_AddCancelButton: cannot add cancel button, there is no free position for it^;
  !!VRi^radioDlg_freeSpaceAlerted^:S(TRUE);
  !!VRi^radioDlg_numItems^:-1;
!!en;

!?FU(RadioDlg_SelectItem);
; Sets new selected item by its index.
!#VA(itemInd:x);

!!VRi^radioDlg_selectedItemInd^:S(NO_RADIO_DLG_ITEM);
!!VRi^radioDlg_selectedItemInd^&(itemInd)>=0/(itemInd)<i^radioDlg_numItems^:S(itemInd);

!?FU(RadioDlg_SelectItemByValue);
; Finds the first item with specified value and selects it.
!#VA(itemValue:x);

!!VR(newItemInd:y):S(NO_RADIO_DLG_ITEM);

!!re i/0/i^radioDlg_numItems^/1/-1;
  !!SN:Vi^radioDlg_values^/i/?(value:y);

  !!if&(value)=(itemValue);
    !!VR(newItemInd):Si;
    !!br;
  !!en;
!!en;

!!VRi^radioDlg_selectedItemInd^:S(newItemInd);

!?FU(RadioDlg_SelectItemByTag);
; Finds the first item with specified tag and selects it.
!#VA(itemTagPtr:x); Tag string

!!VR(newItemInd:y):S(NO_RADIO_DLG_ITEM);

!!re i/0/i^radioDlg_numItems^/1/-1;
  !!SN:Vi^radioDlg_tags^/i/?s^temp^;

  !!if&s^temp^=z(itemTagPtr);
    !!VR(newItemInd):Si;
    !!br;
  !!en;
!!en;

!!VRs^temp^:S^^;
!!VRi^radioDlg_selectedItemInd^:S(newItemInd);

!?FU(RadioDlg_AddItem);
; Adds new item to radio dialog.
!#VA(itemCaptionPtr:x); Optional. New item caption. Empty/spacy captions are valid. Default: ^^.
!#VA(itemValue:x);      Optional. Numeric value, associated with item. Default: 0.
!#VA(itemTagPtr:x);     Optional. String tag, associated with item. Default: ^^.
!#VA(selectItem:x);     Optional. Boolean. If TRUE, item will be selected. Default: FALSE.

!!VR(hasCancelBtn:y):Si^radioDlg_flags^ &(RADIO_DLG_FLAG_BTN_CANCEL) F(FALSE)/(TRUE);
!!VR(numFreeItems:y):S(RADIO_DLG_MAX_ITEMS) -i^radioDlg_numItems^ -(hasCancelBtn);

!!if&(numFreeItems)<=0;
  !!SN&i^radioDlg_freeSpaceAlerted^=(FALSE):F^ShowErmError^/^RadioDlg_AddItem: cannot add new items, there is no free position^;
  !!VRi^radioDlg_freeSpaceAlerted^:S(TRUE);
  !!FU:E;
!!en;

!!VR(emptyStr:z):S^^;
!!VR(blankItemStr:z):S^-/-^;
!!VR(itemCaptionPtr)|(itemCaptionPtr)=(NULL)/z(itemCaptionPtr)=^^:S(@blankItemStr);
!!VR(itemTagPtr)&(itemTagPtr)=(NULL):S(@emptyStr);
!!VR(selectItem):F(FALSE)/(TRUE);

!!SN:Vi^radioDlg_captions^/i^radioDlg_numItems^/z(itemCaptionPtr);
!!SN:Mi^radioDlg_tags^/d1 Vi^radioDlg_tags^/-1/z(itemTagPtr);
!!SN:Mi^radioDlg_values^/d1 Vi^radioDlg_values^/-1/(itemValue);

!!VRi^radioDlg_selectedItemInd^&(selectItem)<>(FALSE):Si^radioDlg_numItems^;
!!VRi^radioDlg_numItems^:+1;

!?FU(RadioDlg_AddItems);
; Adds up to 5 items to radio dialog. For detailed arguments description see (RadioDlg_AddItem).
!#VA(firstItemCaptionPtr:x);
!#VA(firstItemValue:x);
!#VA(firstItemTagPtr:x);

!!FU:A?(numArgs:y);
!!VR(numItems:y):S(numArgs) :3;
!!FU&(numItems)<=0:E;

!!re i/0/(numItems)/1/-1;
  !!VR(argCaptionPtr:y):Si *3 +(@firstItemCaptionPtr);
  !!VR(argValuePtr:y):  Si *3 +(@firstItemValue);
  !!VR(argTagPtr:y):    Si *3 +(@firstItemTagPtr);
  !!FU(RadioDlg_AddItem):Px(argCaptionPtr)/x(argValuePtr)/x(argTagPtr);
!!en;

!?FU(RadioDlg_GetNumItems);
; Returns number of items, added to dialog
!#VA(result:x);

!!VR(result):Si^radioDlg_numItems^;

!?FU(RadioDlg_GetItemValue);
; Returns value of specified item or throws error in case of invalid index.
!#VA(itemInd:x);
!#VA(result:x);

!!if|(itemInd)<0/(itemInd)>=i^radioDlg_numItems^;
  !!VR(result):S-1;
  !!SN:F^ShowErmError^/^RadioDlg_GetItemValue: invalid item index %(itemInd). Found %i(radioDlg_numItems) items in dialog^;
  !!FU:E;
!!el;
  !!SN:Vi^radioDlg_values^/(itemInd)/?(result);
!!en;

!?FU(RadioDlg_GetItemTag);
; Returns tag of specified item or throws error in case of invalid index.
!#VA(itemInd:x);
!#VA(result:x);

!!if|(itemInd)<0/(itemInd)>=i^radioDlg_numItems^;
  !!VR(result):S-1;
  !!SN:F^ShowErmError^/^RadioDlg_GetItemTag: invalid item index %(itemInd). Found %i(radioDlg_numItems) items in dialog^;
  !!FU:E;
!!el;
  !!SN:Vi^radioDlg_tags^/(itemInd)/?s^temp^;
  !!VR(result):Zs^temp^;
  !!VRs^temp^:S^^;
!!en;

!?FU(RadioDlg_Show);
; Display previously configured radio dialog with single possible choice.
; Currently maximum RADIO_DLG_MAX_ITEMS (-1 for cancel button) items can be added to the dialog.
; Returns selected item index, value and tag. Item index is (NO_RADIO_DLG_ITEM) if no items are present for selection
; or Cancel button was pressed.
!#VA(resultItem:x);   Default: (NO_RADIO_DLG_ITEM).
!#VA(resultValue:x);  Default: -1.
!#VA(resultTagPtr:x); Default: ^^.

!!VR(resultItem):S(NO_RADIO_DLG_ITEM);
!!VR(resultValue):S-1;
!!VR(emptyStr:z):S^^;
!!VR(resultTagPtr):S(@emptyStr);

!!VR(numItems:y):Si^radioDlg_numItems^;
!!FU&(numItems)<=0:E;

!!FU(NewStrArray):P?(captions:y);
!!FU(Array_Copy):Pi^radioDlg_captions^/(captions);
!!FU(NewStrArray):P?(tags:y);
!!FU(Array_Copy):Pi^radioDlg_tags^/(tags);
!!FU(NewIntArray):P?(values:y);
!!FU(Array_Copy):Pi^radioDlg_values^/(values);

!!VR(titlePtr:y):Zs^radioDlg_title^;
!!VR(flags:y):Si^radioDlg_flags^;
!!VR(selectedItemInd:y):Si^radioDlg_selectedItemInd^;

!!VR(hasCancelBtn:y):S(flags) &(RADIO_DLG_FLAG_BTN_CANCEL) F(FALSE)/(TRUE);

!!if&(selectedItemInd)=(NO_RADIO_DLG_ITEM);
  !!if&(hasCancelBtn)<>(FALSE);
    !!VR(selectedItemInd):S(numItems);
  !!el;
    !!VR(selectedItemInd):S0;
  !!en;
!!en;

!!VR(selectionMask:y):S1 Sd<<(selectedItemInd);
!!SN&(hasCancelBtn)<>(FALSE):V(captions)/(numItems)/^%T(era.buttons.cancel)^;

!#VA(itemCaptions[RADIO_DLG_MAX_ITEMS]:y);

!!re i/0/(itemCaptions[SIZE])/1/-1;
  !!SN:V(captions)/i/?s^temp^;
  !!VR(itemCaptions[i]):Zs^temp^;
!!en;

!!VR(savedV1:y):Sv1;
!!IF:G(TRUE)/1/(selectionMask)/z(titlePtr)/z(itemCaptions[0])/z(itemCaptions[1])/z(itemCaptions[2])/z(itemCaptions[3])/
                                           z(itemCaptions[4])/z(itemCaptions[5])/z(itemCaptions[6])/z(itemCaptions[7])/
                                           z(itemCaptions[8])/z(itemCaptions[9])/z(itemCaptions[10])/z(itemCaptions[11]);
!!VR(selectionMask):Sv1;
!!VRv1:S(savedV1);

!!FU(IntLog2):P(selectionMask)/?(resultItem);

!!if&(hasCancelBtn)<>(FALSE)/(resultItem)=(numItems);
  !!VR(resultItem):S(NO_RADIO_DLG_ITEM);
!!el;
  !!SN:V(values)/(resultItem)/?(resultValue);
  !!SN:V(tags)/(resultItem)/?s^temp^;
  !!VR(resultTagPtr):Zs^temp^;
!!en;

!!VRs^temp^:S^^;

!?FU(PrepareMultiPicDialog);
; Initializes IF:N dialog pictures. Call IF:N to show it afterwards.
; Automatically skips pairs with NO_PIC_TYPE type and pairs with PIC_TYPE_MONSTER type and negative subtype.
; Ignores more than 8 non-empty pairs. Always safe to call.
;
; Supports three call syntaxes:
;   P; dialog without pictures
;   P(first picture type)/(first picture subtype)/(second picture type)...
;   P(ID of dynamical array, containing picture pairs)
!#VA(firstArg:x);

!!FU:A?(numArgs:y);

!!if&(numArgs)<=0;
  ; SYNTAX: P; dialog without pictures
  !!IF:N(NO_PIC_TYPE)/(NO_PIC_TYPE)/(NO_PIC_TYPE)/(NO_PIC_TYPE);
  !!FU:E;
!!en;

; Define and reset dialog parameters array
!#VA(params[16]:y);

!!re i/0/(params[SIZE])/1/-1;
  !!VR(params[i]):S(NO_PIC_TYPE);
!!en;

!!VR(paramPtr:y):S(@params);

!!if&(numArgs)>1;
  ; SYNTAX: P(first picture type)/(first picture subtype)/(second picture type)...
  !!VR(numPicPairs:y):S(numArgs) :2;
  !!VR(argPtr:y):S(@firstArg);

  !!re i/0/(numPicPairs)/1/-1;
    !!VR(picType:y):Sx(argPtr);
    !!VR(argPtr):+1;
    !!VR(picValue:y):Sx(argPtr);
    !!VR(argPtr):+1;

    !!if&(picType)<>(NO_PIC_TYPE);
      !!if|(picType)<>(PIC_TYPE_MONSTER)/(picValue)>=(MON_FIRST);
        !!VRy(paramPtr):S(picType);
        !!VR(paramPtr):+1;
        !!VRy(paramPtr):S(picValue);
        !!VR(paramPtr):+1;
      !!en;
    !!en;
  !!en;
!!el;
  ; SYNTAX: P(ID of dynamical array, containing picture pairs)
  !!VR(dlgPicList:y):S(firstArg);
  !!SN:M(dlgPicList)/?(picListSize:y);
  !!VR(numPicPairs:y):S(picListSize) :2;

  !!VR(argInd:y):S0;

  !!re i/0/(numPicPairs)/1/-1;
    !!SN:V(dlgPicList)/(argInd)/?(picType:y)/?(picValue:y);

    !!if&(picType)<>(NO_PIC_TYPE);
      !!if|(picType)<>(PIC_TYPE_MONSTER)/(picValue)>=(MON_FIRST);
        !!VRy(paramPtr):S(picType);
        !!VR(paramPtr):+1;
        !!VRy(paramPtr):S(picValue);
        !!VR(paramPtr):+1;

        !!br&(paramPtr)>(@params[-1]);
      !!en;
    !!en;

    !!VR(argInd):+2;
  !!en;
!!en;

!!IF:N(params[0])/(params[1])/(params[2])/(params[3])/(params[4])/(params[5])/(params[6])/(params[7])/
      (params[8])/(params[9])/(params[10])/(params[11])/(params[12])/(params[13])/(params[14])/(params[15]);

!?FU(ShowAnimatedDefDlg);
; Displays message dialog with OK button, text and leading animated def.
!#VA(textPtr:x);    Text to show
!#VA(defNamePtr:x); Optional. Name of def to show animation for or empty string.

!!if|(defNamePtr)=0/z(defNamePtr)=^^;
  !!IF:M1/z(textPtr);
!!el;
  !!SN:E7814514/(CALLCONV_CDECL)/z(textPtr)/z(defNamePtr);
!!en;

; ============= END DIALOGS =============


; =============== BATTLE ===============
!?FU(BattleStack_Shoot);
; Forces one stack to shoot at another one.
!#VA(attackerStackId:x) (defenderStackId:x);
!!BM(attackerStackId):Z?(attackerStackStruct:y);
!!BM(defenderStackId):Z?(defenderStackStruct:y);
!!SN:E4453920/(CALLCONV_THISCALL)/(attackerStackStruct)/(defenderStackStruct);

!?FU(BattleStack_MakeActive);
; Makes specified stack active/acting.
!#VA(stackId:x); Stack ID to pass control to.

!!if|(stackId)<0/(stackId)>=(BATTLE_MAX_STACKS);
  !!SN:F^ShowErmError^/^Invalid stack ID. Got: %(stackId). Expected 0..41^;
  !!FU:E;
!!en;

!!VR(stackSide:y):S(stackId) :(BATTLE_STACKS_PER_SIDE);
!!VR(stackInd:y):S(stackId) %(BATTLE_STACKS_PER_SIDE);
!!UN:C(COMBAT_MANAGER)/(UNC_INT)/?(combatMan:y);
!!SN:E4607760/(CALLCONV_THISCALL)/(combatMan)/(stackSide)/(stackInd);

!?FU(ActivateNextStack);
; Finds and activates next stack. Returns TRUE on success and FALSE if nobody can move in this phase.
; TRUE is returned before round end and before waiting phase start.
!#VA(result:x);

!!UN:C(COMBAT_MANAGER)/4/?(combatManager:y);
!!VR(savedV1:y):Sv1;
!!SN:E4607072/(CALLCONV_THISCALL)/(combatManager)/(TRUE);
!!VR(result)&(result)<>0:Sv1 &(BITS_1_MASK);
!!VRv1:S(savedV1);

!?FU(UpdateBattleVars);
; Updates global variables with most of "OnBeforeBattle/Universal" event parameters.
; Call this function if you change anything, except monsters, via BA command.
!!BA:Q?i^battle_isQuick^ P?i^battle_x^/?i^battle_y^/?i^battle_z^;
!!BA:O?i^battle_owner_0^/?i^battle_owner_1^;
!!BA:H0/?i^battle_hero_0^ H1/?i^battle_hero_1^;

; Replace invalid defender hero values like (NO_DEFENDING_HERO) with normalized (NO_HERO)
!!VRi^battle_hero_vs_hero^:S(TRUE);

!!if&i^battle_hero_1^<(HERO_FIRST);
  !!VRi^battle_hero_1^:S(NO_HERO);
  !!VRi^battle_hero_vs_hero^:S(FALSE);
!!en;

!!VRi^battle_ai_0^:S(TRUE);
!!VRi^battle_ai_1^:S(TRUE);
!!VRi^battle_remote_0^:S(FALSE);
!!VRi^battle_remote_1^:S(FALSE);

!!if&i^battle_owner_0^<>(NO_OWNER);
  !!OW:Ii^battle_owner_0^/?i^battle_ai_0^ Gi^battle_owner_0^/?(isLocalHuman:y);
  !!VRi^battle_remote_0^&i^battle_ai_0^=(FALSE)/(isLocalHuman)=(FALSE):S(TRUE);
!!en;

!!if&i^battle_owner_1^<>(NO_OWNER);
  !!OW:Ii^battle_owner_1^/?i^battle_ai_1^ Gi^battle_owner_1^/?(isLocalHuman:y);
  !!VRi^battle_remote_1^&i^battle_ai_1^=(FALSE)/(isLocalHuman)=(FALSE):S(TRUE);
!!en;

!!VRi^battle_local_0^:S(TRUE) Xi^battle_remote_0^;
!!VRi^battle_local_1^:S(TRUE) Xi^battle_remote_1^;
!!VRi^battle_human_0^:S(TRUE) Xi^battle_ai_0^;
!!VRi^battle_human_1^:S(TRUE) Xi^battle_ai_1^;
!!VRi^battle_localHuman_0^:Si^battle_local_0^ &i^battle_human_0^;
!!VRi^battle_localHuman_1^:Si^battle_local_1^ &i^battle_human_1^;

!!VRi^battle_hasHuman^:S(FALSE);
!!VRi^battle_hasHuman^|i^battle_human_0^<>(FALSE)/i^battle_human_1^<>(FALSE):S(TRUE);

!!VRi^battle_humanOnly^:Si^battle_human_0^ &i^battle_human_1^;
!!if&i^battle_humanOnly^;                                                            [fix variable when player can can have quick combat option is enbaled]
  !!VRi^battle_isQuick^:S(FALSE);
!!en;
!!VRi^battle_aiOnly^:Si^battle_ai_0^ &i^battle_ai_1^;
!!VRi^battle_isVisible^:Si^battle_aiOnly^ |i^battle_isQuick^ X(TRUE);
!!VRi^battle_isNetwork^:Si^battle_remote_0^ |i^battle_remote_1^;

!!VR(battleType:y):S0;
!!VR(battleType)&i^battle_human_0^<>(FALSE):    |(BATTLE_TYPE_FLAG_LEFT_IS_HUMAN);
!!VR(battleType)&i^battle_human_1^<>(FALSE):    |(BATTLE_TYPE_FLAG_RIGHT_IS_HUMAN);
!!VR(battleType)&i^battle_owner_0^<>(NO_OWNER): |(BATTLE_TYPE_FLAG_LEFT_HAS_OWNER);
!!VR(battleType)&i^battle_owner_1^<>(NO_OWNER): |(BATTLE_TYPE_FLAG_RIGHT_HAS_OWNER);
!!VR(battleType)&i^battle_hero_0^<>(NO_HERO):   |(BATTLE_TYPE_FLAG_LEFT_HAS_HERO);
!!VR(battleType)&i^battle_hero_1^<>(NO_HERO):   |(BATTLE_TYPE_FLAG_RIGHT_HAS_HERO);
!!VRi^battle_type^:S(battleType);

!?FU(OnBattleReplay);
!!VRi^battle_round^:S(INT_MIN);
!!FU(UpdateBattleVars):P;
; ============= END BATTLE =============


; ============== TIME ==============
!?FU(GetTimeMsec);
; Returns current time in milliseconds (time from computer start, overflowing each 49.71 days)
!#VA(result:x);
!!UN:C6529876/(UNC_INT)/?(timeGetTime:y);
!!VR(savedV1:y):Sv1;
!!SN:E(timeGetTime)/(CALLCONV_STDCALL);
!!VR(result):Sv1;
!!VRv1:S(savedV1);
; ============ END TIME ============


; ============== UTILITIES ==============
!?FU(GetProcessGuid);
; Returns unique 32-character ID of game process run. Each game process start will generate different value.
; Modders can use this value to check, whether player restarted the game process or not.
!#VA(result:x);

!!VR(savedV1:y):Sv1;
!!SN:F^GetProcessGuid^/?(processGuid:z);
!!VR(result):Z(processGuid);
!!VRv1:S(savedV1);

!?FU(IsDllLoaded);
; Returns (TRUE) is specified DLL is loaded. The check is fast and does not lead to loading dll.
!#VA(dllFileNamePtr:x); DLL file name with extension (*.dll, *.era, *.ani, etc).
!#VA(result:x);         Boolean. (TRUE) if DLL is loaded.

!!VR(savedV1:y):Sv1;
!!SN:F^GetModuleHandleA^/z(dllFileNamePtr);
!!VR(result):S(FALSE);
!!VR(result)&v1<>(NULL):S(TRUE);
!!VRv1:S(savedV1);
; ============ END UTILITIES ============


; ============== MONSTERS ==============
!?FU(MonCountToFuzzyText);
; Converts monster quantity to stringish value range like "50-99" or "2K+" with maximum length restriction.
; Example P777/?{result}/(MON_FUZZY_COUNT_SHORT) => "500-999".
!#VA(monNum:x);         Number of monsters to convert to text.
!#VA(resultPtr:x);      OUT. Result string
!#VA(maxTextLength:x);  Optional. Result length restriction in the form of MON_FUZZY_COUNT_XXX constant. Default: MON_FUZZY_COUNT_SHORT

!!if&(monNum)<0;
  !!SN:F^ShowErmError^/^MonCountToFuzzyText: negative monster quantity %(monNum)^;
  !!FU:E;
!!en;

!!VR(h3HintsBaseAddr:y):S6970400;
!!VR(rangeInd:y):-1;

!!if&(monNum)<=4;
  !!VRs^result^:S^1-4^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S0;
!!el&(monNum)<=9;
  !!VRs^result^:S^5-9^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S1;
!!el&(monNum)<=19;
  !!VRs^result^:S^10-19^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S2;
!!el&(monNum)<=49;
  !!VRs^result^:S^20-49^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S3;
!!el&(monNum)<=99;
  !!VRs^result^:S^50-99^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S4;
!!el&(monNum)<=249;
  !!VRs^result^:S^100-249^;
  !!VRs^result^&(maxTextLength)=(MON_FUZZY_COUNT_EXTRA_SHORT):S^100+^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S5;
!!el&(monNum)<=499;
  !!VRs^result^:S^250-499^;
  !!VRs^result^&(maxTextLength)=(MON_FUZZY_COUNT_EXTRA_SHORT):S^250+^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S6;
!!el&(monNum)<=999;
  !!VRs^result^:S^500-999^;
  !!VRs^result^&(maxTextLength)=(MON_FUZZY_COUNT_EXTRA_SHORT):S^500+^;
  !!VR(rangeInd)&(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY):S7;
!!el&(monNum)<2000/(maxTextLength)=(MON_FUZZY_COUNT_HUMAN_FRIENDLY);
  !!VR(rangeInd):S8;
!!el&(monNum)<1000000;
  !!VR(thousandInd:y):S(monNum) :1000;
  !!FU(IntLog2):P(thousandInd)/?(thousandPower:y);
  !!VR(borderValue:y):S1 Sd<<(thousandPower) *1000 -1;
  !!VR(thousandPower)&(monNum)<=(borderValue):-1;
  !!VR(rangeStart:y):S1 Sd<<(thousandPower);
  !!VRs^result^:S^%(rangeStart)K+^;
!!el;
  !!VR(billionInd:y):S(monNum) :1000000;
  !!FU(IntLog2):P(billionInd)/?(billionPower:y);
  !!VR(borderValue:y):S1 Sd<<(billionPower) *1000000 -1;
  !!VR(borderValue)&(borderValue)<0:S(INT_MAX);
  !!VR(billionPower)&(monNum)<=(borderValue):-1;
  !!VR(rangeStart:y):S1 Sd<<(billionPower);
  !!VRs^result^:S^%(rangeStart)M+^;
!!en;

!!if&(rangeInd)<>-1;
  !!VRf:S(rangeInd) *(SIZEOF_INT) *3 +(SIZEOF_INT) +(h3HintsBaseAddr);
  !!UN:Cf/(SIZEOF_PTR)/?(strAddr:y);
  !!SN:B(strAddr)/d/?s^result^;
!!en;

!!VR(resultPtr):Zs^result^;
!!VRs^result^:S^^;

!?FU(GetMaxMonsterId);
; Returns ID of the last supported monster in game. Some plugins, extending creature limit, add many blank
; monsters, resulting in max ID = 9999, for instance.
!#VA(result:x);

!!UN:C4855383/(UNC_INT)/?(result);
!!VR(result):-1;

!?FU(GetUpgradedMonster);
; Returns ID of upgraded monster or NO_MON if no upgrade exists.
!#VA(monId:x);  ID of monster to get upgrade for.
!#VA(result:x); OUT. ID of upgraded monster or -1.

!!VR(savedV1:y):Sv1;
!!SN:E7662803/(CALLCONV_CDECL)/(monId);
!!VR(result):Sv1;
!!VRv1:S(savedV1);

!?FU(GetDegradedMonCandidates);
; Returns temporary list of all monsters, which can be upgraded to specified monster.
; There may exist multiple monster, upgrading to the same type. Function performance is low.
!#VA(monId:x);        Upgraded monster ID.
!#VA(degradesList:x); ID of temporary SN:M array with degraded monster candidates.

!!SN:M(M_AUTO_ID)/0/(M_INT)/(M_TRIGGER_LOCAL)/?(degradesList) F^ExtendArrayLifetime^/(degradesList);
!!FU(GetMaxMonsterId):P?(lastMonsterId:y);

!!re i/(MON_FIRST)/(lastMonsterId);
  !!FU(GetUpgradedMonster):Pi/?(upgradedMonId:y);
  !!SN&(upgradedMonId)=(monId):M(degradesList)/d1 V(degradesList)/-1/i;
!!en;
; ============ END MONSTERS ============


; ============== HEROES ==============
!?FU(GetMaxHeroId);
; Returns ID of the last supported hero in game.
!#VA(result:x);

!!UN:C4960750/(UNC_INT)/?(result);
!!VR(result):-1;
; ============ END HEROES ============


; ============== ARTIFACTS ==============
!?FU(GetHeroPrimarySkillsWithoutArts);
; Returns hero real primary skills without artifacts. Unequips all artifacts to get values and reequipts afterwards,
; thus triggering OnEquipArt and OnUnequipArt events.
!#VA(hero:x);      Hero ID or (CURRENT_HERO).
!#VA(attack:x);    Out. Attack value.
!#VA(defense:x);   Out. Defense value.
!#VA(power:x);     Out. Power value.
!#VA(knowledge:x); Out. Knowledge value.

!#VA(equippedArts[19]:y);
!#VA(equippedArtMods[19]:y);

!!re (slot:y)/0/(equippedArts[SIZE])/1/-1;
  !!FU(GetArtAtSlot):P(hero)/(slot)/?(art:y)/?(artMod:y);
  !!VR(equippedArts[slot]):S(NO_ART);
  !!VR(equippedArtMods[slot]):S(artMod);

  !!if&(art)<>(ART_HIGHLIGHTED_SLOT)/(art)<>(ART_ARTIFACT_LOCK);
    !!VR(equippedArts[slot]):S(art);
    !!FU(UnequipArtFromSlot):P(hero)/(slot);
  !!en;
!!en;

!!HE(hero):F?(attack)/?(defense)/?(power)/?(knowledge);

!!re (slot:y)/0/(equippedArts[SIZE])/1/-1;
  !!VR(art):S(equippedArts[slot]);
  !!FU(EquipArtToSlot)&(art)<>(NO_ART):P(hero)/(art)/(equippedArtMods[slot])/(slot);
!!en;

!?FU(GetArtAtSlot);
; Returns hero artifact and artifact modifier at given slot.
!#VA(hero:x);   Hero ID or (CURRENT_HERO)
!#VA(slot:x);   Slot ID (backpack is supported).
!#VA(artId:x);  OUT. Artifact ID.
!#VA(artMod:x); OUT. Artifact modifier.

!!HE(hero):Z?(heroStruct:y);

!!if|(slot)<(ART_SLOT_FIRST)/(slot)>(ART_SLOT_LAST);
  !!SN:F^ShowErmError^/^GetArtAtSlot: invalid artifact slot ID: %(slot)^;
  !!FU:E;
!!en;

!!if&(slot)>=(ART_SLOT_EQUIPPED_FIRST)/(slot)<=(ART_SLOT_EQUIPPED_LAST);
  !!VR(artHandlePtr:y):+S(slot) *8 +301 +(heroStruct);
!!el;
  !!VR(artHandlePtr:y):+S(slot) -(ART_SLOT_EQUIPPED_LAST) -1 *8 +468 +(heroStruct);
!!en;

!!UN:C(artHandlePtr)/0/(UNC_INT)/?(artId);
!!UN:C(artHandlePtr)/4/(UNC_INT)/?(artMod);

!?FU(ChangeArtModAtSlot);
; Changes artifact modifier in specified hero slot. Usually modifier is spell ID for spell scrolls or (NO_ART_MOD).
!#VA(hero:x);   Hero ID or (CURRENT_HERO)
!#VA(slot:x);   Slot ID (backpack is supported).
!#VA(artMod:x); Artifact modifier.

!!HE(hero):Z?(heroStruct:y);

!!if|(slot)<(ART_SLOT_FIRST)/(slot)>(ART_SLOT_LAST);
  !!SN:F^ShowErmError^/^GetArtAtSlot: invalid artifact slot ID: %(slot)^;
  !!FU:E;
!!en;

!!if&(slot)>=(ART_SLOT_EQUIPPED_FIRST)/(slot)<=(ART_SLOT_EQUIPPED_LAST);
  !!VR(artHandlePtr:y):+S(slot) *8 +301 +(heroStruct);
!!el;
  !!VR(artHandlePtr:y):+S(slot) -(ART_SLOT_EQUIPPED_LAST) -1 *8 +468 +(heroStruct);
!!en;

!!UN:C(artHandlePtr)/4/(UNC_INT)/(artMod);

!?FU(AddArtToHero);
; Adds artifact to hero, trying to equip it first and fallbacking to putting in backpack. Returns success flag.
; Automatically builds combo arts and checks scenario win conditions.
!#VA(hero:x);   ID of hero to equip artifact to.
!#VA(art:x);    ID of artifact to equip.
!#VA(artMod:x); Artifact modifier or (NO_ART_MOD). For spell scrolls its spell ID. For other artifacts the value is usually ignored.
              ; Custom artifact modifiers may be implemented. Artifact modifier is always carried with artifact by game functions.
!#VA(result:x); Boolean. Success flag.

!!HE(hero):Z?(heroStruct:y);
!!VR(savedV1:y):Sv1;
!!SN:E7431164/(CALLCONV_CDECL)/(heroStruct)/(art)/(artMod);
!!VR(result):Sv1 &1;
!!VRv1:S(savedV1);

!?FU(EquipArtToSlot);
; Tries to put artifact to specified hero doll slot, triggering OnEquipArt event. Returns success flag.
!#VA(hero:x);   ID of hero to equip artifact to.
!#VA(art:x);    ID of artifact to equip.
!#VA(artMod:x); Artifact modifier or (NO_ART_MOD). For spell scrolls its spell ID. For other artifacts the value is usually ignored.
              ; Custom artifact modifiers may be implemented. Artifact modifier is always carried with artifact by game functions.
!#VA(slot:x);   ID of hero doll slot to put artifact in or (NO_ART_SLOT) for autodetection.
!#VA(result:x); Boolean. Success flag.

!!if|(slot)<(NO_ART_SLOT)/(slot)>(ART_SLOT_MISC_5);
  !!VR(result):S(FALSE);
  !!FU:E;
!!en;

!!UN:C(GAME_MANAGER)/(UNC_INT)/?(gameManager:y);
!!HE(hero):Z?(heroStruct:y);
!!VR(savedV1:y):Sv1;
!!SN:E5123184/(CALLCONV_THISCALL)/(heroStruct)/?(art)/(slot);
!!VR(result):Sv1 &1;
!!VRv1:S(savedV1);

!?FU(UnequipArtFromSlot);
; Tries to unquip artifact from specified hero doll slot, triggering OnUnequipArt event.
!#VA(hero:x); ID of hero to unequip artifact to.
!#VA(slot:x); ID of hero doll slot to unequip artifact from.

!!HE(hero):Z?(heroStruct:y);
!!SN:E5123648/(CALLCONV_THISCALL)/(heroStruct)/(slot);

!?FU(GetMaxArtifactId);
; Returns ID of the last supported artifact in game. Some plugins, extending creature limit, add many blank
; artifacts, resulting in max ID = 999, for instance.
!#VA(result:x);

!!VR(result):S(ART_LAST_WOG);
; ============ END ARTIFACTS ============


; The following contents were created by Era Project Team.


; =============== TEXT ==================
!?FU(GetTextFileString);
; Get strings from text resources
!#VA(txtFilename:x);                    [filename of the text]
!#VA(rowIndex:x);                       [index of row, starts from 0]
!#VA(string:x);                         [returned string]

; Standarize the filename
!!FU(StrToLower):Pz(txtFilename)/?(text:z);
; Remove filename extension (if applicable)
!!SN:K(text)/?(size:y);
!!VR(index:y):S(size) -4;
!!SN:K(text)/(index)/?(character:z);
!!FU(Substr)&(character)=^.^:P(text)/0/-4/?(text);

!!if&(text)=^randtvrn^;
  !!VR(address:y):S6910692;             [random tavern info]
!!el&(text)=^arraytxt^;
  !!VR(address):S6971564;               [array text]
!!el&(text)=^genrltxt^;
  !!VR(address):S6970820;               [general text]
!!el&(text)=^tcommand^;
  !!VR(address):S6972152;               [TCommand]
!!el&(text)=^artevent^;
  !!VR(address):S6909120;               [artifact events]
!!el&(text)=^crgen1^;
  !!VR(address):S6886304;               [creature generator 1]
!!el&(text)=^crgen4^;
  !!VR(address):S6887052;               [creature generator 4]
!!el&(text)=^dwelling^;
  !!VR(address):S6972144;               [dwelling]
!!el&(text)=^minename^;
  !!VR(address):S6968376;               [mine names]
!!el&(text)=^objnames^;
  !!VR(address):S6974640;               [object names]
!!el&(text)=^plcolors^;
  !!VR(address):S6976900;               [player colour]
!!el&(text)=^priskill^;
  !!VR(address):S6974556;               [primary skills]
!!el&(text)=^restypes^;
  !!VR(address):S6968208;               [resources]
!!el&(text)=^skilllev^;
  !!VR(address):S6979432;               [secondary skill levels]
!!el&(text)=^advevent^;
  !!VR(address):S6908520;               [adventure map object events]
!!el;
  !!VR(string):Z^Wrong txt filename!^;
  !!FU:E;
!!en;

; @Master Of Puppets
!!UN:C(address)/(UNC_INT)/?(value:y);
!!VR(address2:y):S(value) +32;
!!UN:C(address2)/(UNC_INT)/?(value3:y);
!!VR(address3:y):S(rowIndex) *4 +(value3);
!!UN:C(address3)/(UNC_INT)/?(value4:y);
!!SN:X?(value5:y) X(value4) X?z1 X(value5);
!!VR(string):Z^%z1^;

!?FU(GetTextTableString);
; Get or set string in a text table file
!#VA(txtFilename:x);                    [filename of the text table]
!#VA(rowIndex:x);                       [index of row]
!#VA(colIndex:x);                       [index of column]
!#VA(string:x);                         [returend string]

; Standarize the filename
!!FU(StrToLower):Pz(txtFilename)/?(text:z);
; Reove filename extension (if applicable)
!!SN:K(text)/?(size:y);
!!VR(index:y):S(size) -4;
!!SN:K(text)/(index)/?(character:z);
!!FU(Substr)&(character)=^.^:P(text)/0/-4/?(text);

!!if&(text)=^help^;
  !!VR(address:y):S6976896;
!!el&(text)=^znpc00^;
  !!VR(address:y):S42338084;
!!el;
  !!VR(string):Z^Wrong txt filename!^;
  !!FU:E;
!!en;

!!VR(savedV1:y):Sv1;

!!SN:E7827723/(CALLCONV_CDECL)/(rowIndex)/(colIndex)/(address);
!!SN:Bv1/d/?(text:z);
!!VR(string):Z(text);

!!VRv1:S(savedV1);
; =============== TEXT ==================

; ============= H3QUEST =================
!?FU(H3Quests_RefreshData);
!#VA(forceRefreshText:x);
; change text and pictures for the quests guards/seerhuts/questlogs to actual one
; call that function after all replacemnent procedures; By default game executes that once at the end of new day
; also makes sense to affect the quest messages after changing hero/artifact/creature names
!!UN:C(GAME_MANAGER)/4/?(gameMgr:y); // get combat
!!VR(questsVector:y):S(gameMgr) +129904 +176; // game mgr +0x1FB70 mainStructList +0xB0 H3Vector<H3Quests*>
!!UN:C(questsVector)/4/4/?(first:y) C(questsVector)/8/4/?(end:y); // get vetor'start/end
!!VR(size:y):S(end) -(first) Sd>>2; // take size

!!if&(size);
  !!VR(savedV1:y):Sv1; // save v1

  !!re i/0/(size)/1/-1; // loop all H3Quests*
    !!VR(needToRefreshText:y):S(forceRefreshText);
    !!VR(offset:y):Si Sd<<2;

    !!UN:C(first)/(offset)/4/?(quest:y); // take Quest*
    !!UN:C(quest)/4/?(virtTable:y); // get Quest VTable

    !!UN:C(virtTable)/32/4/?(typeFunc:y); // get Quest Type Function addres

    !!SN:E(typeFunc)/(CALLCONV_THISCALL)/(quest);
    !!VR(questType:y):Sv1;
    !!if&(questType)=(QUEST_TYPE_DEFEAT_MONSTER);
      !!UN:C(quest)/68/4/?(packedCoords:y); // get target mon mixed pos
      !!UN:C(quest)/72/4/?q; get assumed mon type at coordinates

      !#VA(x:y) (y:y) (z:y);
      !!SN:E7413577/1/?(x)/?(y)/?(z)/(packedCoords); // unpack mon pos
      !!OB(x)/(y)/(z):T?t U?s; // get real mon type at coordinates

      !!if&t=(OBJ_MONSTER)/s<>(NO_MON)/s<>q; if they are different
        !!UN:C(quest)/72/4/s; set new quest mon type
        !!VR(needToRefreshText):S(TRUE);
      !!en;
    !!en;

    !!if&(needToRefreshText);
      !!re k/0/2; loop quest's messages
        !!VR(propString:y):Sk*16 +8 +(quest); take str pointers
        !!SN:E4210928/(CALLCONV_THISCALL)/(propString); clear original strings 0x4040F0
      !!en;
      !!UN:C(virtTable)/56/4/?(setTextFunct:y);
      !!SN:E(setTextFunct)/(CALLCONV_THISCALL)/(quest); set text function
    !!en;
  !!en;
  !!VRv1:S(savedV1:y); // restore v1
!!en;
; ============= H3QUEST END =================
